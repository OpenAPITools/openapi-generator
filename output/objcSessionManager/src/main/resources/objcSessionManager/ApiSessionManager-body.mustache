#import <ISO8601/ISO8601.h>

#import "{{classPrefix}}ApiSessionManager.h"
#import "{{classPrefix}}JSONRequestSerializer.h"
#import "{{classPrefix}}JSONResponseSerializer.h"
#import "{{classPrefix}}QueryParamCollection.h"
#import "{{classPrefix}}Object.h"
#import "{{classPrefix}}DefaultConfiguration.h"

#define {{classPrefix}}DebugLog(format, ...) [{{classPrefix}}ApiSessionManager debugLog:[NSString stringWithFormat:@"%s", __PRETTY_FUNCTION__] message: format, ##__VA_ARGS__];


NSString * const {{classPrefix}}ResponseObjectErrorKey = @"{{classPrefix}}ResponseObject";


@interface {{classPrefix}}ApiSessionManager ()

@property (nonatomic, strong, readwrite) id<{{classPrefix}}Configuration> configuration;

@end

@implementation {{classPrefix}}ApiSessionManager

- (instancetype)init {

    return [self initWithConfiguration:[{{classPrefix}}DefaultConfiguration sharedConfiguration]];
}

- (instancetype)initWithBaseURL:(NSURL *)url {

    return [self initWithBaseURL:url
                   configuration:[{{classPrefix}}DefaultConfiguration sharedConfiguration]];
    
}

- (instancetype)initWithConfiguration:(id<{{classPrefix}}Configuration>)configuration {

    return [self initWithBaseURL:[NSURL URLWithString:configuration.host] configuration:configuration];
}

- (instancetype)initWithBaseURL:(NSURL *)url
                  configuration:(id<{{classPrefix}}Configuration>)configuration {

    self = [super initWithBaseURL:url];
    if (self) {
        _configuration = configuration;
    }

    return self;
}

- (NSURLSessionTask *)requestWithCompletionBlock:(NSString *)path
                                          method:(NSString *)method
                                      pathParams:(NSDictionary *)pathParams
                                     queryParams:(NSDictionary *)queryParams
                                      formParams:(NSDictionary *)formParams
                                           files:(NSDictionary *)files
                                            body:(id)body
                                    headerParams:(NSDictionary *)headerParams
                                    authSettings:(NSArray *)authSettings
                              requestContentType:(NSString *)requestContentType
                             responseContentType:(NSString *)responseContentType
                                    responseType:(NSString *)responseType
                                 completionBlock:(void (^)(id, NSError *))completionBlock {

    // setting request serializer
    if ([requestContentType isEqualToString:@"application/json"]) {
        self.requestSerializer = [{{classPrefix}}JSONRequestSerializer serializer];
    }
    else if ([requestContentType isEqualToString:@"application/x-www-form-urlencoded"]) {
        self.requestSerializer = [AFHTTPRequestSerializer serializer];
    }
    else if ([requestContentType isEqualToString:@"multipart/form-data"]) {
        self.requestSerializer = [AFHTTPRequestSerializer serializer];
    }
    else {
        NSAssert(false, @"unsupport request type %@", requestContentType);
    }
    
    // setting response serializer
    if ([responseContentType isEqualToString:@"application/json"]) {
        self.responseSerializer = [{{classPrefix}}JSONResponseSerializer serializer];
    }
    else {
        self.responseSerializer = [AFHTTPResponseSerializer serializer];
    }
    
    // sanitize parameters
    pathParams = [self sanitizeForSerialization:pathParams];
    queryParams = [self sanitizeForSerialization:queryParams];
    headerParams = [self sanitizeForSerialization:headerParams];
    formParams = [self sanitizeForSerialization:formParams];
    body = [self sanitizeForSerialization:body];
    
    // auth setting
    [self updateHeaderParams:&headerParams queryParams:&queryParams WithAuthSettings:authSettings];
    
    NSMutableString *resourcePath = [NSMutableString stringWithString:path];
    [pathParams enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
        [resourcePath replaceCharactersInRange:[resourcePath rangeOfString:[NSString stringWithFormat:@"%@%@%@", @"{", key, @"}"]]
                                    withString:[{{classPrefix}}ApiSessionManager escape:obj]];
    }];
    
    NSMutableURLRequest * request = nil;
    
    NSString* pathWithQueryParams = [self pathWithQueryParamsToString:resourcePath queryParams:queryParams];
    if ([pathWithQueryParams hasPrefix:@"/"]) {
        pathWithQueryParams = [pathWithQueryParams substringFromIndex:1];
    }
    
    NSString* urlString = [[NSURL URLWithString:pathWithQueryParams relativeToURL:self.baseURL] absoluteString];
    if (files.count > 0) {
        request = [self.requestSerializer multipartFormRequestWithMethod:@"POST"
                                                               URLString:urlString
                                                              parameters:nil
                                               constructingBodyWithBlock:^(id<AFMultipartFormData> formData) {
                                                   [formParams enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
                                                       NSString *objString = [self parameterToString:obj];
                                                       NSData *data = [objString dataUsingEncoding:NSUTF8StringEncoding];
                                                       [formData appendPartWithFormData:data name:key];
                                                   }];
                                                   [files enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
                                                       NSURL *filePath = (NSURL *)obj;
                                                       [formData appendPartWithFileURL:filePath name:key error:nil];
                                                   }];
                                               } error:nil];
    }
    else {
        if (formParams) {
            request = [self.requestSerializer requestWithMethod:method
                                                      URLString:urlString
                                                     parameters:formParams
                                                          error:nil];
        }
        if (body) {
            request = [self.requestSerializer requestWithMethod:method
                                                      URLString:urlString
                                                     parameters:body
                                                          error:nil];
        }
    }
    
    // request cache
    BOOL hasHeaderParams = false;
    if (headerParams != nil && [headerParams count] > 0) {
        hasHeaderParams = true;
    }

    if (self.configuration.offlineState) {
        {{classPrefix}}DebugLog(@"%@ cache forced", resourcePath);
        [request setCachePolicy:NSURLRequestReturnCacheDataDontLoad];
    }
    else if(!hasHeaderParams && [method isEqualToString:@"GET"] && self.configuration.cacheEnabled) {
        {{classPrefix}}DebugLog(@"%@ cache enabled", resourcePath);
        [request setCachePolicy:NSURLRequestUseProtocolCachePolicy];
    }
    else {
        {{classPrefix}}DebugLog(@"%@ cache disabled", resourcePath);
        [request setCachePolicy:NSURLRequestReloadIgnoringLocalCacheData];
    }
    
    if (hasHeaderParams) {
        for(NSString * key in [headerParams keyEnumerator]) {
            [request setValue:[headerParams valueForKey:key] forHTTPHeaderField:key];
        }
    }
    [self.requestSerializer setValue:responseContentType forHTTPHeaderField:@"Accept"];
    
    
    // Always disable cookies!
    [request setHTTPShouldHandleCookies:NO];
    
    NSURLSessionTask *task = nil;
    
    if ([responseType isEqualToString:@"NSURL*"]) {
        task = [self downloadTaskWithCompletionBlock:request completionBlock:^(id data, NSError *error) {
            completionBlock(data, error);
        }];
    }
    else {
        task = [self taskWithCompletionBlock:request completionBlock:^(id data, NSError *error) {
            completionBlock([self deserialize:data class:responseType], error);
        }];
    }
    
    [task resume];
    
    return task;
}

#pragma mark - Task Methods

- (NSURLSessionDataTask *) taskWithCompletionBlock: (NSURLRequest *)request
                      completionBlock: (void (^)(id, NSError *))completionBlock {
    
    NSURLSessionDataTask *task = [self dataTaskWithRequest:request completionHandler:^(NSURLResponse * _Nonnull response, id  _Nullable responseObject, NSError * _Nullable error) {
        if (error) {
            NSMutableDictionary *userInfo = [error.userInfo mutableCopy];
            if (responseObject) {
                // Add in the (parsed) response body.
                userInfo[{{classPrefix}}ResponseObjectErrorKey] = responseObject;
            }
            NSError *augmentedError = [error initWithDomain:error.domain code:error.code userInfo:userInfo];
            
            completionBlock(nil, augmentedError);
        } else {
            completionBlock(responseObject, nil);
        }
    }];
    
    return task;
}

- (NSURLSessionDownloadTask *) downloadTaskWithCompletionBlock: (NSURLRequest *)request
                              completionBlock: (void (^)(id, NSError *))completionBlock {
    
    id<{{classPrefix}}Configuration> config = self.configuration;
    
    NSURLSessionDownloadTask *task = [self downloadTaskWithRequest:request progress:nil destination:^NSURL * _Nonnull(NSURL * _Nonnull targetPath, NSURLResponse * _Nonnull response) {
        NSString *directory = nil;
        if (config.tempFolderPath) {
            directory = config.tempFolderPath;
        }
        else {
            directory = NSTemporaryDirectory();
        }
        
        NSDictionary *headers = nil;
        if ([response isKindOfClass:[NSHTTPURLResponse class]])
        {
            NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)response;
            headers = httpResponse.allHeaderFields;
        }
        
        NSString *filename = nil;
        if ([headers objectForKey:@"Content-Disposition"]) {
            
            NSString *pattern = @"filename=['\"]?([^'\"\\s]+)['\"]?";
            NSRegularExpression *regexp = [NSRegularExpression regularExpressionWithPattern:pattern
                                                                                    options:NSRegularExpressionCaseInsensitive
                                                                                      error:nil];
            NSString *contentDispositionHeader = [headers objectForKey:@"Content-Disposition"];
            NSTextCheckingResult *match = [regexp firstMatchInString:contentDispositionHeader
                                                             options:0
                                                               range:NSMakeRange(0, [contentDispositionHeader length])];
            filename = [contentDispositionHeader substringWithRange:[match rangeAtIndex:1]];
        }
        else {
            filename = [NSString stringWithFormat:@"%@", [[NSProcessInfo processInfo] globallyUniqueString]];
        }
        
        NSString *filepath = [directory stringByAppendingPathComponent:filename];
        NSURL *file = [NSURL fileURLWithPath:filepath];
        
        return file;
    } completionHandler:^(NSURLResponse * _Nonnull response, NSURL * _Nullable filePath, NSError * _Nullable error) {
        if (error) {
            completionBlock(nil, error);
        } else {
            completionBlock(filePath, nil);
        }
    }];
    
    return task;
}

#pragma mark - Serialization

- (void) updateHeaderParams:(NSDictionary *__autoreleasing *)headers
                queryParams:(NSDictionary *__autoreleasing *)querys
           WithAuthSettings:(NSArray *)authSettings {
    
    if (!authSettings || [authSettings count] == 0) {
        return;
    }
    
    NSMutableDictionary *headersWithAuth = [NSMutableDictionary dictionaryWithDictionary:*headers];
    NSMutableDictionary *querysWithAuth = [NSMutableDictionary dictionaryWithDictionary:*querys];
    
    id<{{classPrefix}}Configuration> config = self.configuration;
    for (NSString *auth in authSettings) {
        //NSDictionary *authSetting = [[config authSettings] objectForKey:auth];
        NSDictionary *authSetting = config.authSettings[auth];
        
        if (authSetting) {
            if ([authSetting[@"in"] isEqualToString:@"header"]) {
                [headersWithAuth setObject:authSetting[@"value"] forKey:authSetting[@"key"]];
            }
            else if ([authSetting[@"in"] isEqualToString:@"query"]) {
                [querysWithAuth setObject:authSetting[@"value"] forKey:authSetting[@"key"]];
            }
        }
    }
    
    *headers = [NSDictionary dictionaryWithDictionary:headersWithAuth];
    *querys = [NSDictionary dictionaryWithDictionary:querysWithAuth];
}

- (id)sanitizeForSerialization:(id)object {

    if (object == nil) {
        return nil;
    }
    else if ([object isKindOfClass:[NSString class]] || [object isKindOfClass:[NSNumber class]] || [object isKindOfClass:[{{classPrefix}}QueryParamCollection class]]) {
        return object;
    }
    else if ([object isKindOfClass:[NSDate class]]) {
        return [object ISO8601String];
    }
    else if ([object isKindOfClass:[NSArray class]]) {
        NSArray *objectArray = object;
        NSMutableArray *sanitizedObjs = [NSMutableArray arrayWithCapacity:[objectArray count]];
        [object enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
            if (obj) {
                [sanitizedObjs addObject:[self sanitizeForSerialization:obj]];
            }
        }];
        return sanitizedObjs;
    }
    else if ([object isKindOfClass:[NSDictionary class]]) {
        NSDictionary *objectDict = object;
        NSMutableDictionary *sanitizedObjs = [NSMutableDictionary dictionaryWithCapacity:[objectDict count]];
        [object enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
            if (obj) {
                [sanitizedObjs setValue:[self sanitizeForSerialization:obj] forKey:key];
            }
        }];
        return sanitizedObjs;
    }
    else if ([object isKindOfClass:[{{classPrefix}}Object class]]) {
        return [object toDictionary];
    }
    else {
        NSException *e = [NSException
                          exceptionWithName:@"InvalidObjectArgumentException"
                          reason:[NSString stringWithFormat:@"*** The argument object: %@ is invalid", object]
                          userInfo:nil];
        @throw e;
    }
}

- (id)deserialize:(id)data class:(NSString *)class {

    NSRegularExpression *regexp = nil;
    NSTextCheckingResult *match = nil;
    NSMutableArray *resultArray = nil;
    NSMutableDictionary *resultDict = nil;
    NSString *innerType = nil;
    
    // return nil if data is nil or class is nil
    if (!data || !class) {
        return nil;
    }
    
    // remove "*" from class, if ends with "*"
    if ([class hasSuffix:@"*"]) {
        class = [class substringToIndex:[class length] - 1];
    }
    
    // pure object
    if ([class isEqualToString:@"NSObject"]) {
        return data;
    }
    
    // list of models
    NSString *arrayOfModelsPat = @"NSArray<(.+)>";
    regexp = [NSRegularExpression regularExpressionWithPattern:arrayOfModelsPat
                                                       options:NSRegularExpressionCaseInsensitive
                                                         error:nil];
    
    match = [regexp firstMatchInString:class
                               options:0
                                 range:NSMakeRange(0, [class length])];
    
    if (match) {
        NSArray *dataArray = data;
        innerType = [class substringWithRange:[match rangeAtIndex:1]];
        
        resultArray = [NSMutableArray arrayWithCapacity:[dataArray count]];
        [data enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
            [resultArray addObject:[self deserialize:obj class:innerType]];
        }
         ];
        
        return resultArray;
    }
    
    // list of primitives
    NSString *arrayOfPrimitivesPat = @"NSArray\\* /\\* (.+) \\*/";
    regexp = [NSRegularExpression regularExpressionWithPattern:arrayOfPrimitivesPat
                                                       options:NSRegularExpressionCaseInsensitive
                                                         error:nil];
    match = [regexp firstMatchInString:class
                               options:0
                                 range:NSMakeRange(0, [class length])];
    
    if (match) {
        NSArray *dataArray = data;
        innerType = [class substringWithRange:[match rangeAtIndex:1]];
        
        resultArray = [NSMutableArray arrayWithCapacity:[dataArray count]];
        [data enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
            [resultArray addObject:[self deserialize:obj class:innerType]];
        }];
        
        return resultArray;
    }
    
    // map
    NSString *dictPat = @"NSDictionary\\* /\\* (.+?), (.+) \\*/";
    regexp = [NSRegularExpression regularExpressionWithPattern:dictPat
                                                       options:NSRegularExpressionCaseInsensitive
                                                         error:nil];
    match = [regexp firstMatchInString:class
                               options:0
                                 range:NSMakeRange(0, [class length])];
    
    if (match) {
        NSDictionary *dataDict = data;
        NSString *valueType = [class substringWithRange:[match rangeAtIndex:2]];
        
        resultDict = [NSMutableDictionary dictionaryWithCapacity:[dataDict count]];
        [data enumerateKeysAndObjectsUsingBlock:^(id key, id obj, BOOL *stop) {
            [resultDict setValue:[self deserialize:obj class:valueType] forKey:key];
        }];
        
        return resultDict;
    }
    
    // primitives
    NSArray *primitiveTypes = @[@"NSString", @"NSDate", @"NSNumber"];
    
    if ([primitiveTypes containsObject:class]) {
        if ([class isEqualToString:@"NSString"]) {
            return [NSString stringWithString:data];
        }
        else if ([class isEqualToString:@"NSDate"]) {
            return [NSDate dateWithISO8601String:data];
        }
        else if ([class isEqualToString:@"NSNumber"]) {
            // NSNumber from NSNumber
            if ([data isKindOfClass:[NSNumber class]]) {
                return data;
            }
            else if ([data isKindOfClass:[NSString class]]) {
                // NSNumber (NSCFBoolean) from NSString
                if ([[data lowercaseString] isEqualToString:@"true"] || [[data lowercaseString] isEqualToString:@"false"]) {
                    return [NSNumber numberWithBool:[data boolValue]];
                    // NSNumber from NSString
                } else {
                    NSNumberFormatter *formatter = [[NSNumberFormatter alloc] init];
                    formatter.numberStyle = NSNumberFormatterDecimalStyle;
                    return [formatter numberFromString:data];
                }
            }
        }
    }
    
    // model
    Class ModelClass = NSClassFromString(class);
    if ([ModelClass instancesRespondToSelector:@selector(initWithDictionary:error:)]) {
        return [[ModelClass alloc] initWithDictionary:data error:nil];
    }
    
    return nil;
}

- (NSString *)pathWithQueryParamsToString:(NSString *)path
                              queryParams:(NSDictionary *)queryParams {

    NSString * separator = nil;
    int counter = 0;
    
    NSMutableString * requestUrl = [NSMutableString stringWithFormat:@"%@", path];
    if (queryParams != nil){
        for(NSString * key in [queryParams keyEnumerator]){
            if (counter == 0) separator = @"?";
            else separator = @"&";
            id queryParam = [queryParams valueForKey:key];
            if ([queryParam isKindOfClass:[NSString class]]){
                [requestUrl appendString:[NSString stringWithFormat:@"%@%@=%@", separator,
                                          [{{classPrefix}}ApiSessionManager escape:key], [{{classPrefix}}ApiSessionManager escape:[queryParams valueForKey:key]]]];
            }
            else if ([queryParam isKindOfClass:[{{classPrefix}}QueryParamCollection class]]){
                {{classPrefix}}QueryParamCollection * coll = ({{classPrefix}}QueryParamCollection*) queryParam;
                NSArray* values = [coll values];
                NSString* format = [coll format];
                
                if ([format isEqualToString:@"csv"]) {
                    [requestUrl appendString:[NSString stringWithFormat:@"%@%@=%@", separator,
                                              [{{classPrefix}}ApiSessionManager escape:key], [NSString stringWithFormat:@"%@", [values componentsJoinedByString:@","]]]];
                    
                }
                else if ([format isEqualToString:@"tsv"]) {
                    [requestUrl appendString:[NSString stringWithFormat:@"%@%@=%@", separator,
                                              [{{classPrefix}}ApiSessionManager escape:key], [NSString stringWithFormat:@"%@", [values componentsJoinedByString:@"\t"]]]];
                    
                }
                else if ([format isEqualToString:@"pipes"]) {
                    [requestUrl appendString:[NSString stringWithFormat:@"%@%@=%@", separator,
                                              [{{classPrefix}}ApiSessionManager escape:key], [NSString stringWithFormat:@"%@", [values componentsJoinedByString:@"|"]]]];
                    
                }
                else if ([format isEqualToString:@"multi"]) {
                    for(id obj in values) {
                        [requestUrl appendString:[NSString stringWithFormat:@"%@%@=%@", separator,
                                                  [{{classPrefix}}ApiSessionManager escape:key], [NSString stringWithFormat:@"%@", obj]]];
                        counter += 1;
                    }
                    
                }
            }
            else {
                [requestUrl appendString:[NSString stringWithFormat:@"%@%@=%@", separator,
                                          [{{classPrefix}}ApiSessionManager escape:key], [NSString stringWithFormat:@"%@", [queryParams valueForKey:key]]]];
            }
            
            counter += 1;
        }
    }
    return requestUrl;
}

- (NSString *)parameterToString:(id)param {

    if ([param isKindOfClass:[NSString class]]) {
        return param;
    }
    else if ([param isKindOfClass:[NSNumber class]]) {
        return [param stringValue];
    }
    else if ([param isKindOfClass:[NSDate class]]) {
        return [param ISO8601String];
    }
    else if ([param isKindOfClass:[NSArray class]]) {
        NSMutableArray *mutableParam;
        [param enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
            [mutableParam addObject:[self parameterToString:obj]];
        }];
        return [mutableParam componentsJoinedByString:@","];
    }
    else {
        NSException *e = [NSException
                          exceptionWithName:@"InvalidObjectArgumentException"
                          reason:[NSString stringWithFormat:@"*** The argument object: %@ is invalid", param]
                          userInfo:nil];
        @throw e;
    }
}

#pragma mark - Utility Methods

/*
 * Detect `Accept` from accepts
 */
+ (NSString *)selectHeaderAccept:(NSArray *)accepts {
    if (accepts == nil || [accepts count] == 0) {
        return @"";
    }
    
    NSMutableArray *lowerAccepts = [[NSMutableArray alloc] initWithCapacity:[accepts count]];
    for (NSString *string in accepts) {
        NSString * lowerAccept = [string lowercaseString];
        if ([lowerAccept containsString:@"application/json"]) {
            return @"application/json";
        }
        [lowerAccepts addObject:lowerAccept];
    }
    
    if (lowerAccepts.count == 1) {
        return [lowerAccepts firstObject];
    }
    
    return [lowerAccepts componentsJoinedByString:@", "];
}

/*
 * Detect `Content-Type` from contentTypes
 */
+ (NSString *)selectHeaderContentType:(NSArray *)contentTypes {
    if (contentTypes == nil || [contentTypes count] == 0) {
        return @"application/json";
    }
    
    NSMutableArray *lowerContentTypes = [[NSMutableArray alloc] initWithCapacity:[contentTypes count]];
    [contentTypes enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL *stop) {
        [lowerContentTypes addObject:[obj lowercaseString]];
    }];
    
    if ([lowerContentTypes containsObject:@"application/json"]) {
        return @"application/json";
    }
    else {
        return lowerContentTypes[0];
    }
}

+ (NSString*)escape:(id)unescaped {
    if ([unescaped isKindOfClass:[NSString class]]){
        return (NSString *)CFBridgingRelease
        (CFURLCreateStringByAddingPercentEscapes(
                                                 NULL,
                                                 (__bridge CFStringRef) unescaped,
                                                 NULL,
                                                 (CFStringRef)@"!*'();:@&=+$,/?%#[]",
                                                 kCFStringEncodingUTF8));
    }
    else {
        return [NSString stringWithFormat:@"%@", unescaped];
    }
}

#pragma mark - Log Methods

+ (void)debugLog:(NSString *)method
         message:(NSString *)format, ... {
    NSMutableString *message = [NSMutableString stringWithCapacity:1];
    
    if (method) {
        [message appendString:[NSString stringWithFormat:@"%@: ", method]];
    }
    
    va_list args;
    va_start(args, format);
    
    [message appendString:[[NSString alloc] initWithFormat:format arguments:args]];
    
    NSLog(@"%@", message);
    
    va_end(args);
}

@end
