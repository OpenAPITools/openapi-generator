/*
 * OpenAPI Petstore
 *
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package petstoreserver

import (
	"fmt"
	"os"
	"net/http"

	"github.com/gin-gonic/gin"
)

// AddPetResponse405 controller response type
type AddPetResponse405 struct {
}

// AddPetHeaders : request headers
type AddPetHeaders struct {
}

// AddPetQueryParams : query/GET request parameters
type AddPetQueryParams struct {
}

// AddPetPathParams : in path request parameters
type AddPetPathParams struct {
}

// AddPetFormParams : form/POST request parameters
type AddPetFormParams struct {
}

// AddPetRequest payload object
type AddPetRequest struct {
	Headers *AddPetHeaders
	QueryParams *AddPetQueryParams
	PathParams *AddPetPathParams
	FormParams *AddPetFormParams
}

// Bind : gin bind
func (o *AddPetRequest) Bind (c *gin.Context) error {
    var err error

	return err
}

// NewAddPetHandler constructor
func NewAddPetHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case AddPetResponse405:
			render(c, 405, resp)
		default:
			err := fmt.Sprintf("AddPet() command response type mismatch. [%T] != ENUM[AddPetResponse405, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// DeletePetResponse400 controller response type
type DeletePetResponse400 struct {
}

// DeletePetHeaders : request headers
type DeletePetHeaders struct {
	ApiKey string `json:"api_key,omitempty" header:"api_key" binding:""`
}

// DeletePetQueryParams : query/GET request parameters
type DeletePetQueryParams struct {
}

// DeletePetPathParams : in path request parameters
type DeletePetPathParams struct {
	// Pet id to delete
	PetId int64 `json:"petId" uri:"petId" binding:"required"`
}

// DeletePetFormParams : form/POST request parameters
type DeletePetFormParams struct {
}

// DeletePetRequest payload object
type DeletePetRequest struct {
	Headers *DeletePetHeaders
	QueryParams *DeletePetQueryParams
	PathParams *DeletePetPathParams
	FormParams *DeletePetFormParams
}

// Bind : gin bind
func (o *DeletePetRequest) Bind (c *gin.Context) error {
    var err error

    o.Headers = &DeletePetHeaders{}
	err = c.ShouldBindHeader(o.Headers)
	if err != nil {
		return err
	}

    o.PathParams = &DeletePetPathParams{}
	err = c.ShouldBindUri(o.PathParams)
	if err != nil {
		return err
	}

	return err
}

// NewDeletePetHandler constructor
func NewDeletePetHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case DeletePetResponse400:
			render(c, 400, resp)
		default:
			err := fmt.Sprintf("DeletePet() command response type mismatch. [%T] != ENUM[DeletePetResponse400, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// FindPetsByStatusResponse200 controller response type
type FindPetsByStatusResponse200 struct {
	Payload []Pet
}

// FindPetsByStatusResponse400 controller response type
type FindPetsByStatusResponse400 struct {
}

// FindPetsByStatusHeaders : request headers
type FindPetsByStatusHeaders struct {
}

// FindPetsByStatusQueryParams : query/GET request parameters
type FindPetsByStatusQueryParams struct {
	// Status values that need to be considered for filter
	Status []string `json:"status" form:"status" binding:"required"`
}

// FindPetsByStatusPathParams : in path request parameters
type FindPetsByStatusPathParams struct {
}

// FindPetsByStatusFormParams : form/POST request parameters
type FindPetsByStatusFormParams struct {
}

// FindPetsByStatusRequest payload object
type FindPetsByStatusRequest struct {
	Headers *FindPetsByStatusHeaders
	QueryParams *FindPetsByStatusQueryParams
	PathParams *FindPetsByStatusPathParams
	FormParams *FindPetsByStatusFormParams
}

// Bind : gin bind
func (o *FindPetsByStatusRequest) Bind (c *gin.Context) error {
    var err error

    o.QueryParams = &FindPetsByStatusQueryParams{}
	err = c.ShouldBindQuery(o.QueryParams)
	if err != nil {
		return err
	}

	return err
}

// NewFindPetsByStatusHandler constructor
func NewFindPetsByStatusHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case FindPetsByStatusResponse200:
			render(c, 200, resp)
		case FindPetsByStatusResponse400:
			render(c, 400, resp)
		default:
			err := fmt.Sprintf("FindPetsByStatus() command response type mismatch. [%T] != ENUM[FindPetsByStatusResponse200, FindPetsByStatusResponse400, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// FindPetsByTagsResponse200 controller response type
type FindPetsByTagsResponse200 struct {
	Payload []Pet
}

// FindPetsByTagsResponse400 controller response type
type FindPetsByTagsResponse400 struct {
}

// FindPetsByTagsHeaders : request headers
type FindPetsByTagsHeaders struct {
}

// FindPetsByTagsQueryParams : query/GET request parameters
type FindPetsByTagsQueryParams struct {
	// Tags to filter by
	Tags []string `json:"tags" form:"tags" binding:"required"`
}

// FindPetsByTagsPathParams : in path request parameters
type FindPetsByTagsPathParams struct {
}

// FindPetsByTagsFormParams : form/POST request parameters
type FindPetsByTagsFormParams struct {
}

// FindPetsByTagsRequest payload object
type FindPetsByTagsRequest struct {
	Headers *FindPetsByTagsHeaders
	QueryParams *FindPetsByTagsQueryParams
	PathParams *FindPetsByTagsPathParams
	FormParams *FindPetsByTagsFormParams
}

// Bind : gin bind
func (o *FindPetsByTagsRequest) Bind (c *gin.Context) error {
    var err error

    o.QueryParams = &FindPetsByTagsQueryParams{}
	err = c.ShouldBindQuery(o.QueryParams)
	if err != nil {
		return err
	}

	return err
}

// NewFindPetsByTagsHandler constructor
func NewFindPetsByTagsHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case FindPetsByTagsResponse200:
			render(c, 200, resp)
		case FindPetsByTagsResponse400:
			render(c, 400, resp)
		default:
			err := fmt.Sprintf("FindPetsByTags() command response type mismatch. [%T] != ENUM[FindPetsByTagsResponse200, FindPetsByTagsResponse400, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// GetPetByIdResponse200 controller response type
type GetPetByIdResponse200 struct {
	Pet
}

// GetPetByIdResponse400 controller response type
type GetPetByIdResponse400 struct {
}

// GetPetByIdResponse404 controller response type
type GetPetByIdResponse404 struct {
}

// GetPetByIdHeaders : request headers
type GetPetByIdHeaders struct {
}

// GetPetByIdQueryParams : query/GET request parameters
type GetPetByIdQueryParams struct {
}

// GetPetByIdPathParams : in path request parameters
type GetPetByIdPathParams struct {
	// ID of pet to return
	PetId int64 `json:"petId" uri:"petId" binding:"required"`
}

// GetPetByIdFormParams : form/POST request parameters
type GetPetByIdFormParams struct {
}

// GetPetByIdRequest payload object
type GetPetByIdRequest struct {
	Headers *GetPetByIdHeaders
	QueryParams *GetPetByIdQueryParams
	PathParams *GetPetByIdPathParams
	FormParams *GetPetByIdFormParams
}

// Bind : gin bind
func (o *GetPetByIdRequest) Bind (c *gin.Context) error {
    var err error

    o.PathParams = &GetPetByIdPathParams{}
	err = c.ShouldBindUri(o.PathParams)
	if err != nil {
		return err
	}

	return err
}

// NewGetPetByIdHandler constructor
func NewGetPetByIdHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case GetPetByIdResponse200:
			render(c, 200, resp)
		case GetPetByIdResponse400:
			render(c, 400, resp)
		case GetPetByIdResponse404:
			render(c, 404, resp)
		default:
			err := fmt.Sprintf("GetPetById() command response type mismatch. [%T] != ENUM[GetPetByIdResponse200, GetPetByIdResponse400, GetPetByIdResponse404, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// UpdatePetResponse400 controller response type
type UpdatePetResponse400 struct {
}

// UpdatePetResponse404 controller response type
type UpdatePetResponse404 struct {
}

// UpdatePetResponse405 controller response type
type UpdatePetResponse405 struct {
}

// UpdatePetHeaders : request headers
type UpdatePetHeaders struct {
}

// UpdatePetQueryParams : query/GET request parameters
type UpdatePetQueryParams struct {
}

// UpdatePetPathParams : in path request parameters
type UpdatePetPathParams struct {
}

// UpdatePetFormParams : form/POST request parameters
type UpdatePetFormParams struct {
}

// UpdatePetRequest payload object
type UpdatePetRequest struct {
	Headers *UpdatePetHeaders
	QueryParams *UpdatePetQueryParams
	PathParams *UpdatePetPathParams
	FormParams *UpdatePetFormParams
}

// Bind : gin bind
func (o *UpdatePetRequest) Bind (c *gin.Context) error {
    var err error

	return err
}

// NewUpdatePetHandler constructor
func NewUpdatePetHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case UpdatePetResponse400:
			render(c, 400, resp)
		case UpdatePetResponse404:
			render(c, 404, resp)
		case UpdatePetResponse405:
			render(c, 405, resp)
		default:
			err := fmt.Sprintf("UpdatePet() command response type mismatch. [%T] != ENUM[UpdatePetResponse400, UpdatePetResponse404, UpdatePetResponse405, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// UpdatePetWithFormResponse405 controller response type
type UpdatePetWithFormResponse405 struct {
}

// UpdatePetWithFormHeaders : request headers
type UpdatePetWithFormHeaders struct {
}

// UpdatePetWithFormQueryParams : query/GET request parameters
type UpdatePetWithFormQueryParams struct {
}

// UpdatePetWithFormPathParams : in path request parameters
type UpdatePetWithFormPathParams struct {
	// ID of pet that needs to be updated
	PetId int64 `json:"petId" uri:"petId" binding:"required"`
}

// UpdatePetWithFormFormParams : form/POST request parameters
type UpdatePetWithFormFormParams struct {
	// Updated name of the pet
	Name string `json:"name,omitempty" form:"name" binding:""`
	// Updated status of the pet
	Status string `json:"status,omitempty" form:"status" binding:""`
}

// UpdatePetWithFormRequest payload object
type UpdatePetWithFormRequest struct {
	Headers *UpdatePetWithFormHeaders
	QueryParams *UpdatePetWithFormQueryParams
	PathParams *UpdatePetWithFormPathParams
	FormParams *UpdatePetWithFormFormParams
}

// Bind : gin bind
func (o *UpdatePetWithFormRequest) Bind (c *gin.Context) error {
    var err error

    o.PathParams = &UpdatePetWithFormPathParams{}
	err = c.ShouldBindUri(o.PathParams)
	if err != nil {
		return err
	}

    o.FormParams = &UpdatePetWithFormFormParams{}
	err = c.ShouldBind(o.FormParams)
	if err != nil {
		return err
	}

	return err
}

// NewUpdatePetWithFormHandler constructor
func NewUpdatePetWithFormHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case UpdatePetWithFormResponse405:
			render(c, 405, resp)
		default:
			err := fmt.Sprintf("UpdatePetWithForm() command response type mismatch. [%T] != ENUM[UpdatePetWithFormResponse405, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// UploadFileResponse200 controller response type
type UploadFileResponse200 struct {
	ApiResponse
}

// UploadFileHeaders : request headers
type UploadFileHeaders struct {
}

// UploadFileQueryParams : query/GET request parameters
type UploadFileQueryParams struct {
}

// UploadFilePathParams : in path request parameters
type UploadFilePathParams struct {
	// ID of pet to update
	PetId int64 `json:"petId" uri:"petId" binding:"required"`
}

// UploadFileFormParams : form/POST request parameters
type UploadFileFormParams struct {
	// Additional data to pass to server
	AdditionalMetadata string `json:"additionalMetadata,omitempty" form:"additionalMetadata" binding:""`
	// file to upload
	File *os.File `json:"file,omitempty" form:"file" binding:""`
}

// UploadFileRequest payload object
type UploadFileRequest struct {
	Headers *UploadFileHeaders
	QueryParams *UploadFileQueryParams
	PathParams *UploadFilePathParams
	FormParams *UploadFileFormParams
}

// Bind : gin bind
func (o *UploadFileRequest) Bind (c *gin.Context) error {
    var err error

    o.PathParams = &UploadFilePathParams{}
	err = c.ShouldBindUri(o.PathParams)
	if err != nil {
		return err
	}

    o.FormParams = &UploadFileFormParams{}
	err = c.ShouldBind(o.FormParams)
	if err != nil {
		return err
	}

	return err
}

// NewUploadFileHandler constructor
func NewUploadFileHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case UploadFileResponse200:
			render(c, 200, resp)
		default:
			err := fmt.Sprintf("UploadFile() command response type mismatch. [%T] != ENUM[UploadFileResponse200, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

