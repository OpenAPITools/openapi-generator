/*
 * OpenAPI Petstore
 *
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package petstoreserver

import (
	"fmt"
	"net/http"

	"github.com/gin-gonic/gin"
)

// CreateUserResponse0 controller response type
type CreateUserResponse0 struct {
}

// CreateUserHeaders : request headers
type CreateUserHeaders struct {
}

// CreateUserQueryParams : query/GET request parameters
type CreateUserQueryParams struct {
}

// CreateUserPathParams : in path request parameters
type CreateUserPathParams struct {
}

// CreateUserFormParams : form/POST request parameters
type CreateUserFormParams struct {
}

// CreateUserRequest payload object
type CreateUserRequest struct {
	Headers *CreateUserHeaders
	QueryParams *CreateUserQueryParams
	PathParams *CreateUserPathParams
	FormParams *CreateUserFormParams
}

// Bind : gin bind
func (o *CreateUserRequest) Bind (c *gin.Context) error {
    var err error

	return err
}

// NewCreateUserHandler constructor
func NewCreateUserHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case CreateUserResponse0:
			render(c, 0, resp)
		default:
			err := fmt.Sprintf("CreateUser() command response type mismatch. [%T] != ENUM[CreateUserResponse0, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// CreateUsersWithArrayInputResponse0 controller response type
type CreateUsersWithArrayInputResponse0 struct {
}

// CreateUsersWithArrayInputHeaders : request headers
type CreateUsersWithArrayInputHeaders struct {
}

// CreateUsersWithArrayInputQueryParams : query/GET request parameters
type CreateUsersWithArrayInputQueryParams struct {
}

// CreateUsersWithArrayInputPathParams : in path request parameters
type CreateUsersWithArrayInputPathParams struct {
}

// CreateUsersWithArrayInputFormParams : form/POST request parameters
type CreateUsersWithArrayInputFormParams struct {
}

// CreateUsersWithArrayInputRequest payload object
type CreateUsersWithArrayInputRequest struct {
	Headers *CreateUsersWithArrayInputHeaders
	QueryParams *CreateUsersWithArrayInputQueryParams
	PathParams *CreateUsersWithArrayInputPathParams
	FormParams *CreateUsersWithArrayInputFormParams
}

// Bind : gin bind
func (o *CreateUsersWithArrayInputRequest) Bind (c *gin.Context) error {
    var err error

	return err
}

// NewCreateUsersWithArrayInputHandler constructor
func NewCreateUsersWithArrayInputHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case CreateUsersWithArrayInputResponse0:
			render(c, 0, resp)
		default:
			err := fmt.Sprintf("CreateUsersWithArrayInput() command response type mismatch. [%T] != ENUM[CreateUsersWithArrayInputResponse0, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// CreateUsersWithListInputResponse0 controller response type
type CreateUsersWithListInputResponse0 struct {
}

// CreateUsersWithListInputHeaders : request headers
type CreateUsersWithListInputHeaders struct {
}

// CreateUsersWithListInputQueryParams : query/GET request parameters
type CreateUsersWithListInputQueryParams struct {
}

// CreateUsersWithListInputPathParams : in path request parameters
type CreateUsersWithListInputPathParams struct {
}

// CreateUsersWithListInputFormParams : form/POST request parameters
type CreateUsersWithListInputFormParams struct {
}

// CreateUsersWithListInputRequest payload object
type CreateUsersWithListInputRequest struct {
	Headers *CreateUsersWithListInputHeaders
	QueryParams *CreateUsersWithListInputQueryParams
	PathParams *CreateUsersWithListInputPathParams
	FormParams *CreateUsersWithListInputFormParams
}

// Bind : gin bind
func (o *CreateUsersWithListInputRequest) Bind (c *gin.Context) error {
    var err error

	return err
}

// NewCreateUsersWithListInputHandler constructor
func NewCreateUsersWithListInputHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case CreateUsersWithListInputResponse0:
			render(c, 0, resp)
		default:
			err := fmt.Sprintf("CreateUsersWithListInput() command response type mismatch. [%T] != ENUM[CreateUsersWithListInputResponse0, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// DeleteUserResponse400 controller response type
type DeleteUserResponse400 struct {
}

// DeleteUserResponse404 controller response type
type DeleteUserResponse404 struct {
}

// DeleteUserHeaders : request headers
type DeleteUserHeaders struct {
}

// DeleteUserQueryParams : query/GET request parameters
type DeleteUserQueryParams struct {
}

// DeleteUserPathParams : in path request parameters
type DeleteUserPathParams struct {
	// The name that needs to be deleted
	Username string `json:"username" uri:"username" binding:"required"`
}

// DeleteUserFormParams : form/POST request parameters
type DeleteUserFormParams struct {
}

// DeleteUserRequest payload object
type DeleteUserRequest struct {
	Headers *DeleteUserHeaders
	QueryParams *DeleteUserQueryParams
	PathParams *DeleteUserPathParams
	FormParams *DeleteUserFormParams
}

// Bind : gin bind
func (o *DeleteUserRequest) Bind (c *gin.Context) error {
    var err error

    o.PathParams = &DeleteUserPathParams{}
	err = c.ShouldBindUri(o.PathParams)
	if err != nil {
		return err
	}

	return err
}

// NewDeleteUserHandler constructor
func NewDeleteUserHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case DeleteUserResponse400:
			render(c, 400, resp)
		case DeleteUserResponse404:
			render(c, 404, resp)
		default:
			err := fmt.Sprintf("DeleteUser() command response type mismatch. [%T] != ENUM[DeleteUserResponse400, DeleteUserResponse404, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// GetUserByNameResponse200 controller response type
type GetUserByNameResponse200 struct {
	User
}

// GetUserByNameResponse400 controller response type
type GetUserByNameResponse400 struct {
}

// GetUserByNameResponse404 controller response type
type GetUserByNameResponse404 struct {
}

// GetUserByNameHeaders : request headers
type GetUserByNameHeaders struct {
}

// GetUserByNameQueryParams : query/GET request parameters
type GetUserByNameQueryParams struct {
}

// GetUserByNamePathParams : in path request parameters
type GetUserByNamePathParams struct {
	// The name that needs to be fetched. Use user1 for testing.
	Username string `json:"username" uri:"username" binding:"required"`
}

// GetUserByNameFormParams : form/POST request parameters
type GetUserByNameFormParams struct {
}

// GetUserByNameRequest payload object
type GetUserByNameRequest struct {
	Headers *GetUserByNameHeaders
	QueryParams *GetUserByNameQueryParams
	PathParams *GetUserByNamePathParams
	FormParams *GetUserByNameFormParams
}

// Bind : gin bind
func (o *GetUserByNameRequest) Bind (c *gin.Context) error {
    var err error

    o.PathParams = &GetUserByNamePathParams{}
	err = c.ShouldBindUri(o.PathParams)
	if err != nil {
		return err
	}

	return err
}

// NewGetUserByNameHandler constructor
func NewGetUserByNameHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case GetUserByNameResponse200:
			render(c, 200, resp)
		case GetUserByNameResponse400:
			render(c, 400, resp)
		case GetUserByNameResponse404:
			render(c, 404, resp)
		default:
			err := fmt.Sprintf("GetUserByName() command response type mismatch. [%T] != ENUM[GetUserByNameResponse200, GetUserByNameResponse400, GetUserByNameResponse404, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// LoginUserResponse200 controller response type
type LoginUserResponse200 struct {
	Payload string
}

// LoginUserResponse400 controller response type
type LoginUserResponse400 struct {
}

// LoginUserHeaders : request headers
type LoginUserHeaders struct {
}

// LoginUserQueryParams : query/GET request parameters
type LoginUserQueryParams struct {
	// The user name for login
	Username string `json:"username" form:"username" binding:"required"`
	// The password for login in clear text
	Password string `json:"password" form:"password" binding:"required"`
}

// LoginUserPathParams : in path request parameters
type LoginUserPathParams struct {
}

// LoginUserFormParams : form/POST request parameters
type LoginUserFormParams struct {
}

// LoginUserRequest payload object
type LoginUserRequest struct {
	Headers *LoginUserHeaders
	QueryParams *LoginUserQueryParams
	PathParams *LoginUserPathParams
	FormParams *LoginUserFormParams
}

// Bind : gin bind
func (o *LoginUserRequest) Bind (c *gin.Context) error {
    var err error

    o.QueryParams = &LoginUserQueryParams{}
	err = c.ShouldBindQuery(o.QueryParams)
	if err != nil {
		return err
	}

	return err
}

// NewLoginUserHandler constructor
func NewLoginUserHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case LoginUserResponse200:
			render(c, 200, resp)
		case LoginUserResponse400:
			render(c, 400, resp)
		default:
			err := fmt.Sprintf("LoginUser() command response type mismatch. [%T] != ENUM[LoginUserResponse200, LoginUserResponse400, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// LogoutUserResponse0 controller response type
type LogoutUserResponse0 struct {
}

// LogoutUserHeaders : request headers
type LogoutUserHeaders struct {
}

// LogoutUserQueryParams : query/GET request parameters
type LogoutUserQueryParams struct {
}

// LogoutUserPathParams : in path request parameters
type LogoutUserPathParams struct {
}

// LogoutUserFormParams : form/POST request parameters
type LogoutUserFormParams struct {
}

// LogoutUserRequest payload object
type LogoutUserRequest struct {
	Headers *LogoutUserHeaders
	QueryParams *LogoutUserQueryParams
	PathParams *LogoutUserPathParams
	FormParams *LogoutUserFormParams
}

// Bind : gin bind
func (o *LogoutUserRequest) Bind (c *gin.Context) error {
    var err error

	return err
}

// NewLogoutUserHandler constructor
func NewLogoutUserHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case LogoutUserResponse0:
			render(c, 0, resp)
		default:
			err := fmt.Sprintf("LogoutUser() command response type mismatch. [%T] != ENUM[LogoutUserResponse0, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

// UpdateUserResponse400 controller response type
type UpdateUserResponse400 struct {
}

// UpdateUserResponse404 controller response type
type UpdateUserResponse404 struct {
}

// UpdateUserHeaders : request headers
type UpdateUserHeaders struct {
}

// UpdateUserQueryParams : query/GET request parameters
type UpdateUserQueryParams struct {
}

// UpdateUserPathParams : in path request parameters
type UpdateUserPathParams struct {
	// name that need to be deleted
	Username string `json:"username" uri:"username" binding:"required"`
}

// UpdateUserFormParams : form/POST request parameters
type UpdateUserFormParams struct {
}

// UpdateUserRequest payload object
type UpdateUserRequest struct {
	Headers *UpdateUserHeaders
	QueryParams *UpdateUserQueryParams
	PathParams *UpdateUserPathParams
	FormParams *UpdateUserFormParams
}

// Bind : gin bind
func (o *UpdateUserRequest) Bind (c *gin.Context) error {
    var err error

    o.PathParams = &UpdateUserPathParams{}
	err = c.ShouldBindUri(o.PathParams)
	if err != nil {
		return err
	}

	return err
}

// NewUpdateUserHandler constructor
func NewUpdateUserHandler(cmd Command) gin.HandlerFunc {
	return func(c *gin.Context) {
		resp := cmd(c)

		switch resp.(type) {
		case UpdateUserResponse400:
			render(c, 400, resp)
		case UpdateUserResponse404:
			render(c, 404, resp)
		default:
			err := fmt.Sprintf("UpdateUser() command response type mismatch. [%T] != ENUM[UpdateUserResponse400, UpdateUserResponse404, ]")
			c.String(http.StatusNotImplemented, err, resp)
		}
	}
}

