//! Main binary entry point for ops_v3 implementation.

#![allow(missing_docs)]
use clap::{App, Arg};
use openapi_context::{AddContextService, EmptyContext};
use openapi_context::auth::AllowAllAuthenticator;

pub use ops_v3::models as models;

mod server_lib;

use ops_v3::Service;
use server_lib::Server;

macro_rules! make_service(
    () => {
        hyper::service::make_service_fn(|_| async {
            let s: AddContextService<_, EmptyContext> = AddContextService::new(
                AllowAllAuthenticator::new(
                    Service::new(Server::new()),
                    "cosmo",
                )
            );
            let r: Result<_, std::io::Error> = Ok(s);
            r
        })
    }
);

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
#[tokio::main]
async fn main() {
    let matches = App::new("server")
        .arg(Arg::with_name("https")
            .long("https")
            .help("Whether to use HTTPS or not"))
        .get_matches();

    let addr = "127.0.0.1:80".parse().expect("Failed to parse bind address");
    if matches.is_present("https") {
        let acceptor = openapi_client::server::tls::acceptor(
            &addr,
            "examples/server-chain.pem",
            "examples/server-key.pem",
        ).await.expect("Failed to build acceptor");
        hyper::Server::builder(acceptor)
            .serve(make_service!()).await.expect("Server failed to run");
    } else {
        // Using HTTP
        hyper::Server::bind(&addr).serve(make_service!()).await.expect("Server failed to run");
    }
}
