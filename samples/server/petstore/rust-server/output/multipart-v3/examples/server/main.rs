//! Main binary entry point for multipart_v3 implementation.

#![allow(missing_docs)]

// Imports required by this file.
// extern crate <name of this crate>;
extern crate multipart_v3;
extern crate clap;
extern crate env_logger;
extern crate hyper;
#[macro_use]
extern crate log;
extern crate openssl;
extern crate swagger;

// Imports required by server library.
// extern crate multipart_v3;
extern crate chrono;
#[macro_use]
extern crate error_chain;
extern crate futures;
extern crate native_tls;
// extern crate swagger;
extern crate tokio;
extern crate tokio_tls;

use clap::{App, Arg};
use openssl::x509::X509_FILETYPE_PEM;
use openssl::ssl::{SslAcceptorBuilder, SslMethod};
use openssl::error::ErrorStack;

mod server;

// Builds an SSL implementation for Simple HTTPS from some hard-coded file names
fn ssl() -> Result<SslAcceptorBuilder, ErrorStack> {
    let mut ssl = SslAcceptorBuilder::mozilla_intermediate_raw(SslMethod::tls())?;

    // Server authentication
    ssl.set_private_key_file("examples/server-key.pem", X509_FILETYPE_PEM)?;
    ssl.set_certificate_chain_file("examples/server-chain.pem")?;
    ssl.check_private_key()?;

    Ok(ssl)
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
fn main() {
    env_logger::init();

    let matches = App::new("server")
        .arg(Arg::with_name("https")
            .long("https")
            .help("Whether to use HTTPS or not"))
        .get_matches();

    let addr = "127.0.0.1:80";

    let https = if matches.is_present("https") {
        Some(ssl().expect("Failed to load SSL keys"))
    } else {
        None
    };

    hyper::rt::run(server::create(addr, https));
}
