//! Main binary entry point for openapi_v3 implementation.

#![allow(missing_docs)]

// Imports required by this file.
// extern crate <name of this crate>;
extern crate openapi_v3;
extern crate swagger;
extern crate hyper;
extern crate openssl;
extern crate tokio;
extern crate tokio_tls;
extern crate native_tls;
extern crate clap;

// Imports required by server library.
// extern crate openapi_v3;
// extern crate swagger;
extern crate futures;
extern crate chrono;
#[macro_use]
extern crate error_chain;
extern crate uuid;

use futures::{Future, Stream};
use hyper::service::MakeService;
use hyper::server::conn::Http;
use openssl::x509::X509_FILETYPE_PEM;
use openssl::ssl::{SslAcceptorBuilder, SslMethod};
use openssl::error::ErrorStack;
use tokio::net::TcpListener;
use clap::{App, Arg};
use std::sync::{Arc, Mutex};
use swagger::auth::MakeAllowAllAuthenticator;
use swagger::EmptyContext;
use tokio_tls::TlsAcceptorExt;

mod server_lib;

// Builds an SSL implementation for Simple HTTPS from some hard-coded file names
fn ssl() -> Result<SslAcceptorBuilder, ErrorStack> {
    let mut ssl = SslAcceptorBuilder::mozilla_intermediate_raw(SslMethod::tls())?;

    // Server authentication
    ssl.set_private_key_file("examples/server-key.pem", X509_FILETYPE_PEM)?;
    ssl.set_certificate_chain_file("examples/server-chain.pem")?;
    ssl.check_private_key()?;

    Ok(ssl)
}

/// Create custom server, wire it to the autogenerated router,
/// and pass it to the web server.
fn main() {
    let matches = App::new("server")
        .arg(Arg::with_name("https")
            .long("https")
            .help("Whether to use HTTPS or not"))
        .get_matches();

    let server = server_lib::Server::new();

    let service_fn = openapi_v3::server::MakeService::new(server);

    let service_fn = MakeAllowAllAuthenticator::new(service_fn, "cosmo");

    let service_fn =
        openapi_v3::server::context::MakeAddContext::<_, EmptyContext>::new(
            service_fn
        );

    let addr = "127.0.0.1:80".parse().expect("Failed to parse bind address");
    if matches.is_present("https") {
        let ssl = ssl().expect("Failed to load SSL keys");
        let builder: native_tls::TlsAcceptorBuilder = native_tls::backend::openssl::TlsAcceptorBuilderExt::from_openssl(ssl);
        let tls_acceptor = builder.build().expect("Failed to build TLS acceptor");
        let service_fn = Arc::new(Mutex::new(service_fn));
        let tls_listener = TcpListener::bind(&addr).unwrap().incoming().for_each(move |tcp| {
           let addr = tcp.peer_addr().expect("Unable to get remote address");

           let service_fn = service_fn.clone();

           hyper::rt::spawn(tls_acceptor.accept_async(tcp).map_err(|_| ()).and_then(move |tls| {
               let ms = {
                   let mut service_fn = service_fn.lock().unwrap();
                   service_fn.make_service(&addr)
               };

               ms.and_then(move |service| {
                   Http::new().serve_connection(tls, service)
               }).map_err(|_| ())
           }));

           Ok(())
        }).map_err(|_| ());

        hyper::rt::run(tls_listener);
    } else {
        // Using HTTP
        hyper::rt::run(hyper::server::Server::bind(&addr).serve(service_fn).map_err(|e| panic!("{:?}", e)));
    }
}
