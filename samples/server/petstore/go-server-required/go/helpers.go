/*
 * OpenAPI Petstore
 *
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * API version: 1.0.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package petstoreserver

import (
    "net/http"
	"reflect"
)

// Response returns a ImplResponse struct filled
func Response(code int, body interface{}, opts ...ResponseOpt) ImplResponse {
	res := ImplResponse {
		Code: code,
		Body: body,
	}

	for _, f := range opts {
		f(&res)
	}

	return res
}

// ResponseWithHeaders return a ImplResponse struct filled, including headers
func ResponseWithHeaders(code int, headers map[string][]string, body interface{}) ImplResponse {
	return ImplResponse {
		Code: code,
		Headers: headers,
		Body: body,
	}
}

type ResponseOpt func(r *ImplResponse)

// WithCookie adds a cookie to the response.
func WithCookie(c *http.Cookie) ResponseOpt {
	return func(r *ImplResponse) {
		r.Cookies = append(r.Cookies, c)
	}
}

// WithHeader sets a header in the response.
func WithHeader(name, value string) ResponseOpt {
	return func(r *ImplResponse) {
		if r.Headers == nil {
			r.Headers = make(map[string][]string)
		}
		r.Headers[name] = []string{value}
	}
}

// WithAddedHeader adds a header value to the response.
func WithAddedHeader(name, value string) ResponseOpt {
	return func(r *ImplResponse) {
		if r.Headers == nil {
			r.Headers = make(map[string][]string)
		}
		r.Headers[name] = append(r.Headers[name], value)
	}

// IsZeroValue checks if the val is the zero-ed value.
func IsZeroValue(val interface{}) bool {
	return val == nil || reflect.DeepEqual(val, reflect.Zero(reflect.TypeOf(val)).Interface())
}

// AssertInterfaceRequired recursively checks each struct in a slice against the callback.
// This method traverse nested slices in a preorder fashion.
func AssertRecurseInterfaceRequired(obj interface{}, callback func(interface{}) error) error {
	return AssertRecurseValueRequired(reflect.ValueOf(obj), callback)
}

// AssertNestedValueRequired checks each struct in the nested slice against the callback.
// This method traverse nested slices in a preorder fashion.
func AssertRecurseValueRequired(value reflect.Value, callback func(interface{}) error) error {
	switch value.Kind() {
	// If it is a struct we check using callback
	case reflect.Struct:
		if err := callback(value.Interface()); err != nil {
			return err
		}

	// If it is a slice we continue recursion
	case reflect.Slice:
		for i := 0; i < value.Len(); i += 1 {
			if err := AssertRecurseValueRequired(value.Index(i), callback); err != nil {
				return err
			}
		}
	}
	return nil
}
