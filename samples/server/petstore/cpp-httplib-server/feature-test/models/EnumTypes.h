/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#pragma once
// System headers
#include <nlohmann/json.hpp>
#include <optional>
#include <cstdint>
#include <string>



namespace models {


class EnumTypes
{
public:
    // ===================
    // ===== Enums =======
    // ===================
    enum class StringEnumEnum {
        UNSPECIFIED,
        PENDING,
        APPROVED,
        REJECTED
    };

    // Enum conversion functions (definitions in .cpp)
    static std::string StringEnumEnumToString(StringEnumEnum value);
    static StringEnumEnum StringEnumEnumFromString(const std::string& str);

    enum class NumericEnumEnum {
        UNSPECIFIED,
        _100,
        _200,
        _300,
        _404,
        _500
    };

    // Enum conversion functions (definitions in .cpp)
    static std::string NumericEnumEnumToString(NumericEnumEnum value);
    static NumericEnumEnum NumericEnumEnumFromString(const std::string& str);

    enum class StatusCodeEnum {
        UNSPECIFIED,
        _200,
        _404,
        _500
    };

    // Enum conversion functions (definitions in .cpp)
    static std::string StatusCodeEnumToString(StatusCodeEnum value);
    static StatusCodeEnum StatusCodeEnumFromString(const std::string& str);


    EnumTypes();
    virtual ~EnumTypes() = default;

    // Getters and setters
    [[nodiscard]] std::optional<StringEnumEnum> getStringEnum() const;
    void setStringEnum(const std::optional<StringEnumEnum>& stringEnum);
    [[nodiscard]] std::optional<NumericEnumEnum> getNumericEnum() const;
    void setNumericEnum(const std::optional<NumericEnumEnum>& numericEnum);
    [[nodiscard]] std::optional<StatusCodeEnum> getStatusCode() const;
    void setStatusCode(const std::optional<StatusCodeEnum>& statusCode);

    // =============================================================================
    // Friend Enum Serialization Helpers (Required for NLOHMANN JSON serialization)
    // =============================================================================
    // These friend functions must be declared inside the class because:
    // 1. The enum types are nested and don't exist before the class is defined
    // 2. NLOHMANN macros need custom serialization for enum types (uses ToString/FromString)
    // 3. The 'friend' keyword makes them free functions in the namespace (not member functions)
    //    so ADL (Argument-Dependent Lookup) can find them during JSON serialization
    // =============================================================================

    // Serialization helpers for std::optional<StringEnumEnum>
    friend inline void to_json(nlohmann::json& j, const std::optional<StringEnumEnum>& opt)
    {
        if (opt.has_value())
        {
            j = StringEnumEnumToString(opt.value());
        }
        else
        {
            j = nullptr;
        }
    }

    friend inline void from_json(const nlohmann::json& j, std::optional<StringEnumEnum>& opt)
    {
        if (j.is_null())
        {
            opt = std::nullopt;
        }
        else
        {
            opt = StringEnumEnumFromString(j.get<std::string>());
        }
    }

    // Serialization helpers for std::optional<NumericEnumEnum>
    friend inline void to_json(nlohmann::json& j, const std::optional<NumericEnumEnum>& opt)
    {
        if (opt.has_value())
        {
            j = NumericEnumEnumToString(opt.value());
        }
        else
        {
            j = nullptr;
        }
    }

    friend inline void from_json(const nlohmann::json& j, std::optional<NumericEnumEnum>& opt)
    {
        if (j.is_null())
        {
            opt = std::nullopt;
        }
        else
        {
            opt = NumericEnumEnumFromString(j.get<std::string>());
        }
    }

    // Serialization helpers for std::optional<StatusCodeEnum>
    friend inline void to_json(nlohmann::json& j, const std::optional<StatusCodeEnum>& opt)
    {
        if (opt.has_value())
        {
            j = StatusCodeEnumToString(opt.value());
        }
        else
        {
            j = nullptr;
        }
    }

    friend inline void from_json(const nlohmann::json& j, std::optional<StatusCodeEnum>& opt)
    {
        if (j.is_null())
        {
            opt = std::nullopt;
        }
        else
        {
            opt = StatusCodeEnumFromString(j.get<std::string>());
        }
    }



    // JSON serialization using NLOHMANN INTRUSIVE macro (must be inside class to access private members)
    NLOHMANN_DEFINE_TYPE_INTRUSIVE(EnumTypes,
         stringEnum, numericEnum, statusCode)

private:
    std::optional<StringEnumEnum> stringEnum;
    std::optional<NumericEnumEnum> numericEnum;
    std::optional<StatusCodeEnum> statusCode;
};


} // namespace models

