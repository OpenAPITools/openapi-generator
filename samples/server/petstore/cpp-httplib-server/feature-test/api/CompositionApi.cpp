/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

// System headers
#include <algorithm>
#include <cctype>
#include <locale>

// Project headers
#include "CompositionApi.h"

constexpr int HTTP_RESPONSE_CODE_DOG = 200;
constexpr int HTTP_RESPONSE_CODE_STRING_OR_NUMBER = 200;
constexpr int HTTP_RESPONSE_CODE_PAYMENT_METHOD = 200;
constexpr int HTTP_RESPONSE_CODE_BAD_REQUEST = 400;
constexpr int HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR = 500;

namespace api {

using namespace models;

bool Composition::parseCompositionallofPostParams(const httplib::Request& req, Composition::CompositionallofPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Composition::handleCompositionallofPostResponse(const CompositionallofPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_DOG;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Composition::parseCompositionanyofPostParams(const httplib::Request& req, Composition::CompositionanyofPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Composition::handleCompositionanyofPostResponse(const CompositionanyofPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_STRING_OR_NUMBER;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Composition::parseCompositiononeofPostParams(const httplib::Request& req, Composition::CompositiononeofPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Composition::handleCompositiononeofPostResponse(const CompositiononeofPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_PAYMENT_METHOD;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}


void Composition::handleCompositionallofPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        CompositionallofPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseCompositionallofPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForCompositionallof(params);
        handleCompositionallofPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Composition::handleCompositionanyofPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        CompositionanyofPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseCompositionanyofPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForCompositionanyof(params);
        handleCompositionanyofPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Composition::handleCompositiononeofPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        CompositiononeofPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseCompositiononeofPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForCompositiononeof(params);
        handleCompositiononeofPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}


void Composition::registerRoutes(httplib::Server& svr)
{
    svr.Post("/composition/allof", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleCompositionallofPostRequest(req, res);
    });
    svr.Post("/composition/anyof", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleCompositionanyofPostRequest(req, res);
    });
    svr.Post("/composition/oneof", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleCompositiononeofPostRequest(req, res);
    });
}

} // namespace api