/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

// System headers
#include <algorithm>
#include <cctype>
#include <locale>

// Project headers
#include "DatatypesApi.h"

constexpr int HTTP_RESPONSE_CODE_ARRAY_TYPES = 200;
constexpr int HTTP_RESPONSE_CODE_ENUM_TYPES = 200;
constexpr int HTTP_RESPONSE_CODE_SUCCESS_RESPONSE = 200;
constexpr int HTTP_RESPONSE_CODE_CREATED_RESPONSE = 201;
constexpr int HTTP_RESPONSE_CODE_NOT_FOUND_RESPONSE = 404;
constexpr int HTTP_RESPONSE_CODE_ERROR_RESPONSE = 500;
constexpr int HTTP_RESPONSE_CODE_COMPANY = 200;
constexpr int HTTP_RESPONSE_CODE_NULLABLE_OPTIONAL_TYPES = 200;
constexpr int HTTP_RESPONSE_CODE_PRIMITIVE_TYPES = 200;
constexpr int HTTP_RESPONSE_CODE_NO_CONTENT = 204;
constexpr int HTTP_RESPONSE_CODE_BAD_REQUEST = 400;

namespace api {

using namespace models;

bool Datatypes::parseDatatypesarraysPostParams(const httplib::Request& req, Datatypes::DatatypesarraysPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Datatypes::handleDatatypesarraysPostResponse(const DatatypesarraysPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_ARRAY_TYPES;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Datatypes::parseDatatypesenumsPostParams(const httplib::Request& req, Datatypes::DatatypesenumsPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Datatypes::handleDatatypesenumsPostResponse(const DatatypesenumsPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_ENUM_TYPES;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Datatypes::parseResponsesmultipleGetParams(const httplib::Request& req, Datatypes::ResponsesmultipleGetRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Query Parameters - scenario
    if (req.has_param("scenario"))
    {
        try
        {
            params.m_scenario = (req.get_param_value("scenario"));
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'scenario': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Datatypes::handleResponsesmultipleGetResponse(const ResponsesmultipleGetResponse& result, httplib::Response& res)
{
    std::visit([&](const auto& value)
    {
        using T = std::decay_t<decltype(value)>;

        // Success types
        if constexpr (std::is_same_v<T, models::SuccessResponse>)
        {
            res.status = HTTP_RESPONSE_CODE_SUCCESS_RESPONSE;
            nlohmann::json responseJson;
            to_json(responseJson, value);
            res.set_content(responseJson.dump(), "application/json");
        }else if constexpr (std::is_same_v<T, models::CreatedResponse>)
        {
            res.status = HTTP_RESPONSE_CODE_CREATED_RESPONSE;
            nlohmann::json responseJson;
            to_json(responseJson, value);
            res.set_content(responseJson.dump(), "application/json");
        }
        // Error types
        else if constexpr (std::is_same_v<T, models::NotFoundResponse>)
        {
            res.status = HTTP_RESPONSE_CODE_NOT_FOUND_RESPONSE;
            nlohmann::json errorJson = value;
            res.set_content(errorJson.dump(), "application/json");
        }
        else if constexpr (std::is_same_v<T, models::ErrorResponse>)
        {
            res.status = HTTP_RESPONSE_CODE_ERROR_RESPONSE;
            nlohmann::json errorJson = value;
            res.set_content(errorJson.dump(), "application/json");
        }
    }, result);
}
bool Datatypes::parseNestedobjectsPostParams(const httplib::Request& req, Datatypes::NestedobjectsPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Datatypes::handleNestedobjectsPostResponse(const NestedobjectsPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_COMPANY;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Datatypes::parseResponsesnocontentDeleteParams(const httplib::Request& req, Datatypes::ResponsesnocontentDeleteRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Query Parameters - id
    if (req.has_param("id"))
    {
        try
        {
            params.m_id = std::stoi(req.get_param_value("id"));
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'id': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
bool Datatypes::parseNullableoptionalPostParams(const httplib::Request& req, Datatypes::NullableoptionalPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Datatypes::handleNullableoptionalPostResponse(const NullableoptionalPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_NULLABLE_OPTIONAL_TYPES;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Datatypes::parseDatatypesprimitivesPostParams(const httplib::Request& req, Datatypes::DatatypesprimitivesPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Datatypes::handleDatatypesprimitivesPostResponse(const DatatypesprimitivesPostResponse& result, httplib::Response& res)
{
    std::visit([&](const auto& value)
    {
        using T = std::decay_t<decltype(value)>;

        // Success types
        if constexpr (std::is_same_v<T, models::PrimitiveTypes>)
        {
            res.status = HTTP_RESPONSE_CODE_PRIMITIVE_TYPES;
            nlohmann::json responseJson;
            to_json(responseJson, value);
            res.set_content(responseJson.dump(), "application/json");
        }
        // Error types
        else if constexpr (std::is_same_v<T, models::ErrorResponse>)
        {
            res.status = HTTP_RESPONSE_CODE_ERROR_RESPONSE;
            nlohmann::json errorJson = value;
            res.set_content(errorJson.dump(), "application/json");
        }
    }, result);
}


void Datatypes::handleDatatypesarraysPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        DatatypesarraysPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseDatatypesarraysPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForDatatypesarrays(params);
        handleDatatypesarraysPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Datatypes::handleDatatypesenumsPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        DatatypesenumsPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseDatatypesenumsPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForDatatypesenums(params);
        handleDatatypesenumsPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Datatypes::handleResponsesmultipleGetRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        ResponsesmultipleGetRequest params;
        std::vector<std::string> paramErrors;
        if (!parseResponsesmultipleGetParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handleGetForResponsesmultiple(params);
        handleResponsesmultipleGetResponse(result, res);

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_ERROR_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Datatypes::handleNestedobjectsPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        NestedobjectsPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseNestedobjectsPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForNestedobjects(params);
        handleNestedobjectsPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Datatypes::handleResponsesnocontentDeleteRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        ResponsesnocontentDeleteRequest params;
        std::vector<std::string> paramErrors;
        if (!parseResponsesnocontentDeleteParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }

        handleDeleteForResponsesnocontent(params);
        res.status = HTTP_RESPONSE_CODE_NO_CONTENT;

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_ERROR_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Datatypes::handleNullableoptionalPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        NullableoptionalPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseNullableoptionalPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForNullableoptional(params);
        handleNullableoptionalPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Datatypes::handleDatatypesprimitivesPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        DatatypesprimitivesPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseDatatypesprimitivesPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForDatatypesprimitives(params);
        handleDatatypesprimitivesPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}


void Datatypes::registerRoutes(httplib::Server& svr)
{
    svr.Post("/datatypes/arrays", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleDatatypesarraysPostRequest(req, res);
    });
    svr.Post("/datatypes/enums", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleDatatypesenumsPostRequest(req, res);
    });
    svr.Get("/responses/multiple", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleResponsesmultipleGetRequest(req, res);
    });
    svr.Post("/nested/objects", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleNestedobjectsPostRequest(req, res);
    });
    svr.Delete("/responses/nocontent", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleResponsesnocontentDeleteRequest(req, res);
    });
    svr.Post("/nullable/optional", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleNullableoptionalPostRequest(req, res);
    });
    svr.Post("/datatypes/primitives", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleDatatypesprimitivesPostRequest(req, res);
    });
}

} // namespace api