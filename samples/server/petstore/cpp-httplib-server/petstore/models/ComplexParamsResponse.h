/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#pragma once
// System headers
#include <nlohmann/json.hpp>
#include <optional>
#include <cstdint>
#include <string>
#include <vector>
#include "DeepObj.h"



namespace models {


class ComplexParamsResponse
{
public:
    enum class EnumParamEnum {
        UNSPECIFIED,
        A,
        B,
        C
    };

    // Enum conversion functions (definitions in .cpp)
    static std::string EnumParamEnumToString(EnumParamEnum value);
    static EnumParamEnum EnumParamEnumFromString(const std::string& str);

    enum class XEnumHeaderEnum {
        UNSPECIFIED,
        X,
        Y,
        Z
    };

    // Enum conversion functions (definitions in .cpp)
    static std::string XEnumHeaderEnumToString(XEnumHeaderEnum value);
    static XEnumHeaderEnum XEnumHeaderEnumFromString(const std::string& str);

    enum class CookieEnumEnum {
        UNSPECIFIED,
        COOKIEA,
        COOKIEB
    };

    // Enum conversion functions (definitions in .cpp)
    static std::string CookieEnumEnumToString(CookieEnumEnum value);
    static CookieEnumEnum CookieEnumEnumFromString(const std::string& str);


    ComplexParamsResponse();
    virtual ~ComplexParamsResponse() = default;

    // Getters and setters
    [[nodiscard]] DeepObj getDeepObj() const;
    void setDeepObj(const DeepObj& deepObj);
    [[nodiscard]] std::optional<EnumParamEnum> getEnumParam() const;
    void setEnumParam(const std::optional<EnumParamEnum>& enumParam);
    [[nodiscard]] std::vector<std::string> getPipeArr() const;
    void setPipeArr(const std::vector<std::string>& pipeArr);
    [[nodiscard]] std::vector<int> getSpaceArr() const;
    void setSpaceArr(const std::vector<int>& spaceArr);
    [[nodiscard]] std::optional<XEnumHeaderEnum> getXEnumHeader() const;
    void setXEnumHeader(const std::optional<XEnumHeaderEnum>& xEnumHeader);
    [[nodiscard]] std::optional<CookieEnumEnum> getCookieEnum() const;
    void setCookieEnum(const std::optional<CookieEnumEnum>& cookieEnum);
    // Serialization helpers for std::optional<EnumParamEnum>
    friend inline void to_json(nlohmann::json& j, const std::optional<EnumParamEnum>& opt)
    {
        if (opt.has_value())
        {
            j = EnumParamEnumToString(opt.value());
        }
        else
        {
            j = nullptr;
        }
    }

    friend inline void from_json(const nlohmann::json& j, std::optional<EnumParamEnum>& opt)
    {
        if (j.is_null())
        {
            opt = std::nullopt;
        }
        else
        {
            opt = EnumParamEnumFromString(j.get<std::string>());
        }
    }

    // Serialization helpers for std::optional<XEnumHeaderEnum>
    friend inline void to_json(nlohmann::json& j, const std::optional<XEnumHeaderEnum>& opt)
    {
        if (opt.has_value())
        {
            j = XEnumHeaderEnumToString(opt.value());
        }
        else
        {
            j = nullptr;
        }
    }

    friend inline void from_json(const nlohmann::json& j, std::optional<XEnumHeaderEnum>& opt)
    {
        if (j.is_null())
        {
            opt = std::nullopt;
        }
        else
        {
            opt = XEnumHeaderEnumFromString(j.get<std::string>());
        }
    }

    // Serialization helpers for std::optional<CookieEnumEnum>
    friend inline void to_json(nlohmann::json& j, const std::optional<CookieEnumEnum>& opt)
    {
        if (opt.has_value())
        {
            j = CookieEnumEnumToString(opt.value());
        }
        else
        {
            j = nullptr;
        }
    }

    friend inline void from_json(const nlohmann::json& j, std::optional<CookieEnumEnum>& opt)
    {
        if (j.is_null())
        {
            opt = std::nullopt;
        }
        else
        {
            opt = CookieEnumEnumFromString(j.get<std::string>());
        }
    }



    // JSON serialization using NLOHMANN INTRUSIVE macro (must be inside class to access private members)
    NLOHMANN_DEFINE_TYPE_INTRUSIVE(ComplexParamsResponse,
         deepObj, enumParam, pipeArr, spaceArr, xEnumHeader, cookieEnum)

private:
    DeepObj deepObj;
    std::optional<EnumParamEnum> enumParam;
    std::vector<std::string> pipeArr;
    std::vector<int> spaceArr;
    std::optional<XEnumHeaderEnum> xEnumHeader;
    std::optional<CookieEnumEnum> cookieEnum;
};


} // namespace models

