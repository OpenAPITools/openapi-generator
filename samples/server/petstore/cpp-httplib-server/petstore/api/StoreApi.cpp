/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

// System headers
#include <algorithm>
#include <cctype>
#include <locale>

// Project headers
#include "StoreApi.h"

constexpr int HTTP_RESPONSE_CODE_ORDER = 200;
constexpr int HTTP_RESPONSE_CODE_NO_CONTENT = 204;
constexpr int HTTP_RESPONSE_CODE_BAD_REQUEST = 400;
constexpr int HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR = 500;

namespace api {

using namespace models;

bool Store::parseStoreorderorderIdDeleteParams(const httplib::Request& req, Store::StoreorderorderIdDeleteRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Path Parameters - orderId (index: 1)
    if (req.matches.size() < 1 + 1)
    {
        errors.push_back("Missing path parameter 'orderId'");
    }
    else
    {
        try
        {
            params.m_orderId = std::stoll(req.matches[1]);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid path parameter 'orderId': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
bool Store::parseStoreorderorderIdGetParams(const httplib::Request& req, Store::StoreorderorderIdGetRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Path Parameters - orderId (index: 1)
    if (req.matches.size() < 1 + 1)
    {
        errors.push_back("Missing path parameter 'orderId'");
    }
    else
    {
        try
        {
            params.m_orderId = std::stoll(req.matches[1]);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid path parameter 'orderId': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Store::handleStoreorderorderIdGetResponse(const StoreorderorderIdGetResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_ORDER;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Store::parseStoreorderPostParams(const httplib::Request& req, Store::StoreorderPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Store::handleStoreorderPostResponse(const StoreorderPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_ORDER;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}


void Store::handleStoreorderorderIdDeleteRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        StoreorderorderIdDeleteRequest params;
        std::vector<std::string> paramErrors;
        if (!parseStoreorderorderIdDeleteParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }

        handleDeleteForStoreorderorderId(params);
        res.status = HTTP_RESPONSE_CODE_NO_CONTENT;

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Store::handleStoreorderorderIdGetRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        StoreorderorderIdGetRequest params;
        std::vector<std::string> paramErrors;
        if (!parseStoreorderorderIdGetParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handleGetForStoreorderorderId(params);
        handleStoreorderorderIdGetResponse(result, res);

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Store::handleStoreorderPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        StoreorderPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseStoreorderPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForStoreorder(params);
        handleStoreorderPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}


void Store::registerRoutes(httplib::Server& svr)
{
    svr.Delete("/store/order/{orderId}", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleStoreorderorderIdDeleteRequest(req, res);
    });
    svr.Get("/store/order/{orderId}", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleStoreorderorderIdGetRequest(req, res);
    });
    svr.Post("/store/order", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleStoreorderPostRequest(req, res);
    });
}

} // namespace api