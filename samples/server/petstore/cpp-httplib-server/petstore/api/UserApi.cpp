/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

// System headers
#include <algorithm>
#include <cctype>
#include <locale>

// Project headers
#include "UserApi.h"

constexpr int HTTP_RESPONSE_CODE_USER = 200;
constexpr int HTTP_RESPONSE_CODE_NO_CONTENT = 204;
constexpr int HTTP_RESPONSE_CODE_BAD_REQUEST = 400;
constexpr int HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR = 500;

namespace api {

using namespace models;

bool User::parseUserPostParams(const httplib::Request& req, User::UserPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void User::handleUserPostResponse(const UserPostResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_USER;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool User::parseUserusernameDeleteParams(const httplib::Request& req, User::UserusernameDeleteRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Path Parameters - username (index: 1)
    if (req.matches.size() < 1 + 1)
    {
        errors.push_back("Missing path parameter 'username'");
    }
    else
    {
        try
        {
            params.m_username = req.matches[1];
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid path parameter 'username': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
bool User::parseUserusernameGetParams(const httplib::Request& req, User::UserusernameGetRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Path Parameters - username (index: 1)
    if (req.matches.size() < 1 + 1)
    {
        errors.push_back("Missing path parameter 'username'");
    }
    else
    {
        try
        {
            params.m_username = req.matches[1];
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid path parameter 'username': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void User::handleUserusernameGetResponse(const UserusernameGetResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_USER;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool User::parseUserusernamePutParams(const httplib::Request& req, User::UserusernamePutRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Path Parameters - username (index: 1)
    if (req.matches.size() < 1 + 1)
    {
        errors.push_back("Missing path parameter 'username'");
    }
    else
    {
        try
        {
            params.m_username = req.matches[1];
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid path parameter 'username': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}


void User::handleUserPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        UserPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parseUserPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForUser(params);
        handleUserPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void User::handleUserusernameDeleteRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        UserusernameDeleteRequest params;
        std::vector<std::string> paramErrors;
        if (!parseUserusernameDeleteParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }

        handleDeleteForUserusername(params);
        res.status = HTTP_RESPONSE_CODE_NO_CONTENT;

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void User::handleUserusernameGetRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        UserusernameGetRequest params;
        std::vector<std::string> paramErrors;
        if (!parseUserusernameGetParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handleGetForUserusername(params);
        handleUserusernameGetResponse(result, res);

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void User::handleUserusernamePutRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        UserusernamePutRequest params;
        std::vector<std::string> paramErrors;
        if (!parseUserusernamePutParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }

        handlePutForUserusername(params);
        res.status = HTTP_RESPONSE_CODE_NO_CONTENT;

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_BAD_REQUEST;
        res.set_content(errorJson.dump(), "application/json");
    }
}


void User::registerRoutes(httplib::Server& svr)
{
    svr.Post("/user", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleUserPostRequest(req, res);
    });
    svr.Delete("/user/{username}", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleUserusernameDeleteRequest(req, res);
    });
    svr.Get("/user/{username}", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleUserusernameGetRequest(req, res);
    });
    svr.Put("/user/{username}", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handleUserusernamePutRequest(req, res);
    });
}

} // namespace api