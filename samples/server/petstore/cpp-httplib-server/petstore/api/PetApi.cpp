/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

// System headers
#include <algorithm>
#include <cctype>
#include <locale>

// Project headers
#include "PetApi.h"

constexpr int HTTP_RESPONSE_CODE_PET = 201;
constexpr int HTTP_RESPONSE_CODE_API_RESPONSE = 400;
constexpr int HTTP_RESPONSE_CODE_COMPLEX_PARAMS_RESPONSE = 200;
constexpr int HTTP_RESPONSE_CODE_NO_CONTENT = 204;
constexpr int HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR = 500;

namespace api {

using namespace models;

bool Pet::parsePetPostParams(const httplib::Request& req, Pet::PetPostRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Pet::handlePetPostResponse(const PetPostResponse& result, httplib::Response& res)
{
    std::visit([&](const auto& value)
    {
        using T = std::decay_t<decltype(value)>;

        // Success types
        if constexpr (std::is_same_v<T, models::Pet>)
        {
            res.status = HTTP_RESPONSE_CODE_PET;
            nlohmann::json responseJson;
            to_json(responseJson, value);
            res.set_content(responseJson.dump(), "application/json");
        }
        // Error types
        else if constexpr (std::is_same_v<T, models::ApiResponse>)
        {
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            nlohmann::json errorJson = value;
            res.set_content(errorJson.dump(), "application/json");
        }
    }, result);
}
bool Pet::parsePetcomplexGetParams(const httplib::Request& req, Pet::PetcomplexGetRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Query Parameters - deepObj
    if (req.has_param("deepObj"))
    {
        try
        {
            // Parse JSON object from query
            auto val = req.get_param_value("deepObj", 0);
            params.m_deepObj = nlohmann::json::parse(val).get<models::DeepObj>();
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'deepObj': " + std::string(e.what()));
        }
    }
    // Query Parameters - enumParam
    if (req.has_param("enumParam"))
    {
        try
        {
            params.m_enumParam = (req.get_param_value("enumParam"));
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'enumParam': " + std::string(e.what()));
        }
    }
    // Query Parameters - pipeArr
    if (req.has_param("pipeArr"))
    {
        try
        {
            // form/simple: multi-param or comma-separated
            size_t count = req.get_param_value_count("pipeArr");
            if (!params.m_pipeArr.has_value())
            {
                params.m_pipeArr = std::vector<std::string>{};
            }
            if (count > 1)
            {
                for (size_t i = 0; i < count; ++i)
                {
                    auto val = req.get_param_value("pipeArr", i);

                    params.m_pipeArr->emplace_back(val);

                }
            }
            else if (count == 1)
            {
                auto val = req.get_param_value("pipeArr", 0);
                std::stringstream ss(val);
                std::string item;
                while (std::getline(ss, item, ','))
                {
                    if (!item.empty())
                    {

                        params.m_pipeArr->emplace_back(item);

                    }
                }
            }
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'pipeArr': " + std::string(e.what()));
        }
    }
    // Query Parameters - spaceArr
    if (req.has_param("spaceArr"))
    {
        try
        {
            // form/simple: multi-param or comma-separated
            size_t count = req.get_param_value_count("spaceArr");
            if (!params.m_spaceArr.has_value())
            {
                params.m_spaceArr = std::vector<int>{};
            }
            if (count > 1)
            {
                for (size_t i = 0; i < count; ++i)
                {
                    auto val = req.get_param_value("spaceArr", i);
                    params.m_spaceArr->emplace_back(std::stoi(val));

                }
            }
            else if (count == 1)
            {
                auto val = req.get_param_value("spaceArr", 0);
                std::stringstream ss(val);
                std::string item;
                while (std::getline(ss, item, ','))
                {
                    if (!item.empty())
                    {
                        params.m_spaceArr->emplace_back(std::stoi(item));

                    }
                }
            }
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'spaceArr': " + std::string(e.what()));
        }
    }

    // Header Parameters - x-enum-header
    if (!req.get_header_value("x-enum-header").empty())
    {
        try
        {
            params.m_xEnumHeader = (req.get_header_value("x-enum-header"));
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid header parameter 'x-enum-header': " + std::string(e.what()));
        }
    }

    // Cookie Parameters - cookieEnum
    try
    {
        auto cookieHeader = req.get_header_value("Cookie");
        if (!cookieHeader.empty())
        {
            std::string cookieValue;
            std::string key = "cookieEnum=";
            size_t start = cookieHeader.find(key);
            if (start != std::string::npos)
            {
                start += key.length();
                size_t end = cookieHeader.find(";", start);
                if (end == std::string::npos) end = cookieHeader.length();
                cookieValue = cookieHeader.substr(start, end - start);
                params.m_cookieEnum = (cookieValue);
            }
        }
    }
    catch (const std::exception& e)
    {
        errors.push_back("Invalid cookie parameter 'cookieEnum': " + std::string(e.what()));
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Pet::handlePetcomplexGetResponse(const PetcomplexGetResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_COMPLEX_PARAMS_RESPONSE;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Pet::parsePetpetIdDeleteParams(const httplib::Request& req, Pet::PetpetIdDeleteRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Query Parameters - api_key
    if (req.has_param("api_key"))
    {
        params.m_apiKey = req.get_param_value("api_key");
    }
    else
    {
        // Use default value for optional parameter
        params.m_apiKey = "";
    }

    // Path Parameters - petId (index: 1)
    if (req.matches.size() < 1 + 1)
    {
        errors.push_back("Missing path parameter 'petId'");
    }
    else
    {
        try
        {
            params.m_petId = std::stoll(req.matches[1]);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid path parameter 'petId': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
bool Pet::parsePetfindByStatusGetParams(const httplib::Request& req, Pet::PetfindByStatusGetRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Query Parameters - status
    if (req.has_param("status"))
    {
        try
        {
            params.m_status = (req.get_param_value("status"));
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'status': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Pet::handlePetfindByStatusGetResponse(const PetfindByStatusGetResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_PET;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Pet::parsePetfindByTagsGetParams(const httplib::Request& req, Pet::PetfindByTagsGetRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Query Parameters - tags
    if (req.has_param("tags"))
    {
        try
        {
            // form/simple: multi-param or comma-separated
            size_t count = req.get_param_value_count("tags");
            if (count > 1)
            {
                for (size_t i = 0; i < count; ++i)
                {
                    auto val = req.get_param_value("tags", i);

                    params.m_tags.emplace_back(val);

                }
            }
            else if (count == 1)
            {
                auto val = req.get_param_value("tags", 0);
                std::stringstream ss(val);
                std::string item;
                while (std::getline(ss, item, ','))
                {
                    if (!item.empty())
                    {

                        params.m_tags.emplace_back(item);

                    }
                }
            }
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid query parameter 'tags': " + std::string(e.what()));
        }
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Pet::handlePetfindByTagsGetResponse(const PetfindByTagsGetResponse& result, httplib::Response& res)
{
    // Single response type
    res.status = HTTP_RESPONSE_CODE_PET;
    nlohmann::json responseJson;
    to_json(responseJson, result);
    res.set_content(responseJson.dump(), "application/json");
}
bool Pet::parsePetpetIdGetParams(const httplib::Request& req, Pet::PetpetIdGetRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;

    // Header Parameters - customHeader
    if (!req.get_header_value("customHeader").empty())
    {
        params.m_customHeader = req.get_header_value("customHeader");
    }
    else
    {
        // Use default value for optional parameter
        params.m_customHeader = "";
    }

    // Path Parameters - petId (index: 1)
    if (req.matches.size() < 1 + 1)
    {
        errors.push_back("Missing path parameter 'petId'");
    }
    else
    {
        try
        {
            params.m_petId = std::stoll(req.matches[1]);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid path parameter 'petId': " + std::string(e.what()));
        }
    }

    // Cookie Parameters - cookieParam
    try
    {
        auto cookieHeader = req.get_header_value("Cookie");
        if (!cookieHeader.empty())
        {
            std::string cookieValue;
            std::string key = "cookieParam=";
            size_t start = cookieHeader.find(key);
            if (start != std::string::npos)
            {
                start += key.length();
                size_t end = cookieHeader.find(";", start);
                if (end == std::string::npos) end = cookieHeader.length();
                cookieValue = cookieHeader.substr(start, end - start);
                params.m_cookieParam = cookieValue;
            }
            else
            {
                // Use default value for optional parameter
                params.m_cookieParam = "";
            }
        }
        else
        {
            // Use default value for optional parameter
            params.m_cookieParam = "";
        }
    }
    catch (const std::exception& e)
    {
        errors.push_back("Invalid cookie parameter 'cookieParam': " + std::string(e.what()));
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}
void Pet::handlePetpetIdGetResponse(const PetpetIdGetResponse& result, httplib::Response& res)
{
    std::visit([&](const auto& value)
    {
        using T = std::decay_t<decltype(value)>;

        // Success types
        if constexpr (std::is_same_v<T, models::Pet>)
        {
            res.status = HTTP_RESPONSE_CODE_PET;
            nlohmann::json responseJson;
            to_json(responseJson, value);
            res.set_content(responseJson.dump(), "application/json");
        }
        // Error types
        else if constexpr (std::is_same_v<T, models::ApiResponse>)
        {
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            nlohmann::json errorJson = value;
            res.set_content(errorJson.dump(), "application/json");
        }
    }, result);
}
bool Pet::parsePetPutParams(const httplib::Request& req, Pet::PetPutRequest& params, std::vector<std::string>& paramErrors)
{
    std::vector<std::string> errors;
    if (!req.body.empty())
    {
        try
        {
            nlohmann::json json = nlohmann::json::parse(req.body);
            from_json(json, params.m_request);
        }
        catch (const std::exception& e)
        {
            errors.push_back("Invalid request body: " + std::string(e.what()));
        }
    }
    else
    {
        errors.push_back("Missing required request body");
    }

    // Return errors via out-parameter, return false if any errors
    if (!errors.empty())
    {
        paramErrors = std::move(errors);
        return false;
    }
    return true;
}


void Pet::handlePetPostRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        PetPostRequest params;
        std::vector<std::string> paramErrors;
        if (!parsePetPostParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handlePostForPet(params);
        handlePetPostResponse(result, res);

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Pet::handlePetcomplexGetRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        PetcomplexGetRequest params;
        std::vector<std::string> paramErrors;
        if (!parsePetcomplexGetParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handleGetForPetcomplex(params);
        handlePetcomplexGetResponse(result, res);

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Pet::handlePetpetIdDeleteRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        PetpetIdDeleteRequest params;
        std::vector<std::string> paramErrors;
        if (!parsePetpetIdDeleteParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }

        handleDeleteForPetpetId(params);
        res.status = HTTP_RESPONSE_CODE_NO_CONTENT;

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Pet::handlePetfindByStatusGetRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        PetfindByStatusGetRequest params;
        std::vector<std::string> paramErrors;
        if (!parsePetfindByStatusGetParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handleGetForPetfindByStatus(params);
        handlePetfindByStatusGetResponse(result, res);

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Pet::handlePetfindByTagsGetRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        PetfindByTagsGetRequest params;
        std::vector<std::string> paramErrors;
        if (!parsePetfindByTagsGetParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handleGetForPetfindByTags(params);
        handlePetfindByTagsGetResponse(result, res);

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Pet::handlePetpetIdGetRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        PetpetIdGetRequest params;
        std::vector<std::string> paramErrors;
        if (!parsePetpetIdGetParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }
        auto result = handleGetForPetpetId(params);
        handlePetpetIdGetResponse(result, res);

    }
    catch (const std::exception& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Internal error: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_INTERNAL_SERVER_ERROR;
        res.set_content(errorJson.dump(), "application/json");
    }
}

void Pet::handlePetPutRequest([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
{
    try
    {

        PetPutRequest params;
        std::vector<std::string> paramErrors;
        if (!parsePetPutParams(req, params, paramErrors))
        {
            nlohmann::json errorJson = nlohmann::json::object();
            errorJson["message"] = "Invalid parameters";
            errorJson["errors"] = paramErrors;
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(errorJson.dump(), "application/json");
            return;
        }

        handlePutForPet(params);
        res.status = HTTP_RESPONSE_CODE_NO_CONTENT;

    }
    catch (const nlohmann::json::parse_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::invalid_iterator& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::type_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::out_of_range& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
    catch (const nlohmann::json::other_error& e)
    {
        nlohmann::json errorJson = nlohmann::json::object();
        errorJson["message"] = "Invalid JSON: " + std::string(e.what());
        res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
        res.set_content(errorJson.dump(), "application/json");
    }
}


void Pet::registerRoutes(httplib::Server& svr)
{
    svr.Post("/pet", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handlePetPostRequest(req, res);
    });
    svr.Get("/pet/complex", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handlePetcomplexGetRequest(req, res);
    });
    svr.Delete("/pet/{petId}", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handlePetpetIdDeleteRequest(req, res);
    });
    svr.Get("/pet/findByStatus", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handlePetfindByStatusGetRequest(req, res);
    });
    svr.Get("/pet/findByTags", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handlePetfindByTagsGetRequest(req, res);
    });
    svr.Get("/pet/{petId}", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handlePetpetIdGetRequest(req, res);
    });
    svr.Put("/pet", [this]([[maybe_unused]] const httplib::Request& req, httplib::Response& res)
    {
        handlePetPutRequest(req, res);
    });
}

} // namespace api