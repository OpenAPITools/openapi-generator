/**
* This file is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "PetApi.h"

constexpr int HTTP_RESPONSE_CODE_PET = 200;
constexpr int HTTP_RESPONSE_CODE_PET_ERROR = 400;
constexpr int HTTP_RESPONSE_CODE_API_RESPONSE = 200;


namespace api {
// --- Helper function definitions ---
Pet::PetRequestParams Pet::parsePetParams(const httplib::Request& req) {
    Pet::PetRequestParams params;
    params.m_request = models::Pet::fromJson(nlohmann::json::parse(req.body));
    return params;
}
void Pet::handlePetResponse(const PetResponse& result, httplib::Response& res) {
    std::visit([&](const auto& value) {
        using T = std::decay_t<decltype(value)>;
        //Success types
        if constexpr (std::is_same_v<T, models::Pet>) {
            res.status = HTTP_RESPONSE_CODE_PET;
            res.set_content(value.toJson(value).dump(), "application/json");
        }
        

    }, result);
}
Pet::Pet{petId}RequestParams Pet::parsePet{petId}Params(const httplib::Request& req) {
    Pet::Pet{petId}RequestParams params;
    params.m_apiKey = req.get_header_value("api_key");
    return params;
}
Pet::PetFindByStatusRequestParams Pet::parsePetFindByStatusParams(const httplib::Request& req) {
    Pet::PetFindByStatusRequestParams params;
    params.m_status = req.get_param_value("status");
    return params;
}
void Pet::handlePetFindByStatusResponse(const PetFindByStatusResponse& result, httplib::Response& res) {
    std::visit([&](const auto& value) {
        using T = std::decay_t<decltype(value)>;
        //Success types
        if constexpr (std::is_same_v<T, models::Pet>) {
            res.status = HTTP_RESPONSE_CODE_PET;
            res.set_content(value.toJson(value).dump(), "application/json");
        }
        

    }, result);
}
Pet::PetFindByTagsRequestParams Pet::parsePetFindByTagsParams(const httplib::Request& req) {
    Pet::PetFindByTagsRequestParams params;
    params.m_tags = req.get_param_value("tags");
    return params;
}
void Pet::handlePetFindByTagsResponse(const PetFindByTagsResponse& result, httplib::Response& res) {
    std::visit([&](const auto& value) {
        using T = std::decay_t<decltype(value)>;
        //Success types
        if constexpr (std::is_same_v<T, models::Pet>) {
            res.status = HTTP_RESPONSE_CODE_PET;
            res.set_content(value.toJson(value).dump(), "application/json");
        }
        //Error types
        else if constexpr (std::is_same_v<T, models::PetError>) {
            res.status = HTTP_RESPONSE_CODE_PET_ERROR;
            res.set_content(value.toJson(value).dump(), "application/json");
        }

    }, result);
}
void Pet::handlePet{petId}Response(const Pet{petId}Response& result, httplib::Response& res) {
    std::visit([&](const auto& value) {
        using T = std::decay_t<decltype(value)>;
        //Success types
        if constexpr (std::is_same_v<T, models::Pet>) {
            res.status = HTTP_RESPONSE_CODE_PET;
            res.set_content(value.toJson(value).dump(), "application/json");
        }
        

    }, result);
}
Pet::PetRequestParams Pet::parsePetParams(const httplib::Request& req) {
    Pet::PetRequestParams params;
    params.m_request = models::Pet::fromJson(nlohmann::json::parse(req.body));
    return params;
}
void Pet::handlePetResponse(const PetResponse& result, httplib::Response& res) {
    std::visit([&](const auto& value) {
        using T = std::decay_t<decltype(value)>;
        //Success types
        if constexpr (std::is_same_v<T, models::Pet>) {
            res.status = HTTP_RESPONSE_CODE_PET;
            res.set_content(value.toJson(value).dump(), "application/json");
        }
        

    }, result);
}
void Pet::handlePet{petId}UploadImageResponse(const Pet{petId}UploadImageResponse& result, httplib::Response& res) {
    std::visit([&](const auto& value) {
        using T = std::decay_t<decltype(value)>;
        //Success types
        if constexpr (std::is_same_v<T, models::ApiResponse>) {
            res.status = HTTP_RESPONSE_CODE_API_RESPONSE;
            res.set_content(value.toJson(value).dump(), "application/json");
        }
        

    }, result);
}

void Pet::registerRoutes(httplib::Server& svr) {
    svr.Post("/pet", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto params = parsePetParams(req);
            auto result = handlePostForPet(params);
            handlePetResponse(result, res);
        }catch (const nlohmann::json::parse_error& e) {
            nlohmann::json errorJson = { {"message", "Invalid JSON: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
    svr.Delete("/pet/{petId}", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto params = parsePet{petId}Params(req);
            auto result = handleDeleteForPet{petId}(params);
        }catch (const std::exception& e) {
            nlohmann::json errorJson = { {"message", "Internal error: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
    svr.Get("/pet/findByStatus", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto params = parsePetFindByStatusParams(req);
            auto result = handleGetForPetFindByStatus(params);
            handlePetFindByStatusResponse(result, res);
        }catch (const std::exception& e) {
            nlohmann::json errorJson = { {"message", "Internal error: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
    svr.Get("/pet/findByTags", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto params = parsePetFindByTagsParams(req);
            auto result = handleGetForPetFindByTags(params);
            handlePetFindByTagsResponse(result, res);
        }catch (const std::exception& e) {
            nlohmann::json errorJson = { {"message", "Internal error: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
    svr.Get("/pet/{petId}", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto result = handleGetForPet{petId}();
            handlePet{petId}Response(result, res);
        }catch (const std::exception& e) {
            nlohmann::json errorJson = { {"message", "Internal error: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
    svr.Put("/pet", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto params = parsePetParams(req);
            auto result = handlePutForPet(params);
            handlePetResponse(result, res);
        }catch (const nlohmann::json::parse_error& e) {
            nlohmann::json errorJson = { {"message", "Invalid JSON: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
    svr.Post("/pet/{petId}", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto result = handlePostForPet{petId}();
        }catch (const std::exception& e) {
            nlohmann::json errorJson = { {"message", "Internal error: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
    svr.Post("/pet/{petId}/uploadImage", [this]([[maybe_unused]]const httplib::Request& req, httplib::Response& res) {
        try {
            auto result = handlePostForPet{petId}UploadImage();
            handlePet{petId}UploadImageResponse(result, res);
        }catch (const std::exception& e) {
            nlohmann::json errorJson = { {"message", "Internal error: " + std::string(e.what())} };
            res.set_content(errorJson.dump(), "application/json");
        }
    });
}

} // namespace api