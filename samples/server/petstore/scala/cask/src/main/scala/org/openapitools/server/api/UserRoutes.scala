//> using scala "3.3.1"
//> using lib "com.lihaoyi::cask:0.8.3"
//> using lib "com.lihaoyi::scalatags:0.12.0"
/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: contact@kindservices.co.uk
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 */


// this is generated from apiRoutes.mustache
package org.openapitools.server.api

import java.time.OffsetDateTime
import org.openapitools.server.model.User


final case class UserRoutes(service : UserService) extends cask.Routes {

    // route group for routeWorkAroundForGETUser
    @cask.get("/user", true)
    def routeWorkAroundForGETUser(request: cask.Request,username : Option[String] = None,password : Option[String] = None) = {
        request.remainingPathSegments match {
            case Seq("login") => loginUser(request,username.getOrElse(""), password.getOrElse(""))
            case Seq("logout") => logoutUser(request)
            case Seq(username) => getUserByName(username,request)
            case _          => asHttpResponse(Right(ServiceResponse.NotFound()))
        }
    }

        
        /** Create user
         * 
         */
        @cask.post("/user")
        def createUser(request: cask.Request) = {
            // auth method api_key : apiKey, keyParamName: api_key

        val serviceResponse =         for {
            
            /** TODO - this is a bit of a hack - we should do content type negotiation */
            user <- Parsed.eval(User.fromJsonString(request.bodyAsString))
            result <- Parsed.eval(service.createUser(user))
        } yield result

        asHttpResponse(serviceResponse)
      }
        
        /** Creates list of users with given input array
         * 
         */
        @cask.post("/user/createWithArray")
        def createUsersWithArrayInput(request: cask.Request) = {
            // auth method api_key : apiKey, keyParamName: api_key

        val serviceResponse =         for {
            
            /** TODO - this is a bit of a hack - we should do content type negotiation */
            user <- Parsed.eval(User.manyFromJsonString(request.bodyAsString))
            result <- Parsed.eval(service.createUsersWithArrayInput(user))
        } yield result

        asHttpResponse(serviceResponse)
      }
        
        /** Creates list of users with given input array
         * 
         */
        @cask.post("/user/createWithList")
        def createUsersWithListInput(request: cask.Request) = {
            // auth method api_key : apiKey, keyParamName: api_key

        val serviceResponse =         for {
            
            /** TODO - this is a bit of a hack - we should do content type negotiation */
            user <- Parsed.eval(User.manyFromJsonString(request.bodyAsString))
            result <- Parsed.eval(service.createUsersWithListInput(user))
        } yield result

        asHttpResponse(serviceResponse)
      }
        
        /** Delete user
         * 
         */
        @cask.delete("/user/:username")
        def deleteUser(username : String, request: cask.Request) = {
            // auth method api_key : apiKey, keyParamName: api_key

        val serviceResponse =         for {
            
            username <- Parsed(username)
            result <- Parsed.eval(service.deleteUser(username))
        } yield result

        asHttpResponse(serviceResponse)
      }
        
        /** Get user by user name
         * 
         */
        // conflicts with [/user/{username}, /user/login, /user/logout] after/user, ignoring @cask.get("/user/:username")
        def getUserByName(username : String, request: cask.Request) = {

        val serviceResponse =         for {
            
            username <- Parsed(username)
            result <- Parsed.eval(service.getUserByName(username))
        } yield result

        asHttpResponse(serviceResponse)
      }
        
        /** Logs user into the system
         * 
         */
        // conflicts with [/user/{username}, /user/login, /user/logout] after/user, ignoring @cask.get("/user/login")
        def loginUser(request: cask.Request, username : String, password : String) = {

        val serviceResponse =         for {
            result <- Parsed.eval(service.loginUser(username, password))
        } yield result

        asHttpResponse(serviceResponse)
      }
        
        /** Logs out current logged in user session
         * 
         */
        // conflicts with [/user/{username}, /user/login, /user/logout] after/user, ignoring @cask.get("/user/logout")
        def logoutUser(request: cask.Request) = {
            // auth method api_key : apiKey, keyParamName: api_key

        val serviceResponse =         for {
            result <- Parsed.eval(service.logoutUser())
        } yield result

        asHttpResponse(serviceResponse)
      }
        
        /** Updated user
         * 
         */
        @cask.put("/user/:username")
        def updateUser(username : String, request: cask.Request) = {
            // auth method api_key : apiKey, keyParamName: api_key

        val serviceResponse =         for {
            
            username <- Parsed(username)
            
            /** TODO - this is a bit of a hack - we should do content type negotiation */
            user <- Parsed.eval(User.fromJsonString(request.bodyAsString))
            result <- Parsed.eval(service.updateUser(username, user))
        } yield result

        asHttpResponse(serviceResponse)
      }

    initialize()
}
