# coding: utf-8

"""
    OpenAPI Petstore

    This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\  # noqa: E501

    OpenAPI spec version: 1.0.0
    Generated by: https://openapi-generator.tech
"""


import copy
from datetime import date, datetime  # noqa: F401
import os
import re
import tempfile

from dateutil.parser import parse
import six

from petstore_api.exceptions import (
    ApiKeyError,
    ApiTypeError,
    ApiValueError,
)

none_type = type(None)
if six.PY3:
    import io
    file_type = io.IOBase
else:
    file_type = file  # noqa: F821


class OpenApiModel(object):
    """The base class for all OpenAPIModels"""

COERCION_INDEX_BY_TYPE = {
    none_type: 0,
    list: 1,
    OpenApiModel: 2,
    dict: 3,
    float: 4,
    int: 5,
    bool: 6,
    datetime: 7,
    date: 8,
    str: 9
}
COERCIBLE_TYPE_PAIRS = (
    (dict, OpenApiModel),
    (list, OpenApiModel),
    (str, int),
    (str, float),
    (str, datetime),
    (str, date),
    (int, str),
    (float, str),
    (str, file_type)
)


def order_response_types(required_types):
    """Returns the required types sorted in coercion order

    Args:
        required_types (list/tuple): collection of classes or instance of
            list or dict with classs information inside it

    Returns:
        (list): coercion order sorted collection of classes or instance
            of list or dict with classs information inside it
    """

    def index_getter(class_or_instance):
        if isinstance(class_or_instance, list):
            return COERCION_INDEX_BY_TYPE[list]
        elif isinstance(class_or_instance, dict):
            return COERCION_INDEX_BY_TYPE[dict]
        elif issubclass(class_or_instance, OpenApiModel):
            return COERCION_INDEX_BY_TYPE[OpenApiModel]
        return COERCION_INDEX_BY_TYPE[class_or_instance]

    sorted_types = sorted(
        required_types,
        key=lambda class_or_instance: index_getter(class_or_instance)
    )
    return sorted_types


def remove_uncoercible(required_types_classes, current_item):
    """Only keeps the type conversions that are possible

    Args:
        required_types_classes (tuple): tuple of classes that are required
        current_item (any): the current item to be converted

    Returns:
        (list): the remaining coercible required types, classes only
    """
    if isinstance(current_item, file_type):
        current_type = file_type
    else:
        current_type = type(current_item)

    results_classes = []
    for real_required_type_class in required_types_classes:
        if real_required_type_class == current_type:
            # don't consider converting to one's own class
            continue
        required_type_class = real_required_type_class
        if issubclass(real_required_type_class, OpenApiModel):
            required_type_class = OpenApiModel
        class_pair = (current_type, required_type_class)
        if class_pair in COERCIBLE_TYPE_PAIRS:
            results_classes.append(real_required_type_class)
    return results_classes


def get_parent_key_or_index(input_data, path_to_item):
    """Returns a tuple of parent, key_or_index

    Args:
        input_data (dict/list): the root data object that had an
                                ApiTypeException
        path_to_item (list): the path to the exception, values are keys or
                              indices

    Returns:
        (parent, key_or_index):
            parent (dict/list): the parent of the item that has an
                                ApiTypeException
            key_or_index (str/int): the key that points to the item that has an
                                    ApiTypeException
    """
    current_item = input_data
    for index, path_value in enumerate(path_to_item[:-1]):
        current_item = current_item[path_value]
    parent = current_item
    key_or_index = path_to_item[-1]
    return parent, key_or_index


def get_required_type_classes(required_types_mixed):
    """Converts the tuple required_types into a tuple and a dict described
    below

    Args:
        required_types_mixed (tuple/list): will contain either classes or
            instance of list or dict

    Returns:
        (valid_classes, dict_valid_class_to_child_types_mixed):
            valid_classes (tuple): the valid classes that the current item
                                   should be
            dict_valid_class_to_child_types_mixed (doct):
                valid_class (class): this is the key
                child_types_mixed (list/dict/tuple): describes the valid child
                    types
    """
    valid_classes = []
    child_req_types_by_current_type = {}
    for required_type in required_types_mixed:
        if isinstance(required_type, list):
            valid_classes.append(list)
            child_req_types_by_current_type[list] = required_type[0]
        elif isinstance(required_type, dict):
            valid_classes.append(dict)
            child_req_types_by_current_type[dict] = required_type[str]
        else:
            valid_classes.append(required_type)
    return tuple(valid_classes), child_req_types_by_current_type


def change_keys_js_to_python(input_dict, model_class):
    """
    Converts from javascript_key keys in the input_dict to python_keys in
    the output dict using the mapping in model_class
    """

    output_dict = {}
    reversed_attr_map = {value: key for key, value in
                         six.iteritems(model_class.attribute_map)}
    for javascript_key, value in six.iteritems(input_dict):
        python_key = reversed_attr_map.get(javascript_key)
        if python_key is None:
            # if the key is unknown, it is in error or it is an
            # additionalProperties variable
            python_key = javascript_key
        output_dict[python_key] = value
    return output_dict


def get_type_error(var_value, path_to_item, valid_classes, key_type=False):
    error_msg = type_error_message(
        var_name=path_to_item[-1],
        var_value=var_value,
        valid_classes=valid_classes,
        key_type=key_type
    )
    return ApiTypeError(
        error_msg,
        path_to_item=path_to_item,
        valid_classes=valid_classes,
        key_type=key_type
    )


def deserialize_primitive(data, klass, path_to_item):
    """Deserializes string to primitive type.

    :param data: str/int/float
    :param klass: str/class the class to convert to

    :return: int, float, str, bool, date, datetime
    """
    additional_message = ""
    try:
        if klass in {datetime, date}:
            additional_message = (
                ". If you need your parameter to have a fallback "
                "string value, please set its type as `type: {}` in your "
                "spec. That allows the value to be any type."
            )
            if klass == datetime:
                # The string should be in iso8601 datetime format.
                parsed_datetime = parse(data)
                date_only = (parsed_datetime.hour == 0 and
                    parsed_datetime.minute == 0 and
                    parsed_datetime.second == 0 and
                    parsed_datetime.tzinfo == None and
                    8 <= len(data) <= 10)
                if date_only:
                    raise ValueError("This is a date, not a datetime")
                return parsed_datetime
            elif klass == date:
                return parse(data).date()
        else:
            converted_value = klass(data)
            if isinstance(data, str) and klass == float:
                if str(converted_value) != data:
                    # '7' -> 7.0 -> '7.0' != '7'
                    raise ValueError('This is not a float')
            return converted_value
    except (OverflowError, ValueError):
        # parse can raise OverflowError
        raise ApiValueError(
            "Failed to parse {0} as {1}{2}".format(
                repr(data), klass, additional_message
            ),
            path_to_item=path_to_item
        )


def deserialize_model(model_data, model_class, path_to_item, configuration):
    """Deserializes model_data to model instance.

    Args:
        model_data (list/dict): data to instantiate the model
        model_class (OpenApiModel): the model class
        path_to_item (list): path to the model in the received data
        configuration (Configuration): the instance to use to convert files

    Returns:
        model instance

    Raise:
        ApiTypeError
        ApiValueError
        ApiKeyError
    """
    fixed_model_data = copy.deepcopy(model_data)

    if isinstance(fixed_model_data, dict):
        fixed_model_data = change_keys_js_to_python(fixed_model_data,
                                                    model_class)

    kw_args = dict(_check_type=True,
                   _path_to_item=path_to_item,
                   _configuration=configuration)
    if isinstance(model_data, list):
        instance = model_class(*model_data, **kw_args)
    elif isinstance(model_data, dict):
        kw_args.update(fixed_model_data)
        instance = model_class(**kw_args)

    if hasattr(instance, 'get_real_child_model'):
        discriminator_class = instance.get_real_child_model(model_data)
        if discriminator_class:
            if isinstance(model_data, list):
                instance = discriminator_class(*model_data, **kw_args)
            elif isinstance(model_data, dict):
                instance = discriminator_class(**kw_args)

    return instance


def deserialize_file(self, response_data, configuration,
                     content_disposition=None):
    """Deserializes body to file

    Saves response body into a file in a temporary folder,
    using the filename from the `Content-Disposition` header if provided.

    Args:
        param response_data (str):  the file data to write
        configuration (Configuration): the instance to use to convert files

    Keyword Args:
        content_disposition (str):  the value of the Content-Disposition
            header

    Returns:
        (str): the deserialized file path
    """
    fd, path = tempfile.mkstemp(dir=configuration.temp_folder_path)
    os.close(fd)
    os.remove(path)

    if content_disposition:
        filename = re.search(r'filename=[\'"]?([^\'"\s]+)[\'"]?',
                             content_disposition).group(1)
        path = os.path.join(os.path.dirname(path), filename)

    with open(path, "wb") as f:
        f.write(response_data)

    return path


def attempt_convert_item(input_value, valid_classes, path_to_item,
                         configuration, key_type=False, must_convert=False):
    """
    Args:
        input_value (any): the data to convert
        valid_classes (any): the classes that are valid
        path_to_item (list): the path to the item to convert
        configuration (Configuration): the instance to use to convert files
        key_type (bool): if True we need to convert a key type (not supported)
        must_convert (bool): if True we must convert

    Returns:
        instance (any) the fixed item

    Raises:
        ApiTypeError
        ApiValueError
        ApiKeyError
    """
    valid_classes_ordered = order_response_types(valid_classes)
    valid_classes_coercible = remove_uncoercible(
        valid_classes_ordered, input_value)
    type_error = get_type_error(input_value, path_to_item, valid_classes,
        key_type=key_type)
    if not valid_classes_coercible or key_type:
        # we do not handle keytype errors, json will take care
        # of this for us
        raise type_error
    deserialized_item = None
    for valid_class in valid_classes_coercible:
        try:
            if issubclass(valid_class, OpenApiModel):
                deserialized_item = deserialize_model(
                    input_value,
                    valid_class,
                    path_to_item,
                    configuration
                )
            elif isinstance(valid_class, file_type):
                deserialized_item = deserialize_file(
                    input_value, configuration)
            else:
                deserialized_item = deserialize_primitive(
                    input_value,
                    valid_class,
                    path_to_item
                )
            return deserialized_item
        except (ApiTypeError, ApiValueError, ApiKeyError) as conversion_exc:
            if must_convert:
                raise conversion_exc
            # if we have conversion errors when must_convert == False
            # we ignore the exception and move on to the next class
            continue
    # we were unable to convert, must_convert == False
    return input_value


def validate_and_convert_types(input_value, required_types_mixed, path_to_item,
                               configuration=None):
    """Raises a TypeError is there is a problem, otherwise returns value

    Args:
        input_value (any): the data to validate/convert
        required_types_mixed (list/dict/tuple): A list of
            valid classes, or a list tuples of valid classes, or a dict where
            the value is a tuple of value classes
        path_to_item: (list) the path to the data being validated
            this stores a list of keys or indices to get to the data being
            validated
        configuration: (Configuration): the configuration class to use
            when converting file_type items.
            If passed, conversion will be attempted when possible
            If not passed, no conversions will be attempted and
            exceptions will be raised

    Returns:
        the correctly typed value

    Raises:
        ApiTypeError
    """
    results = get_required_type_classes(required_types_mixed)
    valid_classes, child_req_types_by_current_type = results

    valid_type = False
    for required_class in valid_classes:
        if ((type(input_value) == bool and required_class == int) or
                (type(input_value) == datetime and required_class == date)):
            # we can't use isinstance because
            # isinstance(True, int) == True == isinstance(datetime_val, date)
            valid_type = False
            continue
        valid_type = isinstance(input_value, required_class)
        if valid_type:
            break
    if not valid_type:
        if configuration:
            # if input_value is not valid_type try to convert it
            converted_instance = attempt_convert_item(input_value,
                valid_classes, path_to_item, configuration, key_type=False,
                must_convert=True)
            return converted_instance
        else:
            raise get_type_error(input_value, path_to_item, valid_classes,
                key_type=False)

    # input_value's type is in valid_classes
    if len(valid_classes) > 1 and configuration:
        # there are valid classes which are not the current class
        valid_classes_ordered = order_response_types(valid_classes)
        valid_classes_coercible = remove_uncoercible(
            valid_classes_ordered, input_value)
        if valid_classes_coercible:
            converted_instance = attempt_convert_item(input_value,
                valid_classes_coercible, path_to_item, configuration,
                key_type=False, must_convert=False)
            return converted_instance

    if child_req_types_by_current_type == {}:
        # all types are of the required types and there are no more inner
        # variables left to look at
        return input_value
    inner_required_types = child_req_types_by_current_type.get(
        type(input_value)
    )
    if inner_required_types is None:
        # for this type, there are not more inner variables left to look at
        return input_value
    if isinstance(input_value, list):
        if input_value == []:
            # allow an empty list
            return input_value
        for index, inner_value in enumerate(input_value):
            inner_path = list(path_to_item)
            inner_path.append(index)
            input_value[index] = validate_and_convert_types(inner_value,
                inner_required_types, inner_path, configuration=configuration)
    elif isinstance(input_value, dict):
        if input_value == {}:
            # allow an empty dict
            return input_value
        for inner_key, inner_val in six.iteritems(input_value):
            inner_path = list(path_to_item)
            inner_path.append(inner_key)
            if not isinstance(inner_key, str):
                raise get_type_error(inner_key, inner_path, valid_classes,
                    key_type=True)
            input_value[inner_key] = validate_and_convert_types(inner_val,
                inner_required_types, inner_path, configuration=configuration)
    return input_value


def model_to_dict(model_instance, serialize=True):
    """Returns the model properties as a dict

    Args:
        model_instance (one of your model instances): the model instance that
            will be converted to a dict.

    Keyword Args:
        serialize (bool): if True, the keys in the dict will be values from
            attribute_map
    """
    result = {}

    for attr, value in six.iteritems(model_instance._data_store):
        if serialize:
            attr = model_instance.attribute_map[attr]
        if isinstance(value, list):
            result[attr] = list(map(
                lambda x: model_to_dict(x, serialize=serialize)
                if hasattr(x, '_data_store') else x, value
            ))
        elif isinstance(value, dict):
            result[attr] = dict(map(
                lambda item: (item[0],
                              model_to_dict(item[1], serialize=serialize))
                if hasattr(item[1], '_data_store') else item,
                value.items()
            ))
        elif hasattr(value, '_data_store'):
            result[attr] = model_to_dict(value, serialize=serialize)
        else:
            result[attr] = value

    return result


def type_error_message(var_value=None, var_name=None, valid_classes=None,
                       key_type=None):
    """
    Keyword Args:
        var_value (any): the variable which has the type_error
        var_name (str): the name of the variable which has the typ error
        valid_classes (tuple): the accepted classes for current_item's
                                  value
        key_type (bool): False if our value is a value in a dict
                         True if it is a key in a dict
                         False if our item is an item in a list
    """
    key_or_value = 'value'
    if key_type:
        key_or_value = 'key'
    valid_classes_phrase = 'is {0}'.format(valid_classes[0])
    if len(valid_classes) > 1:
        valid_classes_phrase = 'is one of {0}'.format(valid_classes)
    msg = (
        "Invalid type for variable '{0}'. Required {1} type {2} and "
        "passed type was {3}".format(
            var_name,
            key_or_value,
            valid_classes_phrase,
            type(var_value),
        )
    )
    return msg
