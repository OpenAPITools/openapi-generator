// <auto-generated>
/*
 * OpenAPI Petstore
 *
 * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using OpenAPIClientUtils = UseSourceGeneration.Client.ClientUtils;
using System.Text.Json.Serialization.Metadata;
using UseSourceGeneration.Client;

namespace UseSourceGeneration.Model
{
    /// <summary>
    /// FormatTest
    /// </summary>
    public partial class FormatTest : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="FormatTest" /> class.
        /// </summary>
        /// <param name="binary">binary</param>
        /// <param name="varByte">varByte</param>
        /// <param name="date">date</param>
        /// <param name="dateTime">dateTime</param>
        /// <param name="varDecimal">varDecimal</param>
        /// <param name="varDouble">varDouble</param>
        /// <param name="varFloat">varFloat</param>
        /// <param name="int32">int32</param>
        /// <param name="int64">int64</param>
        /// <param name="integer">integer</param>
        /// <param name="number">number</param>
        /// <param name="password">password</param>
        /// <param name="patternWithBackslash">None</param>
        /// <param name="patternWithDigits">A string that is a 10 digit number. Can have leading zeros.</param>
        /// <param name="patternWithDigitsAndDelimiter">A string starting with &#39;image_&#39; (case insensitive) and one to three digits following i.e. Image_01.</param>
        /// <param name="varString">varString</param>
        /// <param name="unsignedInteger">unsignedInteger</param>
        /// <param name="unsignedLong">unsignedLong</param>
        /// <param name="uuid">uuid</param>
        [JsonConstructor]
        public FormatTest(System.IO.Stream binary, byte[] varByte, DateTime date, DateTime dateTime, decimal varDecimal, double varDouble, float varFloat, int int32, long int64, int integer, decimal number, string password, string patternWithBackslash, string patternWithDigits, string patternWithDigitsAndDelimiter, string varString, uint unsignedInteger, ulong unsignedLong, Guid uuid)
        {
            Binary = binary;
            VarByte = varByte;
            Date = date;
            DateTime = dateTime;
            VarDecimal = varDecimal;
            VarDouble = varDouble;
            VarFloat = varFloat;
            Int32 = int32;
            Int64 = int64;
            Integer = integer;
            Number = number;
            Password = password;
            PatternWithBackslash = patternWithBackslash;
            PatternWithDigits = patternWithDigits;
            PatternWithDigitsAndDelimiter = patternWithDigitsAndDelimiter;
            VarString = varString;
            UnsignedInteger = unsignedInteger;
            UnsignedLong = unsignedLong;
            Uuid = uuid;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets Binary
        /// </summary>
        [JsonPropertyName("binary")]
        public System.IO.Stream Binary { get; set; }

        /// <summary>
        /// Gets or Sets VarByte
        /// </summary>
        [JsonPropertyName("byte")]
        public byte[] VarByte { get; set; }

        /// <summary>
        /// Gets or Sets Date
        /// </summary>
        /// <example>Sun Feb 02 00:00:00 UTC 2020</example>
        [JsonPropertyName("date")]
        public DateTime Date { get; set; }

        /// <summary>
        /// Gets or Sets DateTime
        /// </summary>
        /// <example>2007-12-03T10:15:30+01:00</example>
        [JsonPropertyName("dateTime")]
        public DateTime DateTime { get; set; }

        /// <summary>
        /// Gets or Sets VarDecimal
        /// </summary>
        [JsonPropertyName("decimal")]
        public decimal VarDecimal { get; set; }

        /// <summary>
        /// Gets or Sets VarDouble
        /// </summary>
        [JsonPropertyName("double")]
        public double VarDouble { get; set; }

        /// <summary>
        /// Gets or Sets VarFloat
        /// </summary>
        [JsonPropertyName("float")]
        public float VarFloat { get; set; }

        /// <summary>
        /// Gets or Sets Int32
        /// </summary>
        [JsonPropertyName("int32")]
        public int Int32 { get; set; }

        /// <summary>
        /// Gets or Sets Int64
        /// </summary>
        [JsonPropertyName("int64")]
        public long Int64 { get; set; }

        /// <summary>
        /// Gets or Sets Integer
        /// </summary>
        [JsonPropertyName("integer")]
        public int Integer { get; set; }

        /// <summary>
        /// Gets or Sets Number
        /// </summary>
        [JsonPropertyName("number")]
        public decimal Number { get; set; }

        /// <summary>
        /// Gets or Sets Password
        /// </summary>
        [JsonPropertyName("password")]
        public string Password { get; set; }

        /// <summary>
        /// None
        /// </summary>
        /// <value>None</value>
        [JsonPropertyName("pattern_with_backslash")]
        public string PatternWithBackslash { get; set; }

        /// <summary>
        /// A string that is a 10 digit number. Can have leading zeros.
        /// </summary>
        /// <value>A string that is a 10 digit number. Can have leading zeros.</value>
        [JsonPropertyName("pattern_with_digits")]
        public string PatternWithDigits { get; set; }

        /// <summary>
        /// A string starting with &#39;image_&#39; (case insensitive) and one to three digits following i.e. Image_01.
        /// </summary>
        /// <value>A string starting with &#39;image_&#39; (case insensitive) and one to three digits following i.e. Image_01.</value>
        [JsonPropertyName("pattern_with_digits_and_delimiter")]
        public string PatternWithDigitsAndDelimiter { get; set; }

        /// <summary>
        /// Gets or Sets VarString
        /// </summary>
        [JsonPropertyName("string")]
        public string VarString { get; set; }

        /// <summary>
        /// Gets or Sets UnsignedInteger
        /// </summary>
        [JsonPropertyName("unsigned_integer")]
        public uint UnsignedInteger { get; set; }

        /// <summary>
        /// Gets or Sets UnsignedLong
        /// </summary>
        [JsonPropertyName("unsigned_long")]
        public ulong UnsignedLong { get; set; }

        /// <summary>
        /// Gets or Sets Uuid
        /// </summary>
        /// <example>72f98069-206d-4f12-9f12-3d1e525a8e84</example>
        [JsonPropertyName("uuid")]
        public Guid Uuid { get; set; }

        /// <summary>
        /// Gets or Sets additional properties
        /// </summary>
        [JsonExtensionData]
        public Dictionary<string, JsonElement> AdditionalProperties { get; } = new Dictionary<string, JsonElement>();

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class FormatTest {\n");
            sb.Append("  Binary: ").Append(Binary).Append("\n");
            sb.Append("  VarByte: ").Append(VarByte).Append("\n");
            sb.Append("  Date: ").Append(Date).Append("\n");
            sb.Append("  DateTime: ").Append(DateTime).Append("\n");
            sb.Append("  VarDecimal: ").Append(VarDecimal).Append("\n");
            sb.Append("  VarDouble: ").Append(VarDouble).Append("\n");
            sb.Append("  VarFloat: ").Append(VarFloat).Append("\n");
            sb.Append("  Int32: ").Append(Int32).Append("\n");
            sb.Append("  Int64: ").Append(Int64).Append("\n");
            sb.Append("  Integer: ").Append(Integer).Append("\n");
            sb.Append("  Number: ").Append(Number).Append("\n");
            sb.Append("  Password: ").Append(Password).Append("\n");
            sb.Append("  PatternWithBackslash: ").Append(PatternWithBackslash).Append("\n");
            sb.Append("  PatternWithDigits: ").Append(PatternWithDigits).Append("\n");
            sb.Append("  PatternWithDigitsAndDelimiter: ").Append(PatternWithDigitsAndDelimiter).Append("\n");
            sb.Append("  VarString: ").Append(VarString).Append("\n");
            sb.Append("  UnsignedInteger: ").Append(UnsignedInteger).Append("\n");
            sb.Append("  UnsignedLong: ").Append(UnsignedLong).Append("\n");
            sb.Append("  Uuid: ").Append(Uuid).Append("\n");
            sb.Append("  AdditionalProperties: ").Append(AdditionalProperties).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            // VarDouble (double) maximum
            if (this.VarDouble > (double)123.4)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VarDouble, must be a value less than or equal to 123.4.", new [] { "VarDouble" });
            }

            // VarDouble (double) minimum
            if (this.VarDouble < (double)67.8)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VarDouble, must be a value greater than or equal to 67.8.", new [] { "VarDouble" });
            }

            // VarFloat (float) maximum
            if (this.VarFloat > (float)987.6)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VarFloat, must be a value less than or equal to 987.6.", new [] { "VarFloat" });
            }

            // VarFloat (float) minimum
            if (this.VarFloat < (float)54.3)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VarFloat, must be a value greater than or equal to 54.3.", new [] { "VarFloat" });
            }

            // Int32 (int) maximum
            if (this.Int32 > (int)200)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Int32, must be a value less than or equal to 200.", new [] { "Int32" });
            }

            // Int32 (int) minimum
            if (this.Int32 < (int)20)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Int32, must be a value greater than or equal to 20.", new [] { "Int32" });
            }

            // Integer (int) maximum
            if (this.Integer > (int)100)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Integer, must be a value less than or equal to 100.", new [] { "Integer" });
            }

            // Integer (int) minimum
            if (this.Integer < (int)10)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Integer, must be a value greater than or equal to 10.", new [] { "Integer" });
            }

            // Number (decimal) maximum
            if (this.Number > (decimal)543.2)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Number, must be a value less than or equal to 543.2.", new [] { "Number" });
            }

            // Number (decimal) minimum
            if (this.Number < (decimal)32.1)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Number, must be a value greater than or equal to 32.1.", new [] { "Number" });
            }

            // Password (string) maxLength
            if (this.Password != null && this.Password.Length > 64)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Password, length must be less than 64.", new [] { "Password" });
            }

            // Password (string) minLength
            if (this.Password != null && this.Password.Length < 10)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for Password, length must be greater than 10.", new [] { "Password" });
            }

            if (this.PatternWithBackslash != null) {
                // PatternWithBackslash (string) pattern
                Regex regexPatternWithBackslash = new Regex(@"^(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$", RegexOptions.CultureInvariant);
                if (!regexPatternWithBackslash.Match(this.PatternWithBackslash).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PatternWithBackslash, must match a pattern of " + regexPatternWithBackslash, new [] { "PatternWithBackslash" });
                }
            }

            if (this.PatternWithDigits != null) {
                // PatternWithDigits (string) pattern
                Regex regexPatternWithDigits = new Regex(@"^\d{10}$", RegexOptions.CultureInvariant);
                if (!regexPatternWithDigits.Match(this.PatternWithDigits).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PatternWithDigits, must match a pattern of " + regexPatternWithDigits, new [] { "PatternWithDigits" });
                }
            }

            if (this.PatternWithDigitsAndDelimiter != null) {
                // PatternWithDigitsAndDelimiter (string) pattern
                Regex regexPatternWithDigitsAndDelimiter = new Regex(@"^image_\d{1,3}$", RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);
                if (!regexPatternWithDigitsAndDelimiter.Match(this.PatternWithDigitsAndDelimiter).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for PatternWithDigitsAndDelimiter, must match a pattern of " + regexPatternWithDigitsAndDelimiter, new [] { "PatternWithDigitsAndDelimiter" });
                }
            }

            if (this.VarString != null) {
                // VarString (string) pattern
                Regex regexVarString = new Regex(@"[a-z]", RegexOptions.CultureInvariant | RegexOptions.IgnoreCase);
                if (!regexVarString.Match(this.VarString).Success)
                {
                    yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for VarString, must match a pattern of " + regexVarString, new [] { "VarString" });
                }
            }

            // UnsignedInteger (uint) maximum
            if (this.UnsignedInteger > (uint)200)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UnsignedInteger, must be a value less than or equal to 200.", new [] { "UnsignedInteger" });
            }

            // UnsignedInteger (uint) minimum
            if (this.UnsignedInteger < (uint)20)
            {
                yield return new System.ComponentModel.DataAnnotations.ValidationResult("Invalid value for UnsignedInteger, must be a value greater than or equal to 20.", new [] { "UnsignedInteger" });
            }

            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="FormatTest" />
    /// </summary>
    public class FormatTestJsonConverter : JsonConverter<FormatTest>
    {
        /// <summary>
        /// The format to use to serialize Date
        /// </summary>
        public static string DateFormat { get; set; } = "yyyy'-'MM'-'dd";

        /// <summary>
        /// The format to use to serialize DateTime
        /// </summary>
        public static string DateTimeFormat { get; set; } = "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK";

        /// <summary>
        /// Deserializes json to <see cref="FormatTest" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override FormatTest Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            System.IO.Stream? binary = default;
            byte[]? varByte = default;
            DateTime? date = default;
            DateTime? dateTime = default;
            decimal? varDecimal = default;
            double? varDouble = default;
            float? varFloat = default;
            int? int32 = default;
            long? int64 = default;
            int? integer = default;
            decimal? number = default;
            string? password = default;
            string? patternWithBackslash = default;
            string? patternWithDigits = default;
            string? patternWithDigitsAndDelimiter = default;
            string? varString = default;
            uint? unsignedInteger = default;
            ulong? unsignedLong = default;
            Guid? uuid = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "binary":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                binary = JsonSerializer.Deserialize<System.IO.Stream>(ref utf8JsonReader, jsonSerializerOptions);
                            break;
                        case "byte":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                varByte = JsonSerializer.Deserialize<byte[]>(ref utf8JsonReader, jsonSerializerOptions);
                            break;
                        case "date":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                date = JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions);
                            break;
                        case "dateTime":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                dateTime = JsonSerializer.Deserialize<DateTime>(ref utf8JsonReader, jsonSerializerOptions);
                            break;
                        case "decimal":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                varDecimal = JsonSerializer.Deserialize<decimal>(ref utf8JsonReader, jsonSerializerOptions);
                            break;
                        case "double":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                varDouble = utf8JsonReader.GetDouble();
                            break;
                        case "float":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                varFloat = (float)utf8JsonReader.GetDouble();
                            break;
                        case "int32":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                int32 = utf8JsonReader.GetInt32();
                            break;
                        case "int64":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                int64 = utf8JsonReader.GetInt64();
                            break;
                        case "integer":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                integer = utf8JsonReader.GetInt32();
                            break;
                        case "number":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                number = utf8JsonReader.GetDecimal();
                            break;
                        case "password":
                            password = utf8JsonReader.GetString();
                            break;
                        case "pattern_with_backslash":
                            patternWithBackslash = utf8JsonReader.GetString();
                            break;
                        case "pattern_with_digits":
                            patternWithDigits = utf8JsonReader.GetString();
                            break;
                        case "pattern_with_digits_and_delimiter":
                            patternWithDigitsAndDelimiter = utf8JsonReader.GetString();
                            break;
                        case "string":
                            varString = utf8JsonReader.GetString();
                            break;
                        case "unsigned_integer":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                unsignedInteger = utf8JsonReader.GetUInt32();
                            break;
                        case "unsigned_long":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                unsignedLong = utf8JsonReader.GetUInt64();
                            break;
                        case "uuid":
                            if (utf8JsonReader.TokenType != JsonTokenType.Null)
                                uuid = utf8JsonReader.GetGuid();
                            break;
                        default:
                            break;
                    }
                }
            }

            if (binary == null)
                throw new ArgumentNullException(nameof(binary), "Property is required for class FormatTest.");

            if (varByte == null)
                throw new ArgumentNullException(nameof(varByte), "Property is required for class FormatTest.");

            if (date == null)
                throw new ArgumentNullException(nameof(date), "Property is required for class FormatTest.");

            if (dateTime == null)
                throw new ArgumentNullException(nameof(dateTime), "Property is required for class FormatTest.");

            if (varDecimal == null)
                throw new ArgumentNullException(nameof(varDecimal), "Property is required for class FormatTest.");

            if (varDouble == null)
                throw new ArgumentNullException(nameof(varDouble), "Property is required for class FormatTest.");

            if (varFloat == null)
                throw new ArgumentNullException(nameof(varFloat), "Property is required for class FormatTest.");

            if (int32 == null)
                throw new ArgumentNullException(nameof(int32), "Property is required for class FormatTest.");

            if (int64 == null)
                throw new ArgumentNullException(nameof(int64), "Property is required for class FormatTest.");

            if (integer == null)
                throw new ArgumentNullException(nameof(integer), "Property is required for class FormatTest.");

            if (number == null)
                throw new ArgumentNullException(nameof(number), "Property is required for class FormatTest.");

            if (password == null)
                throw new ArgumentNullException(nameof(password), "Property is required for class FormatTest.");

            if (patternWithBackslash == null)
                throw new ArgumentNullException(nameof(patternWithBackslash), "Property is required for class FormatTest.");

            if (patternWithDigits == null)
                throw new ArgumentNullException(nameof(patternWithDigits), "Property is required for class FormatTest.");

            if (patternWithDigitsAndDelimiter == null)
                throw new ArgumentNullException(nameof(patternWithDigitsAndDelimiter), "Property is required for class FormatTest.");

            if (varString == null)
                throw new ArgumentNullException(nameof(varString), "Property is required for class FormatTest.");

            if (unsignedInteger == null)
                throw new ArgumentNullException(nameof(unsignedInteger), "Property is required for class FormatTest.");

            if (unsignedLong == null)
                throw new ArgumentNullException(nameof(unsignedLong), "Property is required for class FormatTest.");

            if (uuid == null)
                throw new ArgumentNullException(nameof(uuid), "Property is required for class FormatTest.");

            return new FormatTest(binary, varByte, date.Value, dateTime.Value, varDecimal.Value, varDouble.Value, varFloat.Value, int32.Value, int64.Value, integer.Value, number.Value, password, patternWithBackslash, patternWithDigits, patternWithDigitsAndDelimiter, varString, unsignedInteger.Value, unsignedLong.Value, uuid.Value);
        }

        /// <summary>
        /// Serializes a <see cref="FormatTest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="formatTest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, FormatTest formatTest, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(ref writer, formatTest, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="FormatTest" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="formatTest"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(ref Utf8JsonWriter writer, FormatTest formatTest, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WritePropertyName("binary");
            JsonSerializer.Serialize(writer, formatTest.Binary, jsonSerializerOptions);
            writer.WritePropertyName("byte");
            JsonSerializer.Serialize(writer, formatTest.VarByte, jsonSerializerOptions);
            writer.WriteString("date", formatTest.Date.ToString(DateFormat));
            writer.WriteString("dateTime", formatTest.DateTime.ToString(DateTimeFormat));
            writer.WritePropertyName("decimal");
            JsonSerializer.Serialize(writer, formatTest.VarDecimal, jsonSerializerOptions);
            writer.WriteNumber("double", formatTest.VarDouble);
            writer.WriteNumber("float", formatTest.VarFloat);
            writer.WriteNumber("int32", formatTest.Int32);
            writer.WriteNumber("int64", formatTest.Int64);
            writer.WriteNumber("integer", formatTest.Integer);
            writer.WriteNumber("number", formatTest.Number);
            writer.WriteString("password", formatTest.Password);
            writer.WriteString("pattern_with_backslash", formatTest.PatternWithBackslash);
            writer.WriteString("pattern_with_digits", formatTest.PatternWithDigits);
            writer.WriteString("pattern_with_digits_and_delimiter", formatTest.PatternWithDigitsAndDelimiter);
            writer.WriteString("string", formatTest.VarString);
            writer.WriteNumber("unsigned_integer", formatTest.UnsignedInteger);
            writer.WriteNumber("unsigned_long", formatTest.UnsignedLong);
            writer.WriteString("uuid", formatTest.Uuid);
        }
    }

    /// <summary>
    /// The FormatTestSerializationContext
    /// </summary>
    [JsonSourceGenerationOptions(WriteIndented = true, GenerationMode = JsonSourceGenerationMode.Metadata | JsonSourceGenerationMode.Serialization)]
    [JsonSerializable(typeof(FormatTest))]
    public partial class FormatTestSerializationContext : JsonSerializerContext { }
}
