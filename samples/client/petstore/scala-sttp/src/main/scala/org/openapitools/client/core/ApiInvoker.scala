/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.core

import org.joda.time.DateTime
import org.joda.time.format.ISODateTimeFormat
import org.json4s.JsonAST.JString
import org.json4s._
import sttp.client._
import org.openapitools.client.api.EnumsSerializers
import org.openapitools.client.core.ApiInvoker.DateTimeSerializer
import sttp.client.json4s.SttpJson4sApi
import sttp.client.monad.MonadError

class SttpSerializer(implicit val format: Formats = DefaultFormats ++ EnumsSerializers.all + DateTimeSerializer,
                     implicit val serialization: org.json4s.Serialization = org.json4s.jackson.Serialization) extends SttpJson4sApi

class HttpException(val statusCode: Int, val statusText: String, val message: String) extends Exception(s"[$statusCode] $statusText: $message")

object Helpers {

  // Helper to handle Optional header parameters
  implicit class optionalParams(val request: RequestT[Identity, Either[String, String], Nothing]) extends AnyVal {
    def header( header: String, optValue: Option[Any]): RequestT[Identity, Either[String, String], Nothing] = {
      optValue.map( value => request.header(header, value.toString)).getOrElse(request)
    }
  }

}

object ApiInvoker {

  /**
    * Allows request execution without calling apiInvoker.execute(request)
    * request.result can be used to get a monad wrapped content.
    *
    * @param request the apiRequest to be executed
    */
  implicit class ApiRequestImprovements[R[_], T](request: RequestT[Identity, Either[ResponseError[Exception], T], Nothing]) {

    def result(implicit backend: SttpBackend[R, Nothing, Nothing]): R[T] = {
      val responseT = request.send()
      val ME: MonadError[R] = backend.responseMonad
      ME.flatMap(responseT) {
        response =>
          response.body match {
            case Left(ex) => ME.error[T](new HttpException(response.code.code, response.statusText, ex.body))
            case Right(value) => ME.unit(value)
          }
      }
    }
  }

  case object DateTimeSerializer extends CustomSerializer[DateTime](_ => ( {
    case JString(s) =>
      ISODateTimeFormat.dateOptionalTimeParser().parseDateTime(s)
  }, {
    case d: DateTime =>
      JString(ISODateTimeFormat.dateTime().print(d))
  })
  )

}
