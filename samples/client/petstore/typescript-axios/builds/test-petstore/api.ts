/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI Petstore
 * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdditionalPropertiesClass
 */
export interface AdditionalPropertiesClass {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AdditionalPropertiesClass
     */
    'map_property'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof AdditionalPropertiesClass
     */
    'map_of_map_property'?: { [key: string]: { [key: string]: string; }; };
    /**
     * 
     * @type {any}
     * @memberof AdditionalPropertiesClass
     */
    'anytype_1'?: any;
    /**
     * 
     * @type {object}
     * @memberof AdditionalPropertiesClass
     */
    'map_with_undeclared_properties_anytype_1'?: object;
    /**
     * 
     * @type {object}
     * @memberof AdditionalPropertiesClass
     */
    'map_with_undeclared_properties_anytype_2'?: object;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof AdditionalPropertiesClass
     */
    'map_with_undeclared_properties_anytype_3'?: { [key: string]: object; };
    /**
     * an object with no declared properties and no undeclared properties, hence it\'s an empty map.
     * @type {object}
     * @memberof AdditionalPropertiesClass
     */
    'empty_map'?: object;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AdditionalPropertiesClass
     */
    'map_with_undeclared_properties_string'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface Animal
 */
export interface Animal {
    /**
     * 
     * @type {string}
     * @memberof Animal
     */
    'className': string;
    /**
     * 
     * @type {string}
     * @memberof Animal
     */
    'color'?: string;
}
/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiResponse
     */
    'code'?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    'message'?: string;
}
/**
 * 
 * @export
 * @interface Apple
 */
export interface Apple {
    /**
     * 
     * @type {string}
     * @memberof Apple
     */
    'cultivar'?: string;
    /**
     * 
     * @type {string}
     * @memberof Apple
     */
    'origin'?: string;
}
/**
 * 
 * @export
 * @interface AppleReq
 */
export interface AppleReq {
    /**
     * 
     * @type {string}
     * @memberof AppleReq
     */
    'cultivar': string;
    /**
     * 
     * @type {boolean}
     * @memberof AppleReq
     */
    'mealy'?: boolean;
}
/**
 * 
 * @export
 * @interface ArrayOfArrayOfNumberOnly
 */
export interface ArrayOfArrayOfNumberOnly {
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof ArrayOfArrayOfNumberOnly
     */
    'ArrayArrayNumber'?: Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface ArrayOfNumberOnly
 */
export interface ArrayOfNumberOnly {
    /**
     * 
     * @type {Array<number>}
     * @memberof ArrayOfNumberOnly
     */
    'ArrayNumber'?: Array<number>;
}
/**
 * 
 * @export
 * @interface ArrayTest
 */
export interface ArrayTest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ArrayTest
     */
    'array_of_string'?: Array<string>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof ArrayTest
     */
    'array_array_of_integer'?: Array<Array<number>>;
    /**
     * 
     * @type {Array<Array<ReadOnlyFirst>>}
     * @memberof ArrayTest
     */
    'array_array_of_model'?: Array<Array<ReadOnlyFirst>>;
}
/**
 * 
 * @export
 * @interface Banana
 */
export interface Banana {
    /**
     * 
     * @type {number}
     * @memberof Banana
     */
    'lengthCm'?: number;
}
/**
 * 
 * @export
 * @interface BananaReq
 */
export interface BananaReq {
    /**
     * 
     * @type {number}
     * @memberof BananaReq
     */
    'lengthCm': number;
    /**
     * 
     * @type {boolean}
     * @memberof BananaReq
     */
    'sweet'?: boolean;
}
/**
 * 
 * @export
 * @interface BasquePig
 */
export interface BasquePig {
    /**
     * 
     * @type {string}
     * @memberof BasquePig
     */
    'className': string;
}
/**
 * 
 * @export
 * @interface Capitalization
 */
export interface Capitalization {
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    'smallCamel'?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    'CapitalCamel'?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    'small_Snake'?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    'Capital_Snake'?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    'SCA_ETH_Flow_Points'?: string;
    /**
     * Name of the pet 
     * @type {string}
     * @memberof Capitalization
     */
    'ATT_NAME'?: string;
}
/**
 * 
 * @export
 * @interface Cat
 */
export interface Cat extends Animal {
    /**
     * 
     * @type {boolean}
     * @memberof Cat
     */
    'declawed'?: boolean;
}
/**
 * 
 * @export
 * @interface CatAllOf
 */
export interface CatAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof CatAllOf
     */
    'declawed'?: boolean;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ChildCat
 */
export interface ChildCat extends ParentPet {
    /**
     * 
     * @type {string}
     * @memberof ChildCat
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChildCat
     */
    'pet_type': ChildCatPetTypeEnum;
}

export const ChildCatPetTypeEnum = {
    ChildCat: 'ChildCat'
} as const;

export type ChildCatPetTypeEnum = typeof ChildCatPetTypeEnum[keyof typeof ChildCatPetTypeEnum];

/**
 * 
 * @export
 * @interface ChildCatAllOf
 */
export interface ChildCatAllOf {
    /**
     * 
     * @type {string}
     * @memberof ChildCatAllOf
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof ChildCatAllOf
     */
    'pet_type'?: ChildCatAllOfPetTypeEnum;
}

export const ChildCatAllOfPetTypeEnum = {
    ChildCat: 'ChildCat'
} as const;

export type ChildCatAllOfPetTypeEnum = typeof ChildCatAllOfPetTypeEnum[keyof typeof ChildCatAllOfPetTypeEnum];

/**
 * Model for testing model with \"_class\" property
 * @export
 * @interface ClassModel
 */
export interface ClassModel {
    /**
     * 
     * @type {string}
     * @memberof ClassModel
     */
    '_class'?: string;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    'client'?: string;
}
/**
 * 
 * @export
 * @interface ComplexQuadrilateral
 */
export interface ComplexQuadrilateral {
    /**
     * 
     * @type {string}
     * @memberof ComplexQuadrilateral
     */
    'shapeType': string;
    /**
     * 
     * @type {string}
     * @memberof ComplexQuadrilateral
     */
    'quadrilateralType': string;
}
/**
 * 
 * @export
 * @interface DanishPig
 */
export interface DanishPig {
    /**
     * 
     * @type {string}
     * @memberof DanishPig
     */
    'className': string;
}
/**
 * 
 * @export
 * @interface DeprecatedObject
 */
export interface DeprecatedObject {
    /**
     * 
     * @type {string}
     * @memberof DeprecatedObject
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface Dog
 */
export interface Dog extends Animal {
    /**
     * 
     * @type {string}
     * @memberof Dog
     */
    'breed'?: string;
}
/**
 * 
 * @export
 * @interface DogAllOf
 */
export interface DogAllOf {
    /**
     * 
     * @type {string}
     * @memberof DogAllOf
     */
    'breed'?: string;
}
/**
 * 
 * @export
 * @interface Drawing
 */
export interface Drawing {
    [key: string]: Fruit | any;

    /**
     * 
     * @type {Shape}
     * @memberof Drawing
     */
    'mainShape'?: Shape;
    /**
     * 
     * @type {ShapeOrNull}
     * @memberof Drawing
     */
    'shapeOrNull'?: ShapeOrNull;
    /**
     * 
     * @type {NullableShape}
     * @memberof Drawing
     */
    'nullableShape'?: NullableShape | null;
    /**
     * 
     * @type {Array<Shape>}
     * @memberof Drawing
     */
    'shapes'?: Array<Shape>;
}
/**
 * 
 * @export
 * @interface EnumArrays
 */
export interface EnumArrays {
    /**
     * 
     * @type {string}
     * @memberof EnumArrays
     */
    'just_symbol'?: EnumArraysJustSymbolEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnumArrays
     */
    'array_enum'?: Array<EnumArraysArrayEnumEnum>;
}

export const EnumArraysJustSymbolEnum = {
    GreaterThanOrEqualTo: '>=',
    Dollar: '$'
} as const;

export type EnumArraysJustSymbolEnum = typeof EnumArraysJustSymbolEnum[keyof typeof EnumArraysJustSymbolEnum];
export const EnumArraysArrayEnumEnum = {
    Fish: 'fish',
    Crab: 'crab'
} as const;

export type EnumArraysArrayEnumEnum = typeof EnumArraysArrayEnumEnum[keyof typeof EnumArraysArrayEnumEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const EnumClass = {
    Abc: '_abc',
    Efg: '-efg',
    Xyz: '(xyz)'
} as const;

export type EnumClass = typeof EnumClass[keyof typeof EnumClass];


/**
 * 
 * @export
 * @interface EnumTest
 */
export interface EnumTest {
    /**
     * 
     * @type {string}
     * @memberof EnumTest
     */
    'enum_string'?: EnumTestEnumStringEnum;
    /**
     * 
     * @type {string}
     * @memberof EnumTest
     */
    'enum_string_required': EnumTestEnumStringRequiredEnum;
    /**
     * 
     * @type {number}
     * @memberof EnumTest
     */
    'enum_integer'?: EnumTestEnumIntegerEnum;
    /**
     * 
     * @type {number}
     * @memberof EnumTest
     */
    'enum_integer_only'?: EnumTestEnumIntegerOnlyEnum;
    /**
     * 
     * @type {number}
     * @memberof EnumTest
     */
    'enum_number'?: EnumTestEnumNumberEnum;
    /**
     * 
     * @type {OuterEnum}
     * @memberof EnumTest
     */
    'outerEnum'?: OuterEnum | null;
    /**
     * 
     * @type {OuterEnumInteger}
     * @memberof EnumTest
     */
    'outerEnumInteger'?: OuterEnumInteger;
    /**
     * 
     * @type {OuterEnumDefaultValue}
     * @memberof EnumTest
     */
    'outerEnumDefaultValue'?: OuterEnumDefaultValue;
    /**
     * 
     * @type {OuterEnumIntegerDefaultValue}
     * @memberof EnumTest
     */
    'outerEnumIntegerDefaultValue'?: OuterEnumIntegerDefaultValue;
}

export const EnumTestEnumStringEnum = {
    Upper: 'UPPER',
    Lower: 'lower',
    Empty: ''
} as const;

export type EnumTestEnumStringEnum = typeof EnumTestEnumStringEnum[keyof typeof EnumTestEnumStringEnum];
export const EnumTestEnumStringRequiredEnum = {
    Upper: 'UPPER',
    Lower: 'lower',
    Empty: ''
} as const;

export type EnumTestEnumStringRequiredEnum = typeof EnumTestEnumStringRequiredEnum[keyof typeof EnumTestEnumStringRequiredEnum];
export const EnumTestEnumIntegerEnum = {
    NUMBER_1: 1,
    NUMBER_MINUS_1: -1
} as const;

export type EnumTestEnumIntegerEnum = typeof EnumTestEnumIntegerEnum[keyof typeof EnumTestEnumIntegerEnum];
export const EnumTestEnumIntegerOnlyEnum = {
    NUMBER_2: 2,
    NUMBER_MINUS_2: -2
} as const;

export type EnumTestEnumIntegerOnlyEnum = typeof EnumTestEnumIntegerOnlyEnum[keyof typeof EnumTestEnumIntegerOnlyEnum];
export const EnumTestEnumNumberEnum = {
    NUMBER_1_DOT_1: 1.1,
    NUMBER_MINUS_1_DOT_2: -1.2
} as const;

export type EnumTestEnumNumberEnum = typeof EnumTestEnumNumberEnum[keyof typeof EnumTestEnumNumberEnum];

/**
 * 
 * @export
 * @interface EquilateralTriangle
 */
export interface EquilateralTriangle {
    /**
     * 
     * @type {string}
     * @memberof EquilateralTriangle
     */
    'shapeType': string;
    /**
     * 
     * @type {string}
     * @memberof EquilateralTriangle
     */
    'triangleType': string;
}
/**
 * 
 * @export
 * @interface FileSchemaTestClass
 */
export interface FileSchemaTestClass {
    /**
     * 
     * @type {any}
     * @memberof FileSchemaTestClass
     */
    'file'?: any;
    /**
     * 
     * @type {Array<any>}
     * @memberof FileSchemaTestClass
     */
    'files'?: Array<any>;
}
/**
 * 
 * @export
 * @interface Foo
 */
export interface Foo {
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    'bar'?: string;
}
/**
 * 
 * @export
 * @interface FormatTest
 */
export interface FormatTest {
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    'integer'?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    'int32'?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    'int64'?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    'number': number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    'float'?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    'double'?: number;
    /**
     * 
     * @type {Decimal}
     * @memberof FormatTest
     */
    'decimal'?: Decimal;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    'string'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    'byte': string;
    /**
     * 
     * @type {any}
     * @memberof FormatTest
     */
    'binary'?: any;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    'dateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    'password': string;
    /**
     * A string that is a 10 digit number. Can have leading zeros.
     * @type {string}
     * @memberof FormatTest
     */
    'pattern_with_digits'?: string;
    /**
     * A string starting with \'image_\' (case insensitive) and one to three digits following i.e. Image_01.
     * @type {string}
     * @memberof FormatTest
     */
    'pattern_with_digits_and_delimiter'?: string;
}
/**
 * @type Fruit
 * @export
 */
export type Fruit = Apple | Banana;

/**
 * @type FruitReq
 * @export
 */
export type FruitReq = AppleReq | BananaReq | Null;

/**
 * 
 * @export
 * @interface GmFruit
 */
export interface GmFruit {
    /**
     * 
     * @type {string}
     * @memberof GmFruit
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof GmFruit
     */
    'cultivar'?: string;
    /**
     * 
     * @type {string}
     * @memberof GmFruit
     */
    'origin'?: string;
    /**
     * 
     * @type {number}
     * @memberof GmFruit
     */
    'lengthCm'?: number;
}
/**
 * 
 * @export
 * @interface GrandparentAnimal
 */
export interface GrandparentAnimal {
    /**
     * 
     * @type {string}
     * @memberof GrandparentAnimal
     */
    'pet_type': string;
}
/**
 * 
 * @export
 * @interface HasOnlyReadOnly
 */
export interface HasOnlyReadOnly {
    /**
     * 
     * @type {string}
     * @memberof HasOnlyReadOnly
     */
    'bar'?: string;
    /**
     * 
     * @type {string}
     * @memberof HasOnlyReadOnly
     */
    'foo'?: string;
}
/**
 * Just a string to inform instance is up and running. Make it nullable in hope to get it as pointer in generated model.
 * @export
 * @interface HealthCheckResult
 */
export interface HealthCheckResult {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResult
     */
    'NullableMessage'?: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {Foo}
     * @memberof InlineResponseDefault
     */
    'string'?: Foo;
}
/**
 * 
 * @export
 * @interface IsoscelesTriangle
 */
export interface IsoscelesTriangle {
    /**
     * 
     * @type {string}
     * @memberof IsoscelesTriangle
     */
    'shapeType': string;
    /**
     * 
     * @type {string}
     * @memberof IsoscelesTriangle
     */
    'triangleType': string;
}
/**
 * 
 * @export
 * @interface List
 */
export interface List {
    /**
     * 
     * @type {string}
     * @memberof List
     */
    '123-list'?: string;
}
/**
 * @type Mammal
 * @export
 */
export type Mammal = Pig | Whale | Zebra;

/**
 * 
 * @export
 * @interface MapTest
 */
export interface MapTest {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof MapTest
     */
    'map_map_of_string'?: { [key: string]: { [key: string]: string; }; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MapTest
     */
    'map_of_enum_string'?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof MapTest
     */
    'direct_map'?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof MapTest
     */
    'indirect_map'?: { [key: string]: boolean; };
}

export const MapTestMapOfEnumStringEnum = {
    Upper: 'UPPER',
    Lower: 'lower'
} as const;

export type MapTestMapOfEnumStringEnum = typeof MapTestMapOfEnumStringEnum[keyof typeof MapTestMapOfEnumStringEnum];

/**
 * 
 * @export
 * @interface MixedPropertiesAndAdditionalPropertiesClass
 */
export interface MixedPropertiesAndAdditionalPropertiesClass {
    /**
     * 
     * @type {string}
     * @memberof MixedPropertiesAndAdditionalPropertiesClass
     */
    'uuid'?: string;
    /**
     * 
     * @type {string}
     * @memberof MixedPropertiesAndAdditionalPropertiesClass
     */
    'dateTime'?: string;
    /**
     * 
     * @type {{ [key: string]: Animal; }}
     * @memberof MixedPropertiesAndAdditionalPropertiesClass
     */
    'map'?: { [key: string]: Animal; };
}
/**
 * Model for testing model name starting with number
 * @export
 * @interface Model200Response
 */
export interface Model200Response {
    /**
     * 
     * @type {number}
     * @memberof Model200Response
     */
    'name'?: number;
    /**
     * 
     * @type {string}
     * @memberof Model200Response
     */
    'class'?: string;
}
/**
 * Must be named `File` for test.
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * Test capitalization
     * @type {string}
     * @memberof ModelFile
     */
    'sourceURI'?: string;
}
/**
 * Model for testing model name same as property name
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {number}
     * @memberof Name
     */
    'name': number;
    /**
     * 
     * @type {number}
     * @memberof Name
     */
    'snake_case'?: number;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    'property'?: string;
    /**
     * 
     * @type {number}
     * @memberof Name
     */
    '123Number'?: number;
}
/**
 * 
 * @export
 * @interface NullableClass
 */
export interface NullableClass {
    [key: string]: object | any;

    /**
     * 
     * @type {number}
     * @memberof NullableClass
     */
    'integer_prop'?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NullableClass
     */
    'number_prop'?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof NullableClass
     */
    'boolean_prop'?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof NullableClass
     */
    'string_prop'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NullableClass
     */
    'date_prop'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NullableClass
     */
    'datetime_prop'?: string | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof NullableClass
     */
    'array_nullable_prop'?: Array<object> | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof NullableClass
     */
    'array_and_items_nullable_prop'?: Array<object> | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof NullableClass
     */
    'array_items_nullable'?: Array<object>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NullableClass
     */
    'object_nullable_prop'?: { [key: string]: object; } | null;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NullableClass
     */
    'object_and_items_nullable_prop'?: { [key: string]: object; } | null;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NullableClass
     */
    'object_items_nullable'?: { [key: string]: object; };
}
/**
 * @type NullableShape
 * The value may be a shape or the \'null\' value. The \'nullable\' attribute was introduced in OAS schema >= 3.0 and has been deprecated in OAS schema >= 3.1.
 * @export
 */
export type NullableShape = Quadrilateral | Triangle;

/**
 * 
 * @export
 * @interface NumberOnly
 */
export interface NumberOnly {
    /**
     * 
     * @type {number}
     * @memberof NumberOnly
     */
    'JustNumber'?: number;
}
/**
 * 
 * @export
 * @interface ObjectWithDeprecatedFields
 */
export interface ObjectWithDeprecatedFields {
    /**
     * 
     * @type {string}
     * @memberof ObjectWithDeprecatedFields
     */
    'uuid'?: string;
    /**
     * 
     * @type {number}
     * @memberof ObjectWithDeprecatedFields
     * @deprecated
     */
    'id'?: number;
    /**
     * 
     * @type {DeprecatedObject}
     * @memberof ObjectWithDeprecatedFields
     * @deprecated
     */
    'deprecatedRef'?: DeprecatedObject;
    /**
     * 
     * @type {Array<string>}
     * @memberof ObjectWithDeprecatedFields
     * @deprecated
     */
    'bars'?: Array<string>;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'id'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'petId'?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    'quantity'?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    'shipDate'?: string;
    /**
     * Order Status
     * @type {string}
     * @memberof Order
     */
    'status'?: OrderStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    'complete'?: boolean;
}

export const OrderStatusEnum = {
    Placed: 'placed',
    Approved: 'approved',
    Delivered: 'delivered'
} as const;

export type OrderStatusEnum = typeof OrderStatusEnum[keyof typeof OrderStatusEnum];

/**
 * 
 * @export
 * @interface OuterComposite
 */
export interface OuterComposite {
    /**
     * 
     * @type {number}
     * @memberof OuterComposite
     */
    'my_number'?: number;
    /**
     * 
     * @type {string}
     * @memberof OuterComposite
     */
    'my_string'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OuterComposite
     */
    'my_boolean'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const OuterEnum = {
    Placed: 'placed',
    Approved: 'approved',
    Delivered: 'delivered'
} as const;

export type OuterEnum = typeof OuterEnum[keyof typeof OuterEnum];


/**
 * 
 * @export
 * @enum {string}
 */

export const OuterEnumDefaultValue = {
    Placed: 'placed',
    Approved: 'approved',
    Delivered: 'delivered'
} as const;

export type OuterEnumDefaultValue = typeof OuterEnumDefaultValue[keyof typeof OuterEnumDefaultValue];


/**
 * 
 * @export
 * @enum {string}
 */

export const OuterEnumInteger = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type OuterEnumInteger = typeof OuterEnumInteger[keyof typeof OuterEnumInteger];


/**
 * 
 * @export
 * @enum {string}
 */

export const OuterEnumIntegerDefaultValue = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
} as const;

export type OuterEnumIntegerDefaultValue = typeof OuterEnumIntegerDefaultValue[keyof typeof OuterEnumIntegerDefaultValue];


/**
 * 
 * @export
 * @interface ParentPet
 */
export interface ParentPet extends GrandparentAnimal {
}
/**
 * 
 * @export
 * @interface Pet
 */
export interface Pet {
    /**
     * 
     * @type {number}
     * @memberof Pet
     */
    'id'?: number;
    /**
     * 
     * @type {Category}
     * @memberof Pet
     */
    'category'?: Category;
    /**
     * 
     * @type {string}
     * @memberof Pet
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pet
     */
    'photoUrls': Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Pet
     */
    'tags'?: Array<Tag>;
    /**
     * pet status in the store
     * @type {string}
     * @memberof Pet
     */
    'status'?: PetStatusEnum;
}

export const PetStatusEnum = {
    Available: 'available',
    Pending: 'pending',
    Sold: 'sold'
} as const;

export type PetStatusEnum = typeof PetStatusEnum[keyof typeof PetStatusEnum];

/**
 * @type Pig
 * @export
 */
export type Pig = BasquePig | DanishPig;

/**
 * @type Quadrilateral
 * @export
 */
export type Quadrilateral = ComplexQuadrilateral | SimpleQuadrilateral;

/**
 * 
 * @export
 * @interface QuadrilateralInterface
 */
export interface QuadrilateralInterface {
    /**
     * 
     * @type {string}
     * @memberof QuadrilateralInterface
     */
    'quadrilateralType': string;
}
/**
 * 
 * @export
 * @interface ReadOnlyFirst
 */
export interface ReadOnlyFirst {
    /**
     * 
     * @type {string}
     * @memberof ReadOnlyFirst
     */
    'bar'?: string;
    /**
     * 
     * @type {string}
     * @memberof ReadOnlyFirst
     */
    'baz'?: string;
}
/**
 * Model for testing reserved words
 * @export
 * @interface Return
 */
export interface Return {
    /**
     * 
     * @type {number}
     * @memberof Return
     */
    'return'?: number;
}
/**
 * 
 * @export
 * @interface ScaleneTriangle
 */
export interface ScaleneTriangle {
    /**
     * 
     * @type {string}
     * @memberof ScaleneTriangle
     */
    'shapeType': string;
    /**
     * 
     * @type {string}
     * @memberof ScaleneTriangle
     */
    'triangleType': string;
}
/**
 * @type Shape
 * @export
 */
export type Shape = Quadrilateral | Triangle;

/**
 * 
 * @export
 * @interface ShapeInterface
 */
export interface ShapeInterface {
    /**
     * 
     * @type {string}
     * @memberof ShapeInterface
     */
    'shapeType': string;
}
/**
 * @type ShapeOrNull
 * The value may be a shape or the \'null\' value. This is introduced in OAS schema >= 3.1.
 * @export
 */
export type ShapeOrNull = Null | Quadrilateral | Triangle;

/**
 * 
 * @export
 * @interface SimpleQuadrilateral
 */
export interface SimpleQuadrilateral {
    /**
     * 
     * @type {string}
     * @memberof SimpleQuadrilateral
     */
    'shapeType': string;
    /**
     * 
     * @type {string}
     * @memberof SimpleQuadrilateral
     */
    'quadrilateralType': string;
}
/**
 * 
 * @export
 * @interface SpecialModelName
 */
export interface SpecialModelName {
    /**
     * 
     * @type {number}
     * @memberof SpecialModelName
     */
    '$special[property.name]'?: number;
    /**
     * 
     * @type {string}
     * @memberof SpecialModelName
     */
    '_special_model.name_'?: string;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * @type Triangle
 * @export
 */
export type Triangle = EquilateralTriangle | IsoscelesTriangle | ScaleneTriangle;

/**
 * 
 * @export
 * @interface TriangleInterface
 */
export interface TriangleInterface {
    /**
     * 
     * @type {string}
     * @memberof TriangleInterface
     */
    'triangleType': string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phone'?: string;
    /**
     * User Status
     * @type {number}
     * @memberof User
     */
    'userStatus'?: number;
    /**
     * test code generation for objects Value must be a map of strings to values. It cannot be the \'null\' value.
     * @type {object}
     * @memberof User
     */
    'objectWithNoDeclaredProps'?: object;
    /**
     * test code generation for nullable objects. Value must be a map of strings to values or the \'null\' value.
     * @type {object}
     * @memberof User
     */
    'objectWithNoDeclaredPropsNullable'?: object | null;
    /**
     * test code generation for any type Here the \'type\' attribute is not specified, which means the value can be anything, including the null value, string, number, boolean, array or object. See https://github.com/OAI/OpenAPI-Specification/issues/1389
     * @type {any}
     * @memberof User
     */
    'anyTypeProp'?: any;
    /**
     * test code generation for any type Here the \'type\' attribute is not specified, which means the value can be anything, including the null value, string, number, boolean, array or object. The \'nullable\' attribute does not change the allowed values.
     * @type {any}
     * @memberof User
     */
    'anyTypePropNullable'?: any | null;
}
/**
 * 
 * @export
 * @interface Whale
 */
export interface Whale {
    /**
     * 
     * @type {boolean}
     * @memberof Whale
     */
    'hasBaleen'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Whale
     */
    'hasTeeth'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Whale
     */
    'className': string;
}
/**
 * 
 * @export
 * @interface Zebra
 */
export interface Zebra {
    [key: string]: object | any;

    /**
     * 
     * @type {string}
     * @memberof Zebra
     */
    'type'?: ZebraTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Zebra
     */
    'className': string;
}

export const ZebraTypeEnum = {
    Plains: 'plains',
    Mountain: 'mountain',
    Grevys: 'grevys'
} as const;

export type ZebraTypeEnum = typeof ZebraTypeEnum[keyof typeof ZebraTypeEnum];


/**
 * AnotherFakeApi - axios parameter creator
 * @export
 */
export const AnotherFakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To test special tags and operation ID starting with number
         * @summary To test special tags
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _123testSpecialTags: async (client: Client, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('_123testSpecialTags', 'client', client)
            const localVarPath = `/another-fake/dummy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnotherFakeApi - functional programming interface
 * @export
 */
export const AnotherFakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnotherFakeApiAxiosParamCreator(configuration)
    return {
        /**
         * To test special tags and operation ID starting with number
         * @summary To test special tags
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _123testSpecialTags(client: Client, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._123testSpecialTags(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnotherFakeApi - factory interface
 * @export
 */
export const AnotherFakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnotherFakeApiFp(configuration)
    return {
        /**
         * To test special tags and operation ID starting with number
         * @summary To test special tags
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _123testSpecialTags(client: Client, options?: any): AxiosPromise<Client> {
            return localVarFp._123testSpecialTags(client, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnotherFakeApi - object-oriented interface
 * @export
 * @class AnotherFakeApi
 * @extends {BaseAPI}
 */
export class AnotherFakeApi extends BaseAPI {
    /**
     * To test special tags and operation ID starting with number
     * @summary To test special tags
     * @param {Client} client client model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnotherFakeApi
     */
    public _123testSpecialTags(client: Client, options?: AxiosRequestConfig) {
        return AnotherFakeApiFp(this.configuration)._123testSpecialTags(client, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/foo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fooGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponseDefault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fooGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooGet(options?: any): AxiosPromise<InlineResponseDefault> {
            return localVarFp.fooGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fooGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).fooGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FakeApi - axios parameter creator
 * @export
 */
export const FakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeHealthGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of outer boolean types
         * @param {boolean} [body] Input boolean as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterBooleanSerialize: async (body?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/boolean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of object with outer number type
         * @param {OuterComposite} [outerComposite] Input composite as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterCompositeSerialize: async (outerComposite?: OuterComposite, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/composite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outerComposite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of outer number types
         * @param {number} [body] Input number as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterNumberSerialize: async (body?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/number`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of outer string types
         * @param {string} [body] Input string as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterStringSerialize: async (body?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Array of Enums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayOfEnums: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/array-of-enums`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For this test, the body for this request much reference a schema named `File`.
         * @param {FileSchemaTestClass} fileSchemaTestClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithFileSchema: async (fileSchemaTestClass: FileSchemaTestClass, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileSchemaTestClass' is not null or undefined
            assertParamExists('testBodyWithFileSchema', 'fileSchemaTestClass', fileSchemaTestClass)
            const localVarPath = `/fake/body-with-file-schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileSchemaTestClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} query 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithQueryParams: async (query: string, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('testBodyWithQueryParams', 'query', query)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('testBodyWithQueryParams', 'user', user)
            const localVarPath = `/fake/body-with-query-params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To test \"client\" model
         * @summary To test \"client\" model
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClientModel: async (client: Client, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('testClientModel', 'client', client)
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fake endpoint for testing various parameters      
         * @summary Fake endpoint for testing various parameters      
         * @param {number} number None
         * @param {number} _double None
         * @param {string} patternWithoutDelimiter None
         * @param {string} _byte None
         * @param {number} [integer] None
         * @param {number} [int32] None
         * @param {number} [int64] None
         * @param {number} [_float] None
         * @param {string} [string] None
         * @param {any} [binary] None
         * @param {string} [date] None
         * @param {string} [dateTime] None
         * @param {string} [password] None
         * @param {string} [callback] None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEndpointParameters: async (number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('testEndpointParameters', 'number', number)
            // verify required parameter '_double' is not null or undefined
            assertParamExists('testEndpointParameters', '_double', _double)
            // verify required parameter 'patternWithoutDelimiter' is not null or undefined
            assertParamExists('testEndpointParameters', 'patternWithoutDelimiter', patternWithoutDelimiter)
            // verify required parameter '_byte' is not null or undefined
            assertParamExists('testEndpointParameters', '_byte', _byte)
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_basic_test required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (integer !== undefined) { 
                localVarFormParams.set('integer', integer as any);
            }
    
            if (int32 !== undefined) { 
                localVarFormParams.set('int32', int32 as any);
            }
    
            if (int64 !== undefined) { 
                localVarFormParams.set('int64', int64 as any);
            }
    
            if (number !== undefined) { 
                localVarFormParams.set('number', number as any);
            }
    
            if (_float !== undefined) { 
                localVarFormParams.set('float', _float as any);
            }
    
            if (_double !== undefined) { 
                localVarFormParams.set('double', _double as any);
            }
    
            if (string !== undefined) { 
                localVarFormParams.set('string', string as any);
            }
    
            if (patternWithoutDelimiter !== undefined) { 
                localVarFormParams.set('pattern_without_delimiter', patternWithoutDelimiter as any);
            }
    
            if (_byte !== undefined) { 
                localVarFormParams.set('byte', _byte as any);
            }
    
            if (binary !== undefined) { 
                localVarFormParams.set('binary', binary as any);
            }
    
            if (date !== undefined) { 
                localVarFormParams.set('date', date as any);
            }
    
            if (dateTime !== undefined) { 
                localVarFormParams.set('dateTime', dateTime as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (callback !== undefined) { 
                localVarFormParams.set('callback', callback as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To test enum parameters
         * @summary To test enum parameters
         * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
         * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
         * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
         * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
         * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
         * @param {string} [enumFormString] Form parameter enum test (string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEnumParameters: async (enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (enumQueryStringArray) {
                localVarQueryParameter['enum_query_string_array'] = enumQueryStringArray;
            }

            if (enumQueryString !== undefined) {
                localVarQueryParameter['enum_query_string'] = enumQueryString;
            }

            if (enumQueryInteger !== undefined) {
                localVarQueryParameter['enum_query_integer'] = enumQueryInteger;
            }

            if (enumQueryDouble !== undefined) {
                localVarQueryParameter['enum_query_double'] = enumQueryDouble;
            }

            if (enumHeaderStringArray) {
                let mapped = enumHeaderStringArray.map(value => (<any>"Array<'>' | '$'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['enum_header_string_array'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }

            if (enumHeaderString !== undefined && enumHeaderString !== null) {
                localVarHeaderParameter['enum_header_string'] = String(enumHeaderString);
            }

            if (enumFormStringArray) {
                localVarFormParams.set('enum_form_string_array', enumFormStringArray.join(COLLECTION_FORMATS.csv));
            }

    
            if (enumFormString !== undefined) { 
                localVarFormParams.set('enum_form_string', enumFormString as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fake endpoint to test group parameters (optional)
         * @summary Fake endpoint to test group parameters (optional)
         * @param {number} requiredStringGroup Required String in group parameters
         * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
         * @param {number} requiredInt64Group Required Integer in group parameters
         * @param {number} [stringGroup] String in group parameters
         * @param {boolean} [booleanGroup] Boolean in group parameters
         * @param {number} [int64Group] Integer in group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testGroupParameters: async (requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requiredStringGroup' is not null or undefined
            assertParamExists('testGroupParameters', 'requiredStringGroup', requiredStringGroup)
            // verify required parameter 'requiredBooleanGroup' is not null or undefined
            assertParamExists('testGroupParameters', 'requiredBooleanGroup', requiredBooleanGroup)
            // verify required parameter 'requiredInt64Group' is not null or undefined
            assertParamExists('testGroupParameters', 'requiredInt64Group', requiredInt64Group)
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer_test required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requiredStringGroup !== undefined) {
                localVarQueryParameter['required_string_group'] = requiredStringGroup;
            }

            if (requiredInt64Group !== undefined) {
                localVarQueryParameter['required_int64_group'] = requiredInt64Group;
            }

            if (stringGroup !== undefined) {
                localVarQueryParameter['string_group'] = stringGroup;
            }

            if (int64Group !== undefined) {
                localVarQueryParameter['int64_group'] = int64Group;
            }

            if (requiredBooleanGroup !== undefined && requiredBooleanGroup !== null) {
                localVarHeaderParameter['required_boolean_group'] = String(JSON.stringify(requiredBooleanGroup));
            }

            if (booleanGroup !== undefined && booleanGroup !== null) {
                localVarHeaderParameter['boolean_group'] = String(JSON.stringify(booleanGroup));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test inline additionalProperties
         * @param {{ [key: string]: string; }} requestBody request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testInlineAdditionalProperties: async (requestBody: { [key: string]: string; }, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('testInlineAdditionalProperties', 'requestBody', requestBody)
            const localVarPath = `/fake/inline-additionalProperties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test json serialization of form data
         * @param {string} param field1
         * @param {string} param2 field2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testJsonFormData: async (param: string, param2: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'param' is not null or undefined
            assertParamExists('testJsonFormData', 'param', param)
            // verify required parameter 'param2' is not null or undefined
            assertParamExists('testJsonFormData', 'param2', param2)
            const localVarPath = `/fake/jsonFormData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (param !== undefined) { 
                localVarFormParams.set('param', param as any);
            }
    
            if (param2 !== undefined) { 
                localVarFormParams.set('param2', param2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To test the collection format in query parameters
         * @param {Array<string>} pipe 
         * @param {Array<string>} ioutil 
         * @param {Array<string>} http 
         * @param {Array<string>} url 
         * @param {Array<string>} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testQueryParameterCollectionFormat: async (pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipe' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'pipe', pipe)
            // verify required parameter 'ioutil' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'ioutil', ioutil)
            // verify required parameter 'http' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'http', http)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'url', url)
            // verify required parameter 'context' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'context', context)
            const localVarPath = `/fake/test-query-parameters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pipe) {
                localVarQueryParameter['pipe'] = pipe;
            }

            if (ioutil) {
                localVarQueryParameter['ioutil'] = ioutil.join(COLLECTION_FORMATS.csv);
            }

            if (http) {
                localVarQueryParameter['http'] = http.join(COLLECTION_FORMATS.ssv);
            }

            if (url) {
                localVarQueryParameter['url'] = url.join(COLLECTION_FORMATS.csv);
            }

            if (context) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeApi - functional programming interface
 * @export
 */
export const FakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeHealthGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeHealthGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of outer boolean types
         * @param {boolean} [body] Input boolean as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterBooleanSerialize(body?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterBooleanSerialize(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of object with outer number type
         * @param {OuterComposite} [outerComposite] Input composite as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterCompositeSerialize(outerComposite?: OuterComposite, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OuterComposite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterCompositeSerialize(outerComposite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of outer number types
         * @param {number} [body] Input number as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterNumberSerialize(body?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterNumberSerialize(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of outer string types
         * @param {string} [body] Input string as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterStringSerialize(body?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterStringSerialize(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Array of Enums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArrayOfEnums(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OuterEnum>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArrayOfEnums(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For this test, the body for this request much reference a schema named `File`.
         * @param {FileSchemaTestClass} fileSchemaTestClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testBodyWithFileSchema(fileSchemaTestClass: FileSchemaTestClass, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testBodyWithFileSchema(fileSchemaTestClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} query 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testBodyWithQueryParams(query: string, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testBodyWithQueryParams(query, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To test \"client\" model
         * @summary To test \"client\" model
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testClientModel(client: Client, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testClientModel(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fake endpoint for testing various parameters      
         * @summary Fake endpoint for testing various parameters      
         * @param {number} number None
         * @param {number} _double None
         * @param {string} patternWithoutDelimiter None
         * @param {string} _byte None
         * @param {number} [integer] None
         * @param {number} [int32] None
         * @param {number} [int64] None
         * @param {number} [_float] None
         * @param {string} [string] None
         * @param {any} [binary] None
         * @param {string} [date] None
         * @param {string} [dateTime] None
         * @param {string} [password] None
         * @param {string} [callback] None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testEndpointParameters(number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testEndpointParameters(number, _double, patternWithoutDelimiter, _byte, integer, int32, int64, _float, string, binary, date, dateTime, password, callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To test enum parameters
         * @summary To test enum parameters
         * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
         * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
         * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
         * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
         * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
         * @param {string} [enumFormString] Form parameter enum test (string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testEnumParameters(enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testEnumParameters(enumHeaderStringArray, enumHeaderString, enumQueryStringArray, enumQueryString, enumQueryInteger, enumQueryDouble, enumFormStringArray, enumFormString, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fake endpoint to test group parameters (optional)
         * @summary Fake endpoint to test group parameters (optional)
         * @param {number} requiredStringGroup Required String in group parameters
         * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
         * @param {number} requiredInt64Group Required Integer in group parameters
         * @param {number} [stringGroup] String in group parameters
         * @param {boolean} [booleanGroup] Boolean in group parameters
         * @param {number} [int64Group] Integer in group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testGroupParameters(requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testGroupParameters(requiredStringGroup, requiredBooleanGroup, requiredInt64Group, stringGroup, booleanGroup, int64Group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary test inline additionalProperties
         * @param {{ [key: string]: string; }} requestBody request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testInlineAdditionalProperties(requestBody: { [key: string]: string; }, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testInlineAdditionalProperties(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary test json serialization of form data
         * @param {string} param field1
         * @param {string} param2 field2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testJsonFormData(param: string, param2: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testJsonFormData(param, param2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To test the collection format in query parameters
         * @param {Array<string>} pipe 
         * @param {Array<string>} ioutil 
         * @param {Array<string>} http 
         * @param {Array<string>} url 
         * @param {Array<string>} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testQueryParameterCollectionFormat(pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testQueryParameterCollectionFormat(pipe, ioutil, http, url, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FakeApi - factory interface
 * @export
 */
export const FakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeHealthGet(options?: any): AxiosPromise<HealthCheckResult> {
            return localVarFp.fakeHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of outer boolean types
         * @param {boolean} [body] Input boolean as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterBooleanSerialize(body?: boolean, options?: any): AxiosPromise<boolean> {
            return localVarFp.fakeOuterBooleanSerialize(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of object with outer number type
         * @param {OuterComposite} [outerComposite] Input composite as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterCompositeSerialize(outerComposite?: OuterComposite, options?: any): AxiosPromise<OuterComposite> {
            return localVarFp.fakeOuterCompositeSerialize(outerComposite, options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of outer number types
         * @param {number} [body] Input number as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterNumberSerialize(body?: number, options?: any): AxiosPromise<number> {
            return localVarFp.fakeOuterNumberSerialize(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of outer string types
         * @param {string} [body] Input string as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterStringSerialize(body?: string, options?: any): AxiosPromise<string> {
            return localVarFp.fakeOuterStringSerialize(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Array of Enums
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArrayOfEnums(options?: any): AxiosPromise<Array<OuterEnum>> {
            return localVarFp.getArrayOfEnums(options).then((request) => request(axios, basePath));
        },
        /**
         * For this test, the body for this request much reference a schema named `File`.
         * @param {FileSchemaTestClass} fileSchemaTestClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithFileSchema(fileSchemaTestClass: FileSchemaTestClass, options?: any): AxiosPromise<void> {
            return localVarFp.testBodyWithFileSchema(fileSchemaTestClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} query 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithQueryParams(query: string, user: User, options?: any): AxiosPromise<void> {
            return localVarFp.testBodyWithQueryParams(query, user, options).then((request) => request(axios, basePath));
        },
        /**
         * To test \"client\" model
         * @summary To test \"client\" model
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClientModel(client: Client, options?: any): AxiosPromise<Client> {
            return localVarFp.testClientModel(client, options).then((request) => request(axios, basePath));
        },
        /**
         * Fake endpoint for testing various parameters      
         * @summary Fake endpoint for testing various parameters      
         * @param {number} number None
         * @param {number} _double None
         * @param {string} patternWithoutDelimiter None
         * @param {string} _byte None
         * @param {number} [integer] None
         * @param {number} [int32] None
         * @param {number} [int64] None
         * @param {number} [_float] None
         * @param {string} [string] None
         * @param {any} [binary] None
         * @param {string} [date] None
         * @param {string} [dateTime] None
         * @param {string} [password] None
         * @param {string} [callback] None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEndpointParameters(number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testEndpointParameters(number, _double, patternWithoutDelimiter, _byte, integer, int32, int64, _float, string, binary, date, dateTime, password, callback, options).then((request) => request(axios, basePath));
        },
        /**
         * To test enum parameters
         * @summary To test enum parameters
         * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
         * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
         * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
         * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
         * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
         * @param {string} [enumFormString] Form parameter enum test (string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEnumParameters(enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testEnumParameters(enumHeaderStringArray, enumHeaderString, enumQueryStringArray, enumQueryString, enumQueryInteger, enumQueryDouble, enumFormStringArray, enumFormString, options).then((request) => request(axios, basePath));
        },
        /**
         * Fake endpoint to test group parameters (optional)
         * @summary Fake endpoint to test group parameters (optional)
         * @param {number} requiredStringGroup Required String in group parameters
         * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
         * @param {number} requiredInt64Group Required Integer in group parameters
         * @param {number} [stringGroup] String in group parameters
         * @param {boolean} [booleanGroup] Boolean in group parameters
         * @param {number} [int64Group] Integer in group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testGroupParameters(requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options?: any): AxiosPromise<void> {
            return localVarFp.testGroupParameters(requiredStringGroup, requiredBooleanGroup, requiredInt64Group, stringGroup, booleanGroup, int64Group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test inline additionalProperties
         * @param {{ [key: string]: string; }} requestBody request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testInlineAdditionalProperties(requestBody: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return localVarFp.testInlineAdditionalProperties(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test json serialization of form data
         * @param {string} param field1
         * @param {string} param2 field2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testJsonFormData(param: string, param2: string, options?: any): AxiosPromise<void> {
            return localVarFp.testJsonFormData(param, param2, options).then((request) => request(axios, basePath));
        },
        /**
         * To test the collection format in query parameters
         * @param {Array<string>} pipe 
         * @param {Array<string>} ioutil 
         * @param {Array<string>} http 
         * @param {Array<string>} url 
         * @param {Array<string>} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testQueryParameterCollectionFormat(pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.testQueryParameterCollectionFormat(pipe, ioutil, http, url, context, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeApi - object-oriented interface
 * @export
 * @class FakeApi
 * @extends {BaseAPI}
 */
export class FakeApi extends BaseAPI {
    /**
     * 
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeHealthGet(options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).fakeHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of outer boolean types
     * @param {boolean} [body] Input boolean as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterBooleanSerialize(body?: boolean, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).fakeOuterBooleanSerialize(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of object with outer number type
     * @param {OuterComposite} [outerComposite] Input composite as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterCompositeSerialize(outerComposite?: OuterComposite, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).fakeOuterCompositeSerialize(outerComposite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of outer number types
     * @param {number} [body] Input number as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterNumberSerialize(body?: number, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).fakeOuterNumberSerialize(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of outer string types
     * @param {string} [body] Input string as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterStringSerialize(body?: string, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).fakeOuterStringSerialize(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Array of Enums
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public getArrayOfEnums(options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).getArrayOfEnums(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For this test, the body for this request much reference a schema named `File`.
     * @param {FileSchemaTestClass} fileSchemaTestClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testBodyWithFileSchema(fileSchemaTestClass: FileSchemaTestClass, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testBodyWithFileSchema(fileSchemaTestClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} query 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testBodyWithQueryParams(query: string, user: User, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testBodyWithQueryParams(query, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To test \"client\" model
     * @summary To test \"client\" model
     * @param {Client} client client model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testClientModel(client: Client, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testClientModel(client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fake endpoint for testing various parameters      
     * @summary Fake endpoint for testing various parameters      
     * @param {number} number None
     * @param {number} _double None
     * @param {string} patternWithoutDelimiter None
     * @param {string} _byte None
     * @param {number} [integer] None
     * @param {number} [int32] None
     * @param {number} [int64] None
     * @param {number} [_float] None
     * @param {string} [string] None
     * @param {any} [binary] None
     * @param {string} [date] None
     * @param {string} [dateTime] None
     * @param {string} [password] None
     * @param {string} [callback] None
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testEndpointParameters(number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testEndpointParameters(number, _double, patternWithoutDelimiter, _byte, integer, int32, int64, _float, string, binary, date, dateTime, password, callback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To test enum parameters
     * @summary To test enum parameters
     * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
     * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
     * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
     * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
     * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
     * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
     * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
     * @param {string} [enumFormString] Form parameter enum test (string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testEnumParameters(enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testEnumParameters(enumHeaderStringArray, enumHeaderString, enumQueryStringArray, enumQueryString, enumQueryInteger, enumQueryDouble, enumFormStringArray, enumFormString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fake endpoint to test group parameters (optional)
     * @summary Fake endpoint to test group parameters (optional)
     * @param {number} requiredStringGroup Required String in group parameters
     * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
     * @param {number} requiredInt64Group Required Integer in group parameters
     * @param {number} [stringGroup] String in group parameters
     * @param {boolean} [booleanGroup] Boolean in group parameters
     * @param {number} [int64Group] Integer in group parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testGroupParameters(requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testGroupParameters(requiredStringGroup, requiredBooleanGroup, requiredInt64Group, stringGroup, booleanGroup, int64Group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test inline additionalProperties
     * @param {{ [key: string]: string; }} requestBody request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testInlineAdditionalProperties(requestBody: { [key: string]: string; }, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testInlineAdditionalProperties(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test json serialization of form data
     * @param {string} param field1
     * @param {string} param2 field2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testJsonFormData(param: string, param2: string, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testJsonFormData(param, param2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To test the collection format in query parameters
     * @param {Array<string>} pipe 
     * @param {Array<string>} ioutil 
     * @param {Array<string>} http 
     * @param {Array<string>} url 
     * @param {Array<string>} context 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testQueryParameterCollectionFormat(pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options?: AxiosRequestConfig) {
        return FakeApiFp(this.configuration).testQueryParameterCollectionFormat(pipe, ioutil, http, url, context, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FakeClassnameTags123Api - axios parameter creator
 * @export
 */
export const FakeClassnameTags123ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To test class name in snake case
         * @summary To test class name in snake case
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClassname: async (client: Client, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('testClassname', 'client', client)
            const localVarPath = `/fake_classname_test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key_query", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeClassnameTags123Api - functional programming interface
 * @export
 */
export const FakeClassnameTags123ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeClassnameTags123ApiAxiosParamCreator(configuration)
    return {
        /**
         * To test class name in snake case
         * @summary To test class name in snake case
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testClassname(client: Client, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testClassname(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FakeClassnameTags123Api - factory interface
 * @export
 */
export const FakeClassnameTags123ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeClassnameTags123ApiFp(configuration)
    return {
        /**
         * To test class name in snake case
         * @summary To test class name in snake case
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClassname(client: Client, options?: any): AxiosPromise<Client> {
            return localVarFp.testClassname(client, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeClassnameTags123Api - object-oriented interface
 * @export
 * @class FakeClassnameTags123Api
 * @extends {BaseAPI}
 */
export class FakeClassnameTags123Api extends BaseAPI {
    /**
     * To test class name in snake case
     * @summary To test class name in snake case
     * @param {Client} client client model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeClassnameTags123Api
     */
    public testClassname(client: Client, options?: AxiosRequestConfig) {
        return FakeClassnameTags123ApiFp(this.configuration).testClassname(client, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PetApi - axios parameter creator
 * @export
 */
export const PetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPet: async (pet: Pet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pet' is not null or undefined
            assertParamExists('addPet', 'pet', pet)
            const localVarPath = `/pet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePet: async (petId: number, apiKey?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('deletePet', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPetsByStatus: async (status: Array<'available' | 'pending' | 'sold'>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('findPetsByStatus', 'status', status)
            const localVarPath = `/pet/findByStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPetsByTags: async (tags: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('findPetsByTags', 'tags', tags)
            const localVarPath = `/pet/findByTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetById: async (petId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('getPetById', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing pet
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePet: async (pet: Pet, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pet' is not null or undefined
            assertParamExists('updatePet', 'pet', pet)
            const localVarPath = `/pet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetWithForm: async (petId: number, name?: string, status?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('updatePetWithForm', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.set('status', status as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} petId ID of pet to update
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {any} [file] file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (petId: number, additionalMetadata?: string, file?: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('uploadFile', 'petId', petId)
            const localVarPath = `/pet/{petId}/uploadImage`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


            if (additionalMetadata !== undefined) { 
                localVarFormParams.append('additionalMetadata', additionalMetadata as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploads an image (required)
         * @param {number} petId ID of pet to update
         * @param {any} requiredFile file to upload
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileWithRequiredFile: async (petId: number, requiredFile: any, additionalMetadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('uploadFileWithRequiredFile', 'petId', petId)
            // verify required parameter 'requiredFile' is not null or undefined
            assertParamExists('uploadFileWithRequiredFile', 'requiredFile', requiredFile)
            const localVarPath = `/fake/{petId}/uploadImageWithRequiredFile`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


            if (additionalMetadata !== undefined) { 
                localVarFormParams.append('additionalMetadata', additionalMetadata as any);
            }
    
            if (requiredFile !== undefined) { 
                localVarFormParams.append('requiredFile', requiredFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PetApi - functional programming interface
 * @export
 */
export const PetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPet(pet: Pet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPet(pet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePet(petId: number, apiKey?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePet(petId, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPetsByStatus(status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findPetsByTags(tags: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPetsByTags(tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPetById(petId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPetById(petId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing pet
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePet(pet: Pet, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePet(pet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePetWithForm(petId: number, name?: string, status?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePetWithForm(petId, name, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} petId ID of pet to update
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {any} [file] file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(petId, additionalMetadata, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary uploads an image (required)
         * @param {number} petId ID of pet to update
         * @param {any} requiredFile file to upload
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileWithRequiredFile(petId: number, requiredFile: any, additionalMetadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PetApi - factory interface
 * @export
 */
export const PetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPet(pet: Pet, options?: any): AxiosPromise<void> {
            return localVarFp.addPet(pet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePet(petId: number, apiKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePet(petId, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any): AxiosPromise<Array<Pet>> {
            return localVarFp.findPetsByStatus(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPetsByTags(tags: Array<string>, options?: any): AxiosPromise<Array<Pet>> {
            return localVarFp.findPetsByTags(tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetById(petId: number, options?: any): AxiosPromise<Pet> {
            return localVarFp.getPetById(petId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing pet
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePet(pet: Pet, options?: any): AxiosPromise<void> {
            return localVarFp.updatePet(pet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetWithForm(petId: number, name?: string, status?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updatePetWithForm(petId, name, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} petId ID of pet to update
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {any} [file] file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.uploadFile(petId, additionalMetadata, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary uploads an image (required)
         * @param {number} petId ID of pet to update
         * @param {any} requiredFile file to upload
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileWithRequiredFile(petId: number, requiredFile: any, additionalMetadata?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PetApi - object-oriented interface
 * @export
 * @class PetApi
 * @extends {BaseAPI}
 */
export class PetApi extends BaseAPI {
    /**
     * 
     * @summary Add a new pet to the store
     * @param {Pet} pet Pet object that needs to be added to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public addPet(pet: Pet, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).addPet(pet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a pet
     * @param {number} petId Pet id to delete
     * @param {string} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public deletePet(petId: number, apiKey?: string, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).deletePet(petId, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).findPetsByStatus(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param {Array<string>} tags Tags to filter by
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public findPetsByTags(tags: Array<string>, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).findPetsByTags(tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param {number} petId ID of pet to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public getPetById(petId: number, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).getPetById(petId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing pet
     * @param {Pet} pet Pet object that needs to be added to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public updatePet(pet: Pet, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).updatePet(pet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param {number} petId ID of pet that needs to be updated
     * @param {string} [name] Updated name of the pet
     * @param {string} [status] Updated status of the pet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public updatePetWithForm(petId: number, name?: string, status?: string, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).updatePetWithForm(petId, name, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary uploads an image
     * @param {number} petId ID of pet to update
     * @param {string} [additionalMetadata] Additional data to pass to server
     * @param {any} [file] file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).uploadFile(petId, additionalMetadata, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary uploads an image (required)
     * @param {number} petId ID of pet to update
     * @param {any} requiredFile file to upload
     * @param {string} [additionalMetadata] Additional data to pass to server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public uploadFileWithRequiredFile(petId: number, requiredFile: any, additionalMetadata?: string, options?: AxiosRequestConfig) {
        return PetApiFp(this.configuration).uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param {string} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (orderId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('deleteOrder', 'orderId', orderId)
            const localVarPath = `/store/order/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/store/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of pet that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById: async (orderId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderById', 'orderId', orderId)
            const localVarPath = `/store/order/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param {Order} order order placed for purchasing the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder: async (order: Order, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('placeOrder', 'order', order)
            const localVarPath = `/store/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param {string} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(orderId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventory(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventory(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of pet that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderById(orderId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderById(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param {Order} order order placed for purchasing the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOrder(order: Order, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOrder(order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param {string} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory(options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getInventory(options).then((request) => request(axios, basePath));
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of pet that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(orderId: number, options?: any): AxiosPromise<Order> {
            return localVarFp.getOrderById(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param {Order} order order placed for purchasing the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(order: Order, options?: any): AxiosPromise<Order> {
            return localVarFp.placeOrder(order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param {string} orderId ID of the order that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public deleteOrder(orderId: string, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).deleteOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public getInventory(options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).getInventory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param {number} orderId ID of pet that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public getOrderById(orderId: number, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).getOrderById(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place an order for a pet
     * @param {Order} order order placed for purchasing the pet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public placeOrder(order: Order, options?: AxiosRequestConfig) {
        return StoreApiFp(this.configuration).placeOrder(order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param {User} user Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithArrayInput: async (user: Array<User>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUsersWithArrayInput', 'user', user)
            const localVarPath = `/user/createWithArray`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithListInput: async (user: Array<User>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUsersWithListInput', 'user', user)
            const localVarPath = `/user/createWithList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched. Use user1 for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByName: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByName', 'username', username)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (username: string, password: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginUser', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginUser', 'password', password)
            const localVarPath = `/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {string} username name that need to be deleted
         * @param {User} user Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (username: string, user: User, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUser', 'username', username)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param {User} user Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsersWithArrayInput(user: Array<User>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsersWithArrayInput(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsersWithListInput(user: Array<User>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsersWithListInput(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched. Use user1 for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByName(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByName(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(username: string, password: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(username, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {string} username name that need to be deleted
         * @param {User} user Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(username: string, user: User, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(username, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param {User} user Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any): AxiosPromise<void> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithArrayInput(user: Array<User>, options?: any): AxiosPromise<void> {
            return localVarFp.createUsersWithArrayInput(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithListInput(user: Array<User>, options?: any): AxiosPromise<void> {
            return localVarFp.createUsersWithListInput(user, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched. Use user1 for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByName(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserByName(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(username: string, password: string, options?: any): AxiosPromise<string> {
            return localVarFp.loginUser(username, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): AxiosPromise<void> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {string} username name that need to be deleted
         * @param {User} user Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, user: User, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param {User} user Created user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(user: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates list of users with given input array
     * @param {Array<User>} user List of user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUsersWithArrayInput(user: Array<User>, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUsersWithArrayInput(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates list of users with given input array
     * @param {Array<User>} user List of user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUsersWithListInput(user: Array<User>, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUsersWithListInput(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByName(username: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserByName(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs user into the system
     * @param {string} username The user name for login
     * @param {string} password The password for login in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginUser(username: string, password: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).loginUser(username, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logoutUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {string} username name that need to be deleted
     * @param {User} user Updated user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(username: string, user: User, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));
    }
}


