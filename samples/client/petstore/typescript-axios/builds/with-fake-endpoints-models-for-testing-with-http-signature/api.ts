/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI Petstore
 * This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AdditionalPropertiesClass
 */
export interface AdditionalPropertiesClass {
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof AdditionalPropertiesClass
     */
    map_property?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof AdditionalPropertiesClass
     */
    map_of_map_property?: { [key: string]: { [key: string]: string; }; };
}
/**
 * 
 * @export
 * @interface Animal
 */
export interface Animal {
    /**
     * 
     * @type {string}
     * @memberof Animal
     */
    className: string;
    /**
     * 
     * @type {string}
     * @memberof Animal
     */
    color?: string;
}
/**
 * 
 * @export
 * @interface ApiResponse
 */
export interface ApiResponse {
    /**
     * 
     * @type {number}
     * @memberof ApiResponse
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiResponse
     */
    message?: string;
}
/**
 * 
 * @export
 * @interface Apple
 */
export interface Apple {
    /**
     * 
     * @type {string}
     * @memberof Apple
     */
    cultivar?: string;
}
/**
 * 
 * @export
 * @interface AppleReq
 */
export interface AppleReq {
    /**
     * 
     * @type {string}
     * @memberof AppleReq
     */
    cultivar: string;
    /**
     * 
     * @type {boolean}
     * @memberof AppleReq
     */
    mealy?: boolean;
}
/**
 * 
 * @export
 * @interface ArrayOfArrayOfNumberOnly
 */
export interface ArrayOfArrayOfNumberOnly {
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof ArrayOfArrayOfNumberOnly
     */
    ArrayArrayNumber?: Array<Array<number>>;
}
/**
 * 
 * @export
 * @interface ArrayOfNumberOnly
 */
export interface ArrayOfNumberOnly {
    /**
     * 
     * @type {Array<number>}
     * @memberof ArrayOfNumberOnly
     */
    ArrayNumber?: Array<number>;
}
/**
 * 
 * @export
 * @interface ArrayTest
 */
export interface ArrayTest {
    /**
     * 
     * @type {Array<string>}
     * @memberof ArrayTest
     */
    array_of_string?: Array<string>;
    /**
     * 
     * @type {Array<Array<number>>}
     * @memberof ArrayTest
     */
    array_array_of_integer?: Array<Array<number>>;
    /**
     * 
     * @type {Array<Array<ReadOnlyFirst>>}
     * @memberof ArrayTest
     */
    array_array_of_model?: Array<Array<ReadOnlyFirst>>;
}
/**
 * 
 * @export
 * @interface Banana
 */
export interface Banana {
    [key: string]: object | any;

    /**
     * 
     * @type {number}
     * @memberof Banana
     */
    lengthCm?: number;
}
/**
 * 
 * @export
 * @interface BananaReq
 */
export interface BananaReq {
    /**
     * 
     * @type {number}
     * @memberof BananaReq
     */
    lengthCm: number;
    /**
     * 
     * @type {boolean}
     * @memberof BananaReq
     */
    sweet?: boolean;
}
/**
 * 
 * @export
 * @interface Capitalization
 */
export interface Capitalization {
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    smallCamel?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    CapitalCamel?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    small_Snake?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    Capital_Snake?: string;
    /**
     * 
     * @type {string}
     * @memberof Capitalization
     */
    SCA_ETH_Flow_Points?: string;
    /**
     * Name of the pet 
     * @type {string}
     * @memberof Capitalization
     */
    ATT_NAME?: string;
}
/**
 * 
 * @export
 * @interface Cat
 */
export interface Cat extends Animal {
    /**
     * 
     * @type {boolean}
     * @memberof Cat
     */
    declawed?: boolean;
}
/**
 * 
 * @export
 * @interface CatAllOf
 */
export interface CatAllOf {
    /**
     * 
     * @type {boolean}
     * @memberof CatAllOf
     */
    declawed?: boolean;
}
/**
 * 
 * @export
 * @interface Category
 */
export interface Category {
    /**
     * 
     * @type {number}
     * @memberof Category
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Category
     */
    name: string;
}
/**
 * Model for testing model with \"_class\" property
 * @export
 * @interface ClassModel
 */
export interface ClassModel {
    /**
     * 
     * @type {string}
     * @memberof ClassModel
     */
    _class?: string;
}
/**
 * 
 * @export
 * @interface Client
 */
export interface Client {
    /**
     * 
     * @type {string}
     * @memberof Client
     */
    client?: string;
}
/**
 * 
 * @export
 * @interface Dog
 */
export interface Dog extends Animal {
    /**
     * 
     * @type {string}
     * @memberof Dog
     */
    breed?: string;
}
/**
 * 
 * @export
 * @interface DogAllOf
 */
export interface DogAllOf {
    /**
     * 
     * @type {string}
     * @memberof DogAllOf
     */
    breed?: string;
}
/**
 * 
 * @export
 * @interface EnumArrays
 */
export interface EnumArrays {
    /**
     * 
     * @type {string}
     * @memberof EnumArrays
     */
    just_symbol?: EnumArraysJustSymbolEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof EnumArrays
     */
    array_enum?: Array<EnumArraysArrayEnumEnum>;
}

/**
    * @export
    * @enum {string}
    */
export enum EnumArraysJustSymbolEnum {
    GreaterThanOrEqualTo = '>=',
    Dollar = '$'
}
/**
    * @export
    * @enum {string}
    */
export enum EnumArraysArrayEnumEnum {
    Fish = 'fish',
    Crab = 'crab'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum EnumClass {
    Abc = '_abc',
    Efg = '-efg',
    Xyz = '(xyz)'
}

/**
 * 
 * @export
 * @interface EnumTest
 */
export interface EnumTest {
    /**
     * 
     * @type {string}
     * @memberof EnumTest
     */
    enum_string?: EnumTestEnumStringEnum;
    /**
     * 
     * @type {string}
     * @memberof EnumTest
     */
    enum_string_required: EnumTestEnumStringRequiredEnum;
    /**
     * 
     * @type {number}
     * @memberof EnumTest
     */
    enum_integer?: EnumTestEnumIntegerEnum;
    /**
     * 
     * @type {number}
     * @memberof EnumTest
     */
    enum_number?: EnumTestEnumNumberEnum;
    /**
     * 
     * @type {OuterEnum}
     * @memberof EnumTest
     */
    outerEnum?: OuterEnum | null;
    /**
     * 
     * @type {OuterEnumInteger}
     * @memberof EnumTest
     */
    outerEnumInteger?: OuterEnumInteger;
    /**
     * 
     * @type {OuterEnumDefaultValue}
     * @memberof EnumTest
     */
    outerEnumDefaultValue?: OuterEnumDefaultValue;
    /**
     * 
     * @type {OuterEnumIntegerDefaultValue}
     * @memberof EnumTest
     */
    outerEnumIntegerDefaultValue?: OuterEnumIntegerDefaultValue;
}

/**
    * @export
    * @enum {string}
    */
export enum EnumTestEnumStringEnum {
    Upper = 'UPPER',
    Lower = 'lower',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum EnumTestEnumStringRequiredEnum {
    Upper = 'UPPER',
    Lower = 'lower',
    Empty = ''
}
/**
    * @export
    * @enum {string}
    */
export enum EnumTestEnumIntegerEnum {
    NUMBER_1 = 1,
    NUMBER_MINUS_1 = -1
}
/**
    * @export
    * @enum {string}
    */
export enum EnumTestEnumNumberEnum {
    NUMBER_1_DOT_1 = 1.1,
    NUMBER_MINUS_1_DOT_2 = -1.2
}

/**
 * 
 * @export
 * @interface FileSchemaTestClass
 */
export interface FileSchemaTestClass {
    /**
     * 
     * @type {any}
     * @memberof FileSchemaTestClass
     */
    file?: any;
    /**
     * 
     * @type {Array<any>}
     * @memberof FileSchemaTestClass
     */
    files?: Array<any>;
}
/**
 * 
 * @export
 * @interface Foo
 */
export interface Foo {
    /**
     * 
     * @type {string}
     * @memberof Foo
     */
    bar?: string;
}
/**
 * 
 * @export
 * @interface FormatTest
 */
export interface FormatTest {
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    integer?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    int32?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    int64?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    number: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    _float?: number;
    /**
     * 
     * @type {number}
     * @memberof FormatTest
     */
    _double?: number;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    string?: string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    _byte: string;
    /**
     * 
     * @type {any}
     * @memberof FormatTest
     */
    binary?: any;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    date: string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    dateTime?: string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof FormatTest
     */
    password: string;
    /**
     * A string that is a 10 digit number. Can have leading zeros.
     * @type {string}
     * @memberof FormatTest
     */
    pattern_with_digits?: string;
    /**
     * A string starting with \'image_\' (case insensitive) and one to three digits following i.e. Image_01.
     * @type {string}
     * @memberof FormatTest
     */
    pattern_with_digits_and_delimiter?: string;
}
/**
 * @type Fruit
 * @export
 */
export type Fruit = Apple | Banana;

/**
 * @type FruitReq
 * @export
 */
export type FruitReq = AppleReq | BananaReq;

/**
 * 
 * @export
 * @interface GmFruit
 */
export interface GmFruit {
    /**
     * 
     * @type {string}
     * @memberof GmFruit
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof GmFruit
     */
    cultivar?: string;
    /**
     * 
     * @type {number}
     * @memberof GmFruit
     */
    lengthCm?: number;
}
/**
 * 
 * @export
 * @interface HasOnlyReadOnly
 */
export interface HasOnlyReadOnly {
    /**
     * 
     * @type {string}
     * @memberof HasOnlyReadOnly
     */
    bar?: string;
    /**
     * 
     * @type {string}
     * @memberof HasOnlyReadOnly
     */
    foo?: string;
}
/**
 * Just a string to inform instance is up and running. Make it nullable in hope to get it as pointer in generated model.
 * @export
 * @interface HealthCheckResult
 */
export interface HealthCheckResult {
    /**
     * 
     * @type {string}
     * @memberof HealthCheckResult
     */
    NullableMessage?: string | null;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {Foo}
     * @memberof InlineResponseDefault
     */
    string?: Foo;
}
/**
 * 
 * @export
 * @interface List
 */
export interface List {
    /**
     * 
     * @type {string}
     * @memberof List
     */
    _123_list?: string;
}
/**
 * @type Mammal
 * @export
 */
export type Mammal = Whale | Zebra;

/**
 * 
 * @export
 * @interface MapTest
 */
export interface MapTest {
    /**
     * 
     * @type {{ [key: string]: { [key: string]: string; }; }}
     * @memberof MapTest
     */
    map_map_of_string?: { [key: string]: { [key: string]: string; }; };
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MapTest
     */
    map_of_enum_string?: { [key: string]: string; };
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof MapTest
     */
    direct_map?: { [key: string]: boolean; };
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof MapTest
     */
    indirect_map?: { [key: string]: boolean; };
}

/**
    * @export
    * @enum {string}
    */
export enum MapTestMapOfEnumStringEnum {
    Upper = 'UPPER',
    Lower = 'lower'
}

/**
 * 
 * @export
 * @interface MixedPropertiesAndAdditionalPropertiesClass
 */
export interface MixedPropertiesAndAdditionalPropertiesClass {
    /**
     * 
     * @type {string}
     * @memberof MixedPropertiesAndAdditionalPropertiesClass
     */
    uuid?: string;
    /**
     * 
     * @type {string}
     * @memberof MixedPropertiesAndAdditionalPropertiesClass
     */
    dateTime?: string;
    /**
     * 
     * @type {{ [key: string]: Animal; }}
     * @memberof MixedPropertiesAndAdditionalPropertiesClass
     */
    map?: { [key: string]: Animal; };
}
/**
 * Model for testing model name starting with number
 * @export
 * @interface Model200Response
 */
export interface Model200Response {
    /**
     * 
     * @type {number}
     * @memberof Model200Response
     */
    name?: number;
    /**
     * 
     * @type {string}
     * @memberof Model200Response
     */
    _class?: string;
}
/**
 * Must be named `File` for test.
 * @export
 * @interface ModelFile
 */
export interface ModelFile {
    /**
     * Test capitalization
     * @type {string}
     * @memberof ModelFile
     */
    sourceURI?: string;
}
/**
 * Model for testing model name same as property name
 * @export
 * @interface Name
 */
export interface Name {
    /**
     * 
     * @type {number}
     * @memberof Name
     */
    name: number;
    /**
     * 
     * @type {number}
     * @memberof Name
     */
    snake_case?: number;
    /**
     * 
     * @type {string}
     * @memberof Name
     */
    property?: string;
    /**
     * 
     * @type {number}
     * @memberof Name
     */
    _123Number?: number;
}
/**
 * 
 * @export
 * @interface NullableClass
 */
export interface NullableClass {
    [key: string]: object | any;

    /**
     * 
     * @type {number}
     * @memberof NullableClass
     */
    integer_prop?: number | null;
    /**
     * 
     * @type {number}
     * @memberof NullableClass
     */
    number_prop?: number | null;
    /**
     * 
     * @type {boolean}
     * @memberof NullableClass
     */
    boolean_prop?: boolean | null;
    /**
     * 
     * @type {string}
     * @memberof NullableClass
     */
    string_prop?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NullableClass
     */
    date_prop?: string | null;
    /**
     * 
     * @type {string}
     * @memberof NullableClass
     */
    datetime_prop?: string | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof NullableClass
     */
    array_nullable_prop?: Array<object> | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof NullableClass
     */
    array_and_items_nullable_prop?: Array<object> | null;
    /**
     * 
     * @type {Array<object>}
     * @memberof NullableClass
     */
    array_items_nullable?: Array<object>;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NullableClass
     */
    object_nullable_prop?: { [key: string]: object; } | null;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NullableClass
     */
    object_and_items_nullable_prop?: { [key: string]: object; } | null;
    /**
     * 
     * @type {{ [key: string]: object; }}
     * @memberof NullableClass
     */
    object_items_nullable?: { [key: string]: object; };
}
/**
 * 
 * @export
 * @interface NumberOnly
 */
export interface NumberOnly {
    /**
     * 
     * @type {number}
     * @memberof NumberOnly
     */
    JustNumber?: number;
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    id?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    petId?: number;
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    quantity?: number;
    /**
     * 
     * @type {string}
     * @memberof Order
     */
    shipDate?: string;
    /**
     * Order Status
     * @type {string}
     * @memberof Order
     */
    status?: OrderStatusEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    complete?: boolean;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderStatusEnum {
    Placed = 'placed',
    Approved = 'approved',
    Delivered = 'delivered'
}

/**
 * 
 * @export
 * @interface OuterComposite
 */
export interface OuterComposite {
    /**
     * 
     * @type {number}
     * @memberof OuterComposite
     */
    my_number?: number;
    /**
     * 
     * @type {string}
     * @memberof OuterComposite
     */
    my_string?: string;
    /**
     * 
     * @type {boolean}
     * @memberof OuterComposite
     */
    my_boolean?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum OuterEnum {
    Placed = 'placed',
    Approved = 'approved',
    Delivered = 'delivered'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum OuterEnumDefaultValue {
    Placed = 'placed',
    Approved = 'approved',
    Delivered = 'delivered'
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum OuterEnumInteger {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2
}

/**
 * 
 * @export
 * @enum {string}
 */

export enum OuterEnumIntegerDefaultValue {
    NUMBER_0 = 0,
    NUMBER_1 = 1,
    NUMBER_2 = 2
}

/**
 * 
 * @export
 * @interface Pet
 */
export interface Pet {
    /**
     * 
     * @type {number}
     * @memberof Pet
     */
    id?: number;
    /**
     * 
     * @type {Category}
     * @memberof Pet
     */
    category?: Category;
    /**
     * 
     * @type {string}
     * @memberof Pet
     */
    name: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof Pet
     */
    photoUrls: Array<string>;
    /**
     * 
     * @type {Array<Tag>}
     * @memberof Pet
     */
    tags?: Array<Tag>;
    /**
     * pet status in the store
     * @type {string}
     * @memberof Pet
     */
    status?: PetStatusEnum;
}

/**
    * @export
    * @enum {string}
    */
export enum PetStatusEnum {
    Available = 'available',
    Pending = 'pending',
    Sold = 'sold'
}

/**
 * 
 * @export
 * @interface ReadOnlyFirst
 */
export interface ReadOnlyFirst {
    /**
     * 
     * @type {string}
     * @memberof ReadOnlyFirst
     */
    bar?: string;
    /**
     * 
     * @type {string}
     * @memberof ReadOnlyFirst
     */
    baz?: string;
}
/**
 * Model for testing reserved words
 * @export
 * @interface Return
 */
export interface Return {
    /**
     * 
     * @type {number}
     * @memberof Return
     */
    _return?: number;
}
/**
 * 
 * @export
 * @interface SpecialModelName
 */
export interface SpecialModelName {
    /**
     * 
     * @type {number}
     * @memberof SpecialModelName
     */
    $special_property_name?: number;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {number}
     * @memberof Tag
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    username?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    firstName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    lastName?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * User Status
     * @type {number}
     * @memberof User
     */
    userStatus?: number;
    /**
     * test code generation for objects Value must be a map of strings to values. It cannot be the \'null\' value.
     * @type {object}
     * @memberof User
     */
    arbitraryObject?: object;
    /**
     * test code generation for nullable objects. Value must be a map of strings to values or the \'null\' value.
     * @type {object}
     * @memberof User
     */
    arbitraryNullableObject?: object | null;
    /**
     * test code generation for any type Value can be any type - string, number, boolean, array or object.
     * @type {any}
     * @memberof User
     */
    arbitraryTypeValue?: any | null;
    /**
     * test code generation for any type Value can be any type - string, number, boolean, array, object or the \'null\' value.
     * @type {any}
     * @memberof User
     */
    arbitraryNullableTypeValue?: any | null;
}
/**
 * 
 * @export
 * @interface Whale
 */
export interface Whale {
    /**
     * 
     * @type {boolean}
     * @memberof Whale
     */
    hasBaleen?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Whale
     */
    hasTeeth?: boolean;
    /**
     * 
     * @type {string}
     * @memberof Whale
     */
    className: string;
}
/**
 * 
 * @export
 * @interface Zebra
 */
export interface Zebra {
    /**
     * 
     * @type {string}
     * @memberof Zebra
     */
    type?: ZebraTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof Zebra
     */
    className: string;
}

/**
    * @export
    * @enum {string}
    */
export enum ZebraTypeEnum {
    Plains = 'plains',
    Mountain = 'mountain',
    Grevys = 'grevys'
}


/**
 * AnotherFakeApi - axios parameter creator
 * @export
 */
export const AnotherFakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To test special tags and operation ID starting with number
         * @summary To test special tags
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _123testSpecialTags: async (client: Client, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('_123testSpecialTags', 'client', client)
            const localVarPath = `/another-fake/dummy`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AnotherFakeApi - functional programming interface
 * @export
 */
export const AnotherFakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AnotherFakeApiAxiosParamCreator(configuration)
    return {
        /**
         * To test special tags and operation ID starting with number
         * @summary To test special tags
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _123testSpecialTags(client: Client, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._123testSpecialTags(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AnotherFakeApi - factory interface
 * @export
 */
export const AnotherFakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AnotherFakeApiFp(configuration)
    return {
        /**
         * To test special tags and operation ID starting with number
         * @summary To test special tags
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _123testSpecialTags(client: Client, options?: any): AxiosPromise<Client> {
            return localVarFp._123testSpecialTags(client, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AnotherFakeApi - object-oriented interface
 * @export
 * @class AnotherFakeApi
 * @extends {BaseAPI}
 */
export class AnotherFakeApi extends BaseAPI {
    /**
     * To test special tags and operation ID starting with number
     * @summary To test special tags
     * @param {Client} client client model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AnotherFakeApi
     */
    public _123testSpecialTags(client: Client, options?: any) {
        return AnotherFakeApiFp(this.configuration)._123testSpecialTags(client, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/foo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fooGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponseDefault>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fooGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fooGet(options?: any): AxiosPromise<InlineResponseDefault> {
            return localVarFp.fooGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public fooGet(options?: any) {
        return DefaultApiFp(this.configuration).fooGet(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FakeApi - axios parameter creator
 * @export
 */
export const FakeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeHealthGet: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of outer boolean types
         * @param {boolean} [body] Input boolean as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterBooleanSerialize: async (body?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/boolean`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of object with outer number type
         * @param {OuterComposite} [outerComposite] Input composite as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterCompositeSerialize: async (outerComposite?: OuterComposite, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/composite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(outerComposite, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of outer number types
         * @param {number} [body] Input number as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterNumberSerialize: async (body?: number, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/number`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Test serialization of outer string types
         * @param {string} [body] Input string as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterStringSerialize: async (body?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake/outer/string`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For this test, the body for this request much reference a schema named `File`.
         * @param {FileSchemaTestClass} fileSchemaTestClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithFileSchema: async (fileSchemaTestClass: FileSchemaTestClass, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileSchemaTestClass' is not null or undefined
            assertParamExists('testBodyWithFileSchema', 'fileSchemaTestClass', fileSchemaTestClass)
            const localVarPath = `/fake/body-with-file-schema`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(fileSchemaTestClass, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} query 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithQueryParams: async (query: string, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'query' is not null or undefined
            assertParamExists('testBodyWithQueryParams', 'query', query)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('testBodyWithQueryParams', 'user', user)
            const localVarPath = `/fake/body-with-query-params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (query !== undefined) {
                localVarQueryParameter['query'] = query;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To test \"client\" model
         * @summary To test \"client\" model
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClientModel: async (client: Client, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('testClientModel', 'client', client)
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
         * @summary Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
         * @param {number} number None
         * @param {number} _double None
         * @param {string} patternWithoutDelimiter None
         * @param {string} _byte None
         * @param {number} [integer] None
         * @param {number} [int32] None
         * @param {number} [int64] None
         * @param {number} [_float] None
         * @param {string} [string] None
         * @param {any} [binary] None
         * @param {string} [date] None
         * @param {string} [dateTime] None
         * @param {string} [password] None
         * @param {string} [callback] None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEndpointParameters: async (number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'number' is not null or undefined
            assertParamExists('testEndpointParameters', 'number', number)
            // verify required parameter '_double' is not null or undefined
            assertParamExists('testEndpointParameters', '_double', _double)
            // verify required parameter 'patternWithoutDelimiter' is not null or undefined
            assertParamExists('testEndpointParameters', 'patternWithoutDelimiter', patternWithoutDelimiter)
            // verify required parameter '_byte' is not null or undefined
            assertParamExists('testEndpointParameters', '_byte', _byte)
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_basic_test required
            // http basic authentication required
            setBasicAuthToObject(localVarRequestOptions, configuration)


            if (integer !== undefined) { 
                localVarFormParams.set('integer', integer as any);
            }
    
            if (int32 !== undefined) { 
                localVarFormParams.set('int32', int32 as any);
            }
    
            if (int64 !== undefined) { 
                localVarFormParams.set('int64', int64 as any);
            }
    
            if (number !== undefined) { 
                localVarFormParams.set('number', number as any);
            }
    
            if (_float !== undefined) { 
                localVarFormParams.set('float', _float as any);
            }
    
            if (_double !== undefined) { 
                localVarFormParams.set('double', _double as any);
            }
    
            if (string !== undefined) { 
                localVarFormParams.set('string', string as any);
            }
    
            if (patternWithoutDelimiter !== undefined) { 
                localVarFormParams.set('pattern_without_delimiter', patternWithoutDelimiter as any);
            }
    
            if (_byte !== undefined) { 
                localVarFormParams.set('byte', _byte as any);
            }
    
            if (binary !== undefined) { 
                localVarFormParams.set('binary', binary as any);
            }
    
            if (date !== undefined) { 
                localVarFormParams.set('date', date as any);
            }
    
            if (dateTime !== undefined) { 
                localVarFormParams.set('dateTime', dateTime as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (callback !== undefined) { 
                localVarFormParams.set('callback', callback as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To test enum parameters
         * @summary To test enum parameters
         * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
         * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
         * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
         * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
         * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
         * @param {string} [enumFormString] Form parameter enum test (string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEnumParameters: async (enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (enumQueryStringArray) {
                localVarQueryParameter['enum_query_string_array'] = enumQueryStringArray;
            }

            if (enumQueryString !== undefined) {
                localVarQueryParameter['enum_query_string'] = enumQueryString;
            }

            if (enumQueryInteger !== undefined) {
                localVarQueryParameter['enum_query_integer'] = enumQueryInteger;
            }

            if (enumQueryDouble !== undefined) {
                localVarQueryParameter['enum_query_double'] = enumQueryDouble;
            }

            if (enumHeaderStringArray) {
                let mapped = enumHeaderStringArray.map(value => (<any>"Array<'>' | '$'>" !== "Array<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['enum_header_string_array'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }

            if (enumHeaderString !== undefined && enumHeaderString !== null) {
                localVarHeaderParameter['enum_header_string'] = String(enumHeaderString);
            }

            if (enumFormStringArray) {
                localVarFormParams.set('enum_form_string_array', enumFormStringArray.join(COLLECTION_FORMATS.csv));
            }

    
            if (enumFormString !== undefined) { 
                localVarFormParams.set('enum_form_string', enumFormString as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Fake endpoint to test group parameters (optional)
         * @summary Fake endpoint to test group parameters (optional)
         * @param {number} requiredStringGroup Required String in group parameters
         * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
         * @param {number} requiredInt64Group Required Integer in group parameters
         * @param {number} [stringGroup] String in group parameters
         * @param {boolean} [booleanGroup] Boolean in group parameters
         * @param {number} [int64Group] Integer in group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testGroupParameters: async (requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requiredStringGroup' is not null or undefined
            assertParamExists('testGroupParameters', 'requiredStringGroup', requiredStringGroup)
            // verify required parameter 'requiredBooleanGroup' is not null or undefined
            assertParamExists('testGroupParameters', 'requiredBooleanGroup', requiredBooleanGroup)
            // verify required parameter 'requiredInt64Group' is not null or undefined
            assertParamExists('testGroupParameters', 'requiredInt64Group', requiredInt64Group)
            const localVarPath = `/fake`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearer_test required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (requiredStringGroup !== undefined) {
                localVarQueryParameter['required_string_group'] = requiredStringGroup;
            }

            if (requiredInt64Group !== undefined) {
                localVarQueryParameter['required_int64_group'] = requiredInt64Group;
            }

            if (stringGroup !== undefined) {
                localVarQueryParameter['string_group'] = stringGroup;
            }

            if (int64Group !== undefined) {
                localVarQueryParameter['int64_group'] = int64Group;
            }

            if (requiredBooleanGroup !== undefined && requiredBooleanGroup !== null) {
                localVarHeaderParameter['required_boolean_group'] = String(JSON.stringify(requiredBooleanGroup));
            }

            if (booleanGroup !== undefined && booleanGroup !== null) {
                localVarHeaderParameter['boolean_group'] = String(JSON.stringify(booleanGroup));
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test inline additionalProperties
         * @param {{ [key: string]: string; }} requestBody request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testInlineAdditionalProperties: async (requestBody: { [key: string]: string; }, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestBody' is not null or undefined
            assertParamExists('testInlineAdditionalProperties', 'requestBody', requestBody)
            const localVarPath = `/fake/inline-additionalProperties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(requestBody, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary test json serialization of form data
         * @param {string} param field1
         * @param {string} param2 field2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testJsonFormData: async (param: string, param2: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'param' is not null or undefined
            assertParamExists('testJsonFormData', 'param', param)
            // verify required parameter 'param2' is not null or undefined
            assertParamExists('testJsonFormData', 'param2', param2)
            const localVarPath = `/fake/jsonFormData`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (param !== undefined) { 
                localVarFormParams.set('param', param as any);
            }
    
            if (param2 !== undefined) { 
                localVarFormParams.set('param2', param2 as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To test the collection format in query parameters
         * @param {Array<string>} pipe 
         * @param {Array<string>} ioutil 
         * @param {Array<string>} http 
         * @param {Array<string>} url 
         * @param {Array<string>} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testQueryParameterCollectionFormat: async (pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pipe' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'pipe', pipe)
            // verify required parameter 'ioutil' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'ioutil', ioutil)
            // verify required parameter 'http' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'http', http)
            // verify required parameter 'url' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'url', url)
            // verify required parameter 'context' is not null or undefined
            assertParamExists('testQueryParameterCollectionFormat', 'context', context)
            const localVarPath = `/fake/test-query-paramters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (pipe) {
                localVarQueryParameter['pipe'] = pipe;
            }

            if (ioutil) {
                localVarQueryParameter['ioutil'] = ioutil.join(COLLECTION_FORMATS.csv);
            }

            if (http) {
                localVarQueryParameter['http'] = http.join(COLLECTION_FORMATS.ssv);
            }

            if (url) {
                localVarQueryParameter['url'] = url.join(COLLECTION_FORMATS.csv);
            }

            if (context) {
                localVarQueryParameter['context'] = context;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * To test unique items in header and query parameters
         * @param {Set<string>} queryUnique 
         * @param {Set<string>} headerUnique 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUniqueItemsHeaderAndQueryParameterCollectionFormat: async (queryUnique: Set<string>, headerUnique: Set<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'queryUnique' is not null or undefined
            assertParamExists('testUniqueItemsHeaderAndQueryParameterCollectionFormat', 'queryUnique', queryUnique)
            // verify required parameter 'headerUnique' is not null or undefined
            assertParamExists('testUniqueItemsHeaderAndQueryParameterCollectionFormat', 'headerUnique', headerUnique)
            const localVarPath = `/fake/test-unique-paramters`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (queryUnique) {
                localVarQueryParameter['queryUnique'] = Array.from(queryUnique);
            }

            if (headerUnique) {
                let mapped = Array.from(headerUnique).map(value => (<any>"Set<string>" !== "Set<string>") ? JSON.stringify(value) : (value || ""));
                localVarHeaderParameter['headerUnique'] = mapped.join(COLLECTION_FORMATS["csv"]);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeApi - functional programming interface
 * @export
 */
export const FakeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeHealthGet(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<HealthCheckResult>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeHealthGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of outer boolean types
         * @param {boolean} [body] Input boolean as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterBooleanSerialize(body?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterBooleanSerialize(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of object with outer number type
         * @param {OuterComposite} [outerComposite] Input composite as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterCompositeSerialize(outerComposite?: OuterComposite, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OuterComposite>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterCompositeSerialize(outerComposite, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of outer number types
         * @param {number} [body] Input number as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterNumberSerialize(body?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterNumberSerialize(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Test serialization of outer string types
         * @param {string} [body] Input string as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fakeOuterStringSerialize(body?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fakeOuterStringSerialize(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For this test, the body for this request much reference a schema named `File`.
         * @param {FileSchemaTestClass} fileSchemaTestClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testBodyWithFileSchema(fileSchemaTestClass: FileSchemaTestClass, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testBodyWithFileSchema(fileSchemaTestClass, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} query 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testBodyWithQueryParams(query: string, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testBodyWithQueryParams(query, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To test \"client\" model
         * @summary To test \"client\" model
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testClientModel(client: Client, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testClientModel(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
         * @summary Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
         * @param {number} number None
         * @param {number} _double None
         * @param {string} patternWithoutDelimiter None
         * @param {string} _byte None
         * @param {number} [integer] None
         * @param {number} [int32] None
         * @param {number} [int64] None
         * @param {number} [_float] None
         * @param {string} [string] None
         * @param {any} [binary] None
         * @param {string} [date] None
         * @param {string} [dateTime] None
         * @param {string} [password] None
         * @param {string} [callback] None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testEndpointParameters(number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testEndpointParameters(number, _double, patternWithoutDelimiter, _byte, integer, int32, int64, _float, string, binary, date, dateTime, password, callback, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To test enum parameters
         * @summary To test enum parameters
         * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
         * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
         * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
         * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
         * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
         * @param {string} [enumFormString] Form parameter enum test (string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testEnumParameters(enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testEnumParameters(enumHeaderStringArray, enumHeaderString, enumQueryStringArray, enumQueryString, enumQueryInteger, enumQueryDouble, enumFormStringArray, enumFormString, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Fake endpoint to test group parameters (optional)
         * @summary Fake endpoint to test group parameters (optional)
         * @param {number} requiredStringGroup Required String in group parameters
         * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
         * @param {number} requiredInt64Group Required Integer in group parameters
         * @param {number} [stringGroup] String in group parameters
         * @param {boolean} [booleanGroup] Boolean in group parameters
         * @param {number} [int64Group] Integer in group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testGroupParameters(requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testGroupParameters(requiredStringGroup, requiredBooleanGroup, requiredInt64Group, stringGroup, booleanGroup, int64Group, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary test inline additionalProperties
         * @param {{ [key: string]: string; }} requestBody request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testInlineAdditionalProperties(requestBody: { [key: string]: string; }, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testInlineAdditionalProperties(requestBody, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary test json serialization of form data
         * @param {string} param field1
         * @param {string} param2 field2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testJsonFormData(param: string, param2: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testJsonFormData(param, param2, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To test the collection format in query parameters
         * @param {Array<string>} pipe 
         * @param {Array<string>} ioutil 
         * @param {Array<string>} http 
         * @param {Array<string>} url 
         * @param {Array<string>} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testQueryParameterCollectionFormat(pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testQueryParameterCollectionFormat(pipe, ioutil, http, url, context, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * To test unique items in header and query parameters
         * @param {Set<string>} queryUnique 
         * @param {Set<string>} headerUnique 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testUniqueItemsHeaderAndQueryParameterCollectionFormat(queryUnique: Set<string>, headerUnique: Set<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<Pet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testUniqueItemsHeaderAndQueryParameterCollectionFormat(queryUnique, headerUnique, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FakeApi - factory interface
 * @export
 */
export const FakeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeApiFp(configuration)
    return {
        /**
         * 
         * @summary Health check endpoint
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeHealthGet(options?: any): AxiosPromise<HealthCheckResult> {
            return localVarFp.fakeHealthGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of outer boolean types
         * @param {boolean} [body] Input boolean as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterBooleanSerialize(body?: boolean, options?: any): AxiosPromise<boolean> {
            return localVarFp.fakeOuterBooleanSerialize(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of object with outer number type
         * @param {OuterComposite} [outerComposite] Input composite as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterCompositeSerialize(outerComposite?: OuterComposite, options?: any): AxiosPromise<OuterComposite> {
            return localVarFp.fakeOuterCompositeSerialize(outerComposite, options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of outer number types
         * @param {number} [body] Input number as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterNumberSerialize(body?: number, options?: any): AxiosPromise<number> {
            return localVarFp.fakeOuterNumberSerialize(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Test serialization of outer string types
         * @param {string} [body] Input string as post body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fakeOuterStringSerialize(body?: string, options?: any): AxiosPromise<string> {
            return localVarFp.fakeOuterStringSerialize(body, options).then((request) => request(axios, basePath));
        },
        /**
         * For this test, the body for this request much reference a schema named `File`.
         * @param {FileSchemaTestClass} fileSchemaTestClass 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithFileSchema(fileSchemaTestClass: FileSchemaTestClass, options?: any): AxiosPromise<void> {
            return localVarFp.testBodyWithFileSchema(fileSchemaTestClass, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} query 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testBodyWithQueryParams(query: string, user: User, options?: any): AxiosPromise<void> {
            return localVarFp.testBodyWithQueryParams(query, user, options).then((request) => request(axios, basePath));
        },
        /**
         * To test \"client\" model
         * @summary To test \"client\" model
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClientModel(client: Client, options?: any): AxiosPromise<Client> {
            return localVarFp.testClientModel(client, options).then((request) => request(axios, basePath));
        },
        /**
         * Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
         * @summary Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
         * @param {number} number None
         * @param {number} _double None
         * @param {string} patternWithoutDelimiter None
         * @param {string} _byte None
         * @param {number} [integer] None
         * @param {number} [int32] None
         * @param {number} [int64] None
         * @param {number} [_float] None
         * @param {string} [string] None
         * @param {any} [binary] None
         * @param {string} [date] None
         * @param {string} [dateTime] None
         * @param {string} [password] None
         * @param {string} [callback] None
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEndpointParameters(number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testEndpointParameters(number, _double, patternWithoutDelimiter, _byte, integer, int32, int64, _float, string, binary, date, dateTime, password, callback, options).then((request) => request(axios, basePath));
        },
        /**
         * To test enum parameters
         * @summary To test enum parameters
         * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
         * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
         * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
         * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
         * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
         * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
         * @param {string} [enumFormString] Form parameter enum test (string)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testEnumParameters(enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options?: any): AxiosPromise<void> {
            return localVarFp.testEnumParameters(enumHeaderStringArray, enumHeaderString, enumQueryStringArray, enumQueryString, enumQueryInteger, enumQueryDouble, enumFormStringArray, enumFormString, options).then((request) => request(axios, basePath));
        },
        /**
         * Fake endpoint to test group parameters (optional)
         * @summary Fake endpoint to test group parameters (optional)
         * @param {number} requiredStringGroup Required String in group parameters
         * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
         * @param {number} requiredInt64Group Required Integer in group parameters
         * @param {number} [stringGroup] String in group parameters
         * @param {boolean} [booleanGroup] Boolean in group parameters
         * @param {number} [int64Group] Integer in group parameters
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testGroupParameters(requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options?: any): AxiosPromise<void> {
            return localVarFp.testGroupParameters(requiredStringGroup, requiredBooleanGroup, requiredInt64Group, stringGroup, booleanGroup, int64Group, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test inline additionalProperties
         * @param {{ [key: string]: string; }} requestBody request body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testInlineAdditionalProperties(requestBody: { [key: string]: string; }, options?: any): AxiosPromise<void> {
            return localVarFp.testInlineAdditionalProperties(requestBody, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary test json serialization of form data
         * @param {string} param field1
         * @param {string} param2 field2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testJsonFormData(param: string, param2: string, options?: any): AxiosPromise<void> {
            return localVarFp.testJsonFormData(param, param2, options).then((request) => request(axios, basePath));
        },
        /**
         * To test the collection format in query parameters
         * @param {Array<string>} pipe 
         * @param {Array<string>} ioutil 
         * @param {Array<string>} http 
         * @param {Array<string>} url 
         * @param {Array<string>} context 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testQueryParameterCollectionFormat(pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options?: any): AxiosPromise<void> {
            return localVarFp.testQueryParameterCollectionFormat(pipe, ioutil, http, url, context, options).then((request) => request(axios, basePath));
        },
        /**
         * To test unique items in header and query parameters
         * @param {Set<string>} queryUnique 
         * @param {Set<string>} headerUnique 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testUniqueItemsHeaderAndQueryParameterCollectionFormat(queryUnique: Set<string>, headerUnique: Set<string>, options?: any): AxiosPromise<Set<Pet>> {
            return localVarFp.testUniqueItemsHeaderAndQueryParameterCollectionFormat(queryUnique, headerUnique, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeApi - object-oriented interface
 * @export
 * @class FakeApi
 * @extends {BaseAPI}
 */
export class FakeApi extends BaseAPI {
    /**
     * 
     * @summary Health check endpoint
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeHealthGet(options?: any) {
        return FakeApiFp(this.configuration).fakeHealthGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of outer boolean types
     * @param {boolean} [body] Input boolean as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterBooleanSerialize(body?: boolean, options?: any) {
        return FakeApiFp(this.configuration).fakeOuterBooleanSerialize(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of object with outer number type
     * @param {OuterComposite} [outerComposite] Input composite as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterCompositeSerialize(outerComposite?: OuterComposite, options?: any) {
        return FakeApiFp(this.configuration).fakeOuterCompositeSerialize(outerComposite, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of outer number types
     * @param {number} [body] Input number as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterNumberSerialize(body?: number, options?: any) {
        return FakeApiFp(this.configuration).fakeOuterNumberSerialize(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Test serialization of outer string types
     * @param {string} [body] Input string as post body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public fakeOuterStringSerialize(body?: string, options?: any) {
        return FakeApiFp(this.configuration).fakeOuterStringSerialize(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For this test, the body for this request much reference a schema named `File`.
     * @param {FileSchemaTestClass} fileSchemaTestClass 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testBodyWithFileSchema(fileSchemaTestClass: FileSchemaTestClass, options?: any) {
        return FakeApiFp(this.configuration).testBodyWithFileSchema(fileSchemaTestClass, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} query 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testBodyWithQueryParams(query: string, user: User, options?: any) {
        return FakeApiFp(this.configuration).testBodyWithQueryParams(query, user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To test \"client\" model
     * @summary To test \"client\" model
     * @param {Client} client client model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testClientModel(client: Client, options?: any) {
        return FakeApiFp(this.configuration).testClientModel(client, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
     * @summary Fake endpoint for testing various parameters 假端點 偽のエンドポイント 가짜 엔드 포인트 
     * @param {number} number None
     * @param {number} _double None
     * @param {string} patternWithoutDelimiter None
     * @param {string} _byte None
     * @param {number} [integer] None
     * @param {number} [int32] None
     * @param {number} [int64] None
     * @param {number} [_float] None
     * @param {string} [string] None
     * @param {any} [binary] None
     * @param {string} [date] None
     * @param {string} [dateTime] None
     * @param {string} [password] None
     * @param {string} [callback] None
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testEndpointParameters(number: number, _double: number, patternWithoutDelimiter: string, _byte: string, integer?: number, int32?: number, int64?: number, _float?: number, string?: string, binary?: any, date?: string, dateTime?: string, password?: string, callback?: string, options?: any) {
        return FakeApiFp(this.configuration).testEndpointParameters(number, _double, patternWithoutDelimiter, _byte, integer, int32, int64, _float, string, binary, date, dateTime, password, callback, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To test enum parameters
     * @summary To test enum parameters
     * @param {Array<'>' | '$'>} [enumHeaderStringArray] Header parameter enum test (string array)
     * @param {'_abc' | '-efg' | '(xyz)'} [enumHeaderString] Header parameter enum test (string)
     * @param {Array<'>' | '$'>} [enumQueryStringArray] Query parameter enum test (string array)
     * @param {'_abc' | '-efg' | '(xyz)'} [enumQueryString] Query parameter enum test (string)
     * @param {1 | -2} [enumQueryInteger] Query parameter enum test (double)
     * @param {1.1 | -1.2} [enumQueryDouble] Query parameter enum test (double)
     * @param {Array<string>} [enumFormStringArray] Form parameter enum test (string array)
     * @param {string} [enumFormString] Form parameter enum test (string)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testEnumParameters(enumHeaderStringArray?: Array<'>' | '$'>, enumHeaderString?: '_abc' | '-efg' | '(xyz)', enumQueryStringArray?: Array<'>' | '$'>, enumQueryString?: '_abc' | '-efg' | '(xyz)', enumQueryInteger?: 1 | -2, enumQueryDouble?: 1.1 | -1.2, enumFormStringArray?: Array<string>, enumFormString?: string, options?: any) {
        return FakeApiFp(this.configuration).testEnumParameters(enumHeaderStringArray, enumHeaderString, enumQueryStringArray, enumQueryString, enumQueryInteger, enumQueryDouble, enumFormStringArray, enumFormString, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Fake endpoint to test group parameters (optional)
     * @summary Fake endpoint to test group parameters (optional)
     * @param {number} requiredStringGroup Required String in group parameters
     * @param {boolean} requiredBooleanGroup Required Boolean in group parameters
     * @param {number} requiredInt64Group Required Integer in group parameters
     * @param {number} [stringGroup] String in group parameters
     * @param {boolean} [booleanGroup] Boolean in group parameters
     * @param {number} [int64Group] Integer in group parameters
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testGroupParameters(requiredStringGroup: number, requiredBooleanGroup: boolean, requiredInt64Group: number, stringGroup?: number, booleanGroup?: boolean, int64Group?: number, options?: any) {
        return FakeApiFp(this.configuration).testGroupParameters(requiredStringGroup, requiredBooleanGroup, requiredInt64Group, stringGroup, booleanGroup, int64Group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test inline additionalProperties
     * @param {{ [key: string]: string; }} requestBody request body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testInlineAdditionalProperties(requestBody: { [key: string]: string; }, options?: any) {
        return FakeApiFp(this.configuration).testInlineAdditionalProperties(requestBody, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary test json serialization of form data
     * @param {string} param field1
     * @param {string} param2 field2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testJsonFormData(param: string, param2: string, options?: any) {
        return FakeApiFp(this.configuration).testJsonFormData(param, param2, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To test the collection format in query parameters
     * @param {Array<string>} pipe 
     * @param {Array<string>} ioutil 
     * @param {Array<string>} http 
     * @param {Array<string>} url 
     * @param {Array<string>} context 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testQueryParameterCollectionFormat(pipe: Array<string>, ioutil: Array<string>, http: Array<string>, url: Array<string>, context: Array<string>, options?: any) {
        return FakeApiFp(this.configuration).testQueryParameterCollectionFormat(pipe, ioutil, http, url, context, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * To test unique items in header and query parameters
     * @param {Set<string>} queryUnique 
     * @param {Set<string>} headerUnique 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeApi
     */
    public testUniqueItemsHeaderAndQueryParameterCollectionFormat(queryUnique: Set<string>, headerUnique: Set<string>, options?: any) {
        return FakeApiFp(this.configuration).testUniqueItemsHeaderAndQueryParameterCollectionFormat(queryUnique, headerUnique, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FakeClassnameTags123Api - axios parameter creator
 * @export
 */
export const FakeClassnameTags123ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * To test class name in snake case
         * @summary To test class name in snake case
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClassname: async (client: Client, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'client' is not null or undefined
            assertParamExists('testClassname', 'client', client)
            const localVarPath = `/fake_classname_test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key_query required
            await setApiKeyToObject(localVarQueryParameter, "api_key_query", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(client, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeClassnameTags123Api - functional programming interface
 * @export
 */
export const FakeClassnameTags123ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeClassnameTags123ApiAxiosParamCreator(configuration)
    return {
        /**
         * To test class name in snake case
         * @summary To test class name in snake case
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testClassname(client: Client, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Client>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testClassname(client, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FakeClassnameTags123Api - factory interface
 * @export
 */
export const FakeClassnameTags123ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeClassnameTags123ApiFp(configuration)
    return {
        /**
         * To test class name in snake case
         * @summary To test class name in snake case
         * @param {Client} client client model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testClassname(client: Client, options?: any): AxiosPromise<Client> {
            return localVarFp.testClassname(client, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeClassnameTags123Api - object-oriented interface
 * @export
 * @class FakeClassnameTags123Api
 * @extends {BaseAPI}
 */
export class FakeClassnameTags123Api extends BaseAPI {
    /**
     * To test class name in snake case
     * @summary To test class name in snake case
     * @param {Client} client client model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeClassnameTags123Api
     */
    public testClassname(client: Client, options?: any) {
        return FakeClassnameTags123ApiFp(this.configuration).testClassname(client, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PetApi - axios parameter creator
 * @export
 */
export const PetApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPet: async (pet: Pet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pet' is not null or undefined
            assertParamExists('addPet', 'pet', pet)
            const localVarPath = `/pet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePet: async (petId: number, apiKey?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('deletePet', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (apiKey !== undefined && apiKey !== null) {
                localVarHeaderParameter['api_key'] = String(apiKey);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPetsByStatus: async (status: Array<'available' | 'pending' | 'sold'>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'status' is not null or undefined
            assertParamExists('findPetsByStatus', 'status', status)
            const localVarPath = `/pet/findByStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (status) {
                localVarQueryParameter['status'] = status.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPetsByTags: async (tags: Array<string>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'tags' is not null or undefined
            assertParamExists('findPetsByTags', 'tags', tags)
            const localVarPath = `/pet/findByTags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetById: async (petId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('getPetById', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing pet
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePet: async (pet: Pet, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'pet' is not null or undefined
            assertParamExists('updatePet', 'pet', pet)
            const localVarPath = `/pet`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_signature_test required

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pet, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetWithForm: async (petId: number, name?: string, status?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('updatePetWithForm', 'petId', petId)
            const localVarPath = `/pet/{petId}`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


            if (name !== undefined) { 
                localVarFormParams.set('name', name as any);
            }
    
            if (status !== undefined) { 
                localVarFormParams.set('status', status as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} petId ID of pet to update
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {any} [file] file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile: async (petId: number, additionalMetadata?: string, file?: any, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('uploadFile', 'petId', petId)
            const localVarPath = `/pet/{petId}/uploadImage`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


            if (additionalMetadata !== undefined) { 
                localVarFormParams.append('additionalMetadata', additionalMetadata as any);
            }
    
            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploads an image (required)
         * @param {number} petId ID of pet to update
         * @param {any} requiredFile file to upload
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileWithRequiredFile: async (petId: number, requiredFile: any, additionalMetadata?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'petId' is not null or undefined
            assertParamExists('uploadFileWithRequiredFile', 'petId', petId)
            // verify required parameter 'requiredFile' is not null or undefined
            assertParamExists('uploadFileWithRequiredFile', 'requiredFile', requiredFile)
            const localVarPath = `/fake/{petId}/uploadImageWithRequiredFile`
                .replace(`{${"petId"}}`, encodeURIComponent(String(petId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication petstore_auth required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "petstore_auth", ["write:pets", "read:pets"], configuration)


            if (additionalMetadata !== undefined) { 
                localVarFormParams.append('additionalMetadata', additionalMetadata as any);
            }
    
            if (requiredFile !== undefined) { 
                localVarFormParams.append('requiredFile', requiredFile as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PetApi - functional programming interface
 * @export
 */
export const PetApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PetApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPet(pet: Pet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPet(pet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePet(petId: number, apiKey?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePet(petId, apiKey, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPetsByStatus(status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async findPetsByTags(tags: Array<string>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Pet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findPetsByTags(tags, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPetById(petId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Pet>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPetById(petId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update an existing pet
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePet(pet: Pet, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePet(pet, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePetWithForm(petId: number, name?: string, status?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePetWithForm(petId, name, status, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} petId ID of pet to update
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {any} [file] file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFile(petId, additionalMetadata, file, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary uploads an image (required)
         * @param {number} petId ID of pet to update
         * @param {any} requiredFile file to upload
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFileWithRequiredFile(petId: number, requiredFile: any, additionalMetadata?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApiResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PetApi - factory interface
 * @export
 */
export const PetApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PetApiFp(configuration)
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPet(pet: Pet, options?: any): AxiosPromise<void> {
            return localVarFp.addPet(pet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Deletes a pet
         * @param {number} petId Pet id to delete
         * @param {string} [apiKey] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePet(petId: number, apiKey?: string, options?: any): AxiosPromise<void> {
            return localVarFp.deletePet(petId, apiKey, options).then((request) => request(axios, basePath));
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any): AxiosPromise<Array<Pet>> {
            return localVarFp.findPetsByStatus(status, options).then((request) => request(axios, basePath));
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param {Array<string>} tags Tags to filter by
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        findPetsByTags(tags: Array<string>, options?: any): AxiosPromise<Array<Pet>> {
            return localVarFp.findPetsByTags(tags, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param {number} petId ID of pet to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPetById(petId: number, options?: any): AxiosPromise<Pet> {
            return localVarFp.getPetById(petId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing pet
         * @param {Pet} pet Pet object that needs to be added to the store
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePet(pet: Pet, options?: any): AxiosPromise<void> {
            return localVarFp.updatePet(pet, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param {number} petId ID of pet that needs to be updated
         * @param {string} [name] Updated name of the pet
         * @param {string} [status] Updated status of the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePetWithForm(petId: number, name?: string, status?: string, options?: any): AxiosPromise<void> {
            return localVarFp.updatePetWithForm(petId, name, status, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} petId ID of pet to update
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {any} [file] file to upload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.uploadFile(petId, additionalMetadata, file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary uploads an image (required)
         * @param {number} petId ID of pet to update
         * @param {any} requiredFile file to upload
         * @param {string} [additionalMetadata] Additional data to pass to server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFileWithRequiredFile(petId: number, requiredFile: any, additionalMetadata?: string, options?: any): AxiosPromise<ApiResponse> {
            return localVarFp.uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PetApi - object-oriented interface
 * @export
 * @class PetApi
 * @extends {BaseAPI}
 */
export class PetApi extends BaseAPI {
    /**
     * 
     * @summary Add a new pet to the store
     * @param {Pet} pet Pet object that needs to be added to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public addPet(pet: Pet, options?: any) {
        return PetApiFp(this.configuration).addPet(pet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Deletes a pet
     * @param {number} petId Pet id to delete
     * @param {string} [apiKey] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public deletePet(petId: number, apiKey?: string, options?: any) {
        return PetApiFp(this.configuration).deletePet(petId, apiKey, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param {Array<'available' | 'pending' | 'sold'>} status Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public findPetsByStatus(status: Array<'available' | 'pending' | 'sold'>, options?: any) {
        return PetApiFp(this.configuration).findPetsByStatus(status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param {Array<string>} tags Tags to filter by
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public findPetsByTags(tags: Array<string>, options?: any) {
        return PetApiFp(this.configuration).findPetsByTags(tags, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param {number} petId ID of pet to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public getPetById(petId: number, options?: any) {
        return PetApiFp(this.configuration).getPetById(petId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing pet
     * @param {Pet} pet Pet object that needs to be added to the store
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public updatePet(pet: Pet, options?: any) {
        return PetApiFp(this.configuration).updatePet(pet, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param {number} petId ID of pet that needs to be updated
     * @param {string} [name] Updated name of the pet
     * @param {string} [status] Updated status of the pet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public updatePetWithForm(petId: number, name?: string, status?: string, options?: any) {
        return PetApiFp(this.configuration).updatePetWithForm(petId, name, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary uploads an image
     * @param {number} petId ID of pet to update
     * @param {string} [additionalMetadata] Additional data to pass to server
     * @param {any} [file] file to upload
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public uploadFile(petId: number, additionalMetadata?: string, file?: any, options?: any) {
        return PetApiFp(this.configuration).uploadFile(petId, additionalMetadata, file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary uploads an image (required)
     * @param {number} petId ID of pet to update
     * @param {any} requiredFile file to upload
     * @param {string} [additionalMetadata] Additional data to pass to server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PetApi
     */
    public uploadFileWithRequiredFile(petId: number, requiredFile: any, additionalMetadata?: string, options?: any) {
        return PetApiFp(this.configuration).uploadFileWithRequiredFile(petId, requiredFile, additionalMetadata, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * StoreApi - axios parameter creator
 * @export
 */
export const StoreApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param {string} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder: async (orderId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('deleteOrder', 'orderId', orderId)
            const localVarPath = `/store/order/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/store/inventory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            await setApiKeyToObject(localVarHeaderParameter, "api_key", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of pet that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById: async (orderId: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderById', 'orderId', orderId)
            const localVarPath = `/store/order/{order_id}`
                .replace(`{${"order_id"}}`, encodeURIComponent(String(orderId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param {Order} order order placed for purchasing the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder: async (order: Order, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'order' is not null or undefined
            assertParamExists('placeOrder', 'order', order)
            const localVarPath = `/store/order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(order, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StoreApi - functional programming interface
 * @export
 */
export const StoreApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StoreApiAxiosParamCreator(configuration)
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param {string} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteOrder(orderId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteOrder(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInventory(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInventory(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of pet that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderById(orderId: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderById(orderId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param {Order} order order placed for purchasing the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOrder(order: Order, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Order>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOrder(order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * StoreApi - factory interface
 * @export
 */
export const StoreApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StoreApiFp(configuration)
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param {string} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventory(options?: any): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getInventory(options).then((request) => request(axios, basePath));
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of pet that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(orderId: number, options?: any): AxiosPromise<Order> {
            return localVarFp.getOrderById(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param {Order} order order placed for purchasing the pet
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(order: Order, options?: any): AxiosPromise<Order> {
            return localVarFp.placeOrder(order, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StoreApi - object-oriented interface
 * @export
 * @class StoreApi
 * @extends {BaseAPI}
 */
export class StoreApi extends BaseAPI {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param {string} orderId ID of the order that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public deleteOrder(orderId: string, options?: any) {
        return StoreApiFp(this.configuration).deleteOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public getInventory(options?: any) {
        return StoreApiFp(this.configuration).getInventory(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param {number} orderId ID of pet that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public getOrderById(orderId: number, options?: any) {
        return StoreApiFp(this.configuration).getOrderById(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Place an order for a pet
     * @param {Order} order order placed for purchasing the pet
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StoreApi
     */
    public placeOrder(order: Order, options?: any) {
        return StoreApiFp(this.configuration).placeOrder(order, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param {User} user Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser: async (user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUser', 'user', user)
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithArrayInput: async (user: Array<User>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUsersWithArrayInput', 'user', user)
            const localVarPath = `/user/createWithArray`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithListInput: async (user: Array<User>, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('createUsersWithListInput', 'user', user)
            const localVarPath = `/user/createWithList`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('deleteUser', 'username', username)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched. Use user1 for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByName: async (username: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getUserByName', 'username', username)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser: async (username: string, password: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('loginUser', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('loginUser', 'password', password)
            const localVarPath = `/user/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (username !== undefined) {
                localVarQueryParameter['username'] = username;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {string} username name that need to be deleted
         * @param {User} user Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (username: string, user: User, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('updateUser', 'username', username)
            // verify required parameter 'user' is not null or undefined
            assertParamExists('updateUser', 'user', user)
            const localVarPath = `/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param {User} user Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUser(user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUser(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsersWithArrayInput(user: Array<User>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsersWithArrayInput(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUsersWithListInput(user: Array<User>, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUsersWithListInput(user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched. Use user1 for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserByName(username: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserByName(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginUser(username: string, password: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginUser(username, password, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logoutUser(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logoutUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {string} username name that need to be deleted
         * @param {User} user Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(username: string, user: User, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(username, user, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param {User} user Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(user: User, options?: any): AxiosPromise<void> {
            return localVarFp.createUser(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithArrayInput(user: Array<User>, options?: any): AxiosPromise<void> {
            return localVarFp.createUsersWithArrayInput(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param {Array<User>} user List of user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUsersWithListInput(user: Array<User>, options?: any): AxiosPromise<void> {
            return localVarFp.createUsersWithListInput(user, options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} username The name that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(username: string, options?: any): AxiosPromise<void> {
            return localVarFp.deleteUser(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user by user name
         * @param {string} username The name that needs to be fetched. Use user1 for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByName(username: string, options?: any): AxiosPromise<User> {
            return localVarFp.getUserByName(username, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} username The user name for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(username: string, password: string, options?: any): AxiosPromise<string> {
            return localVarFp.loginUser(username, password, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): AxiosPromise<void> {
            return localVarFp.logoutUser(options).then((request) => request(axios, basePath));
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param {string} username name that need to be deleted
         * @param {User} user Updated user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(username: string, user: User, options?: any): AxiosPromise<void> {
            return localVarFp.updateUser(username, user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param {User} user Created user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(user: User, options?: any) {
        return UserApiFp(this.configuration).createUser(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates list of users with given input array
     * @param {Array<User>} user List of user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUsersWithArrayInput(user: Array<User>, options?: any) {
        return UserApiFp(this.configuration).createUsersWithArrayInput(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Creates list of users with given input array
     * @param {Array<User>} user List of user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUsersWithListInput(user: Array<User>, options?: any) {
        return UserApiFp(this.configuration).createUsersWithListInput(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param {string} username The name that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(username: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user by user name
     * @param {string} username The name that needs to be fetched. Use user1 for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByName(username: string, options?: any) {
        return UserApiFp(this.configuration).getUserByName(username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs user into the system
     * @param {string} username The user name for login
     * @param {string} password The password for login in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginUser(username: string, password: string, options?: any) {
        return UserApiFp(this.configuration).loginUser(username, password, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logoutUser(options?: any) {
        return UserApiFp(this.configuration).logoutUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param {string} username name that need to be deleted
     * @param {User} user Updated user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(username: string, user: User, options?: any) {
        return UserApiFp(this.configuration).updateUser(username, user, options).then((request) => request(this.axios, this.basePath));
    }
}


