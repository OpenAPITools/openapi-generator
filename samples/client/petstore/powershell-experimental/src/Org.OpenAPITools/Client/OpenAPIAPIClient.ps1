#
# OpenAPI Petstore
# This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
# Version: 1.0.0
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

function Invoke-OpenAPIAPIClient {
  
    [CmdletBinding()]
    Param(
        [Parameter(Mandatory)]
        [string]$Uri,
        [Parameter(Mandatory)]
        [hashtable]$Accepts,
        [Parameter(Mandatory)]
        [hashtable]$ContentTypes,
        [Parameter(Mandatory)]
        [hashtable]$HeaderParameters,
        [Parameter(Mandatory)]
        [hashtable]$FormParameters,
        [Parameter(Mandatory)]
        [hashtable]$QueryParameters,
        [Parameter(Mandatory)]
        [hashtable]$CookieParameters,
        [Parameter(Mandatory)]
        [string]$Body,
        [Parameter(Mandatory)]
        [string]$Method
    )

    $PSBoundParameters | Out-DebugParameter | Write-Host

    $RequestUri = $Configuration["BaseUrl"] + $Uri
    $RestMethodParameters = [System.UriBuilder]($RequestUri)

    $Configuraiton = Get-OpenAPIConfiguration

    #Write-Host $RestMethodParameters['Uri']
    #$RestMethodParameters['Uri'] = $Uri
    #$RestMethodParameters.Method = $Method

    # cookie parameters
    foreach ($Parameter in $CookieParameters) {
        if ($CookieParameters[$Parameter]) {
            $HeaderParameters["Cookie"] = $CookieParameters[$Parameter]
        }
    }
    if (!$CookieParametters -and $CookieParameters.Count -gt 1) {
        Write-Warning "Multipe cookie parameters found. Curently only the first one is supported/used"
    }

    # accept, content-type headers
    $Accept = SelectAcceptHeaders($Accepts)
    if ($Accept) {
        $HeaderParameters['Accept'] = $Accept
    }

    $ContentType= SelectContentTypeHeaders($ContentTypes)
    if ($ContentType) {
        $HeaderParameters['Content-Type'] = $ContentType
    }

    # TODO revise code block
    # URL query string
    $HttpValues = [System.Web.HttpUtility]::ParseQueryString([String]::Empty)
    foreach ($Item in $QueryParameters.GetEnumerator()) {
        if ($Item.Value.Count -gt 1) {
            # It is an array, so treat that as a special case.
            foreach ($Value in $Item.Value) {
                # Add each item in the array, optionally mark the name of the parameter
                # to indicate it is an array parameter.
                $ParameterName = $Item.Key
                $ParameterName += '[]' # array
                $HttpValues.Add($ParameterName, $Value)
            }
        } else {
            # Add the scalar value.
            $HttpValues.Add($Item.Key,$Item.Value)
        }
    }
    # Build the request and load it with the query string.
    #$Request  = [System.UriBuilder]($Uri)
    $RestMethodParameters.Query = $HttpValues.ToString()

    # process parameters
    #if (!$HeaderParameters -and $HeaderParameters.Count -gt 0) {
    #    $RestMethodParameters['Headers'] = $HeaderParameters
    #}
    if (!$Accept -and $Accept.Count -gt 0) {
        $HeaderParameters['Accept'] = $Accept
    }
    if (!$ContentType -and $ContenType.Count -gt 0) {
        $HeaderParameters['Accept'] = $ContentType
    }

    # include form parameters in the request body
    if (!$FormParameters -and $FormParameters.Count -gt 0) {
        $RequestBody = $FormParameters
    }

    if (!$Body) {
        $RequestBody = $Body
    }

    Write-Host $HeaderParameters

    $Response = Invoke-WebRequest -Uri $RequestUri `
                                  -Method $Method `
                                  -Headers $HeaderParameters `
                                  -Body $RequestBody
}

function SelectAcceptHeaders {
    Param(
        [Parameter(Mandatory)]
        [hashtable]$Accepts
    )

    foreach ($Accept in $Accepts) {
        if (IsJsonMIME($Accept)) {
            return $true
        }
    }

    if (!($Accepts) -or $Accepts.Count -eq 0) {
        return $null
    } else {
        return $Accepts[0] # return the first one
    }
}

function SelectContentTypeHeaders {
    Param(
        [Parameter(Mandatory)]
        [hashtable]$ContentTypes
    )

    foreach ($ContentType in $ContentTypes) {
        if (IsJsonMIME($ContentType)) {
            return $true
        }
    }

    if (!($ContentTypes) -or $ContentTypes.Count -eq 0) {
        return $null
    } else {
        return $ContentTypes[0] # return the first one
    }
}

function IsJsonMIME {
    Param(
        [Parameter(Mandatory)]
        [string]$input
    )

    if ($input -match "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$") {
        return $true
    } else {
        return $false
    }
}
