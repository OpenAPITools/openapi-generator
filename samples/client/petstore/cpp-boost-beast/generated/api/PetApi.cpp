/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI-Generator unset.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include <sstream>
#include <string>
#include <map>

#include <boost/lexical_cast.hpp>
#include <boost/beast/http/status.hpp>
#include <boost/format.hpp>

#include "PetApi.h"


namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;


PetApiException::PetApiException(boost::beast::http::status statusCode, std::string what)
  : m_status(statusCode),
    m_what(what)
{
}

boost::beast::http::status PetApiException::getStatus() const
{
    return m_status;
}

const char* PetApiException::what() const noexcept
{
    return m_what.c_str();
}


std::shared_ptr<Pet>
PetApi::addPet(
    const std::shared_ptr<Pet>& pet) {
    std::string requestBody;
    std::string path = m_context + "pet";;
    std::map<std::string, std::string> headers;
    // Body params
    requestBody = pet->toJsonString();

    addPet_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("POST",
                              path,
                              requestBody,
                              headers);
    }
    catch(const std::exception& e) {
        addPet_handleStdException(e);
    }
    catch(...) {
        addPet_handleUncaughtException();
    }
    std::shared_ptr<Pet> result{};
        result->fromJsonString(responseBody);
    return result;
}

std::shared_ptr<Pet>
PetApi::updatePet(
    const std::shared_ptr<Pet>& pet) {
    std::string requestBody;
    std::string path = m_context + "pet";
    std::map<std::string, std::string> headers;
    // Body params
    requestBody = pet->toJsonString();

    updatePet_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("PUT",
                path,
                requestBody,
                headers);
    }
    catch(const std::exception& e) {
        updatePet_handleStdException(e);
    }
    catch(...) {
        updatePet_handleUncaughtException();
    }

    std::shared_ptr<Pet> result = std::make_shared<Pet>();
    if (statusCode == boost::beast::http::status(200)) {
        result->fromJsonString(responseBody);
    }
    if (statusCode == boost::beast::http::status(400)) {
        throw PetApiException(statusCode, "Invalid ID supplied");
    }
    if (statusCode == boost::beast::http::status(404)) {
        throw PetApiException(statusCode, "Pet not found");
    }
    if (statusCode == boost::beast::http::status(405)) {
        throw PetApiException(statusCode, "Validation exception");
    }

    return result;
}

void PetApi::addPet_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::addPet_handleStdException(
    const std::exception& e) {
    throw e;
}

void PetApi::addPet_handleUncaughtException() {
    throw;
}

void PetApi::updatePet_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::updatePet_handleStdException(
    const std::exception& e) {
    throw e;
}
void PetApi::updatePet_handleUncaughtException() {
    throw;
}
void
PetApi::deletePet(
    const int64_t& petId, const std::string& apiKey) {
    std::string requestBody;
    std::string path = m_context + "/pet/%1%";;
    std::map<std::string, std::string> headers;
    // path params
    const auto formattedPath = boost::format(path) % petId;
    path = formattedPath.str();
    // headers
    headers.emplace(std::make_pair("apiKey", boost::lexical_cast<std::string>(apiKey)));

    deletePet_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("DELETE",
                              path,
                              requestBody,
                              headers);
    }
    catch(const std::exception& e) {
        deletePet_handleStdException(e);
    }
    catch(...) {
        deletePet_handleUncaughtException();
    }
}

std::shared_ptr<Pet>
PetApi::getPetById(
    const int64_t& petId) {
    std::string requestBody;
    std::string path = m_context + "/pet/%1%";
    std::map<std::string, std::string> headers;
    // path params
    const auto formattedPath = boost::format(path) % petId;
    path = formattedPath.str();

    getPetById_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("GET",
                path,
                requestBody,
                headers);
    }
    catch(const std::exception& e) {
        getPetById_handleStdException(e);
    }
    catch(...) {
        getPetById_handleUncaughtException();
    }

    std::shared_ptr<Pet> result = std::make_shared<Pet>();
    if (statusCode == boost::beast::http::status(200)) {
        result->fromJsonString(responseBody);
    }
    if (statusCode == boost::beast::http::status(400)) {
        throw PetApiException(statusCode, "Invalid ID supplied");
    }
    if (statusCode == boost::beast::http::status(404)) {
        throw PetApiException(statusCode, "Pet not found");
    }

    return result;
}


void
PetApi::updatePetWithForm(
    const int64_t& petId, const std::string& name, const std::string& status) {
    std::string requestBody;
    std::string path = m_context + "/pet/%1%";
    std::map<std::string, std::string> headers;
    // path params
    const auto formattedPath = boost::format(path) % petId;
    path = formattedPath.str();

    updatePetWithForm_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("POST",
                path,
                requestBody,
                headers);
    }
    catch(const std::exception& e) {
        updatePetWithForm_handleStdException(e);
    }
    catch(...) {
        updatePetWithForm_handleUncaughtException();
    }

    if (statusCode == boost::beast::http::status(405)) {
        throw PetApiException(statusCode, "Invalid input");
    }

}

void PetApi::deletePet_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::deletePet_handleStdException(
    const std::exception& e) {
    throw e;
}

void PetApi::deletePet_handleUncaughtException() {
    throw;
}

void PetApi::getPetById_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::getPetById_handleStdException(
    const std::exception& e) {
    throw e;
}
void PetApi::getPetById_handleUncaughtException() {
    throw;
}
void PetApi::updatePetWithForm_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::updatePetWithForm_handleStdException(
    const std::exception& e) {
    throw e;
}
void PetApi::updatePetWithForm_handleUncaughtException() {
    throw;
}
std::vector<std::shared_ptr<Pet>>
PetApi::findPetsByStatus(
    const std::vector<std::string>& status) {
    std::string requestBody;
    std::string path = m_context + "/pet/findByStatus/";;
    std::map<std::string, std::string> headers;
    // query params
    std::stringstream queryParamStream;
    queryParamStream << '?';
    path += queryParamStream.str();

    findPetsByStatus_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("GET",
                              path,
                              requestBody,
                              headers);
    }
    catch(const std::exception& e) {
        findPetsByStatus_handleStdException(e);
    }
    catch(...) {
        findPetsByStatus_handleUncaughtException();
    }
    std::vector<std::shared_ptr<Pet>> result{};
    return result;
}
void PetApi::findPetsByStatus_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::findPetsByStatus_handleStdException(
    const std::exception& e) {
    throw e;
}

void PetApi::findPetsByStatus_handleUncaughtException() {
    throw;
}

std::vector<std::shared_ptr<Pet>>
PetApi::findPetsByTags(
    const std::vector<std::string>& tags) {
    std::string requestBody;
    std::string path = m_context + "/pet/findByTags/";;
    std::map<std::string, std::string> headers;
    // query params
    std::stringstream queryParamStream;
    queryParamStream << '?';
    path += queryParamStream.str();

    findPetsByTags_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("GET",
                              path,
                              requestBody,
                              headers);
    }
    catch(const std::exception& e) {
        findPetsByTags_handleStdException(e);
    }
    catch(...) {
        findPetsByTags_handleUncaughtException();
    }
    std::vector<std::shared_ptr<Pet>> result{};
    return result;
}
void PetApi::findPetsByTags_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::findPetsByTags_handleStdException(
    const std::exception& e) {
    throw e;
}

void PetApi::findPetsByTags_handleUncaughtException() {
    throw;
}

std::shared_ptr<ApiResponse>
PetApi::uploadFile(
    const int64_t& petId, const std::string& additionalMetadata, const std::string& file) {
    std::string requestBody;
    std::string path = m_context + "/pet/%1%/uploadImage/";;
    std::map<std::string, std::string> headers;
    // path params
    const auto formattedPath = boost::format(path) % petId;
    path = formattedPath.str();

    uploadFile_addDefaultHeaders(headers);

    auto statusCode = boost::beast::http::status::unknown;
    std::string responseBody;
    try {
        std::tie(statusCode, responseBody) =
            m_client->execute("POST",
                              path,
                              requestBody,
                              headers);
    }
    catch(const std::exception& e) {
        uploadFile_handleStdException(e);
    }
    catch(...) {
        uploadFile_handleUncaughtException();
    }
    std::shared_ptr<ApiResponse> result{};
        result->fromJsonString(responseBody);
    return result;
}
void PetApi::uploadFile_addDefaultHeaders(std::map<std::string, std::string>& headers) {
    static const std::map<std::string, std::string> defaultHeaders{std::make_pair("Accept",
                                                                                  "application/json"),
                                                                   std::make_pair("Content-Type",
                                                                                  "application/json;charset=UTF-8")};
    headers.insert(defaultHeaders.cbegin(), defaultHeaders.cend());
}

void PetApi::uploadFile_handleStdException(
    const std::exception& e) {
    throw e;
}

void PetApi::uploadFile_handleUncaughtException() {
    throw;
}


}  // namespace org
}  // namespace openapitools
}  // namespace client
}  // namespace api
