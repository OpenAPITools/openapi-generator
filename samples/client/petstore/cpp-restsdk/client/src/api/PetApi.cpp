/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * The version of the OpenAPI document: 1.0.0
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.0.0-SNAPSHOT.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


#include "CppRestPetstoreClient/api/PetApi.h"
#include "CppRestPetstoreClient/IHttpBody.h"
#include "CppRestPetstoreClient/JsonBody.h"
#include "CppRestPetstoreClient/MultipartFormData.h"

#include <boost/algorithm/string/replace.hpp>

#include <regex>
#include <unordered_set>

namespace {

    enum SerDeContentType {
        BINARY,
        JSON_DIALECT,
        MULTIPART_FORM_DATA,
        TEXT_PLAIN,
        X_WWW_FORM_URLENCODED
    };

    std::pair<bool, utility::string_t> check_json_content_type(const std::unordered_set<utility::string_t>& content_types)
    {
        auto it_content_type = content_types.find(utility::conversions::to_string_t("application/json"));
        if (it_content_type != content_types.end())
        {
            return std::make_pair(true, *it_content_type);
        }

        static const std::regex REGEX_JSON_CONTENT(R"(application/([a-zA-Z0-9]+\+)?json)");
        auto it_regex_match = std::find_if(content_types.begin(), content_types.end(),
            [](const utility::string_t& content_type) -> bool {
                return std::regex_match(utility::conversions::to_utf8string(content_type), REGEX_JSON_CONTENT);
            });

        bool dialect_matched = it_regex_match != content_types.end();
        return std::make_pair(
            dialect_matched,
            (dialect_matched) ? *it_regex_match : utility::conversions::to_string_t("")
        );
    }

    std::pair<utility::string_t, SerDeContentType> select_expected_response_content_type(const std::unordered_set<utility::string_t>& responseContentTypes)
    {
        utility::string_t responseContentType;
        SerDeContentType deserialiser;
        // use JSON if possible
        if ( responseContentTypes.size() == 0 )
        {
            responseContentType = utility::conversions::to_string_t("application/json");
            deserialiser = JSON_DIALECT;
        }
        // JSON
        else if (auto [supported_dialect, dialect_family] = check_json_content_type(responseContentTypes); supported_dialect)
        {
            responseContentType = dialect_family;
            deserialiser = JSON_DIALECT;
        }
        // multipart formdata
        else if( responseContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != responseContentTypes.end() )
        {
            responseContentType = utility::conversions::to_string_t("multipart/form-data");
            deserialiser = MULTIPART_FORM_DATA;
        }
        // x-www-form-urlencoded type
        else if (responseContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != responseContentTypes.end())
        {
            responseContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
            deserialiser = X_WWW_FORM_URLENCODED;
        }
        else
        {
            throw org::openapitools::client::api::ApiException(400, utility::conversions::to_string_t("PetApi-> does not produce any supported media type"));
        }

        return make_pair(responseContentType, deserialiser);
    }

    std::pair<utility::string_t, SerDeContentType> select_request_content_type(std::unordered_set<utility::string_t>& requestContentTypes)
    {
        utility::string_t requestContentType;
        SerDeContentType serialiser;

        if ( requestContentTypes.size() == 0 ){
            requestContentTypes.insert(utility::conversions::to_string_t("application/json"));
            serialiser = JSON_DIALECT;
        }

        // JSON
        else if (auto [supported_dialect, dialect_family] = check_json_content_type(requestContentTypes); supported_dialect)
        {
            requestContentType = dialect_family;
            serialiser = JSON_DIALECT;
        }
        // multipart formdata
        else if( requestContentTypes.find(utility::conversions::to_string_t("multipart/form-data")) != requestContentTypes.end() )
        {
            requestContentType = utility::conversions::to_string_t("multipart/form-data");
            serialiser = MULTIPART_FORM_DATA;
        }
        // x-www-form-urlencoded type
        else if (requestContentTypes.find(utility::conversions::to_string_t("application/x-www-form-urlencoded")) != requestContentTypes.end())
        {
            requestContentType = utility::conversions::to_string_t("application/x-www-form-urlencoded");
            serialiser = X_WWW_FORM_URLENCODED;
        }
        else
        {
            throw org::openapitools::client::api::ApiException(415, utility::conversions::to_string_t("PetApi-> does not consume any supported media type"));
        }

        return make_pair(requestContentType, serialiser);
    }

} // namespace anonymous

namespace org {
namespace openapitools {
namespace client {
namespace api {

using namespace org::openapitools::client::model;

PetApi::PetApi( std::shared_ptr<const ApiClient> apiClient )
    : m_ApiClient(apiClient)
{
}

PetApi::~PetApi()
{
}

pplx::task<void> PetApi::addPet(std::shared_ptr<Pet> body) const
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, utility::conversions::to_string_t("Missing required parameter 'body' when calling PetApi->addPet"));
    }


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet");

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("application/xml") );


    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
        web::json::value localVarJson;

        localVarJson = ModelBase::toJson(body);
        

        localVarHttpBody = std::shared_ptr<IHttpBody>( new JsonBody( localVarJson ) );
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
        std::shared_ptr<MultipartFormData> localVarMultipart(new MultipartFormData);

        if(body.get())
        {
            body->toMultipart(localVarMultipart, utility::conversions::to_string_t("body"));
        }
        

        localVarHttpBody = localVarMultipart;
        localVarRequestHttpContentType += utility::conversions::to_string_t("; boundary=") + localVarMultipart->getBoundary();
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling addPet: unsupported request type"));
    }

    // authentication (petstore_auth) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling addPet: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling addPet: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        return void();
    });
}
pplx::task<void> PetApi::deletePet(int64_t petId, boost::optional<utility::string_t> apiKey) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet/{petId}");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("petId") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(petId)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    if (apiKey)
    {
        localVarHeaderParams[utility::conversions::to_string_t("api_key")] = ApiClient::parameterToString(*apiKey);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling deletePet: unsupported request type"));
    }

    // authentication (petstore_auth) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("DELETE"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling deletePet: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling deletePet: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        return void();
    });
}
pplx::task<std::vector<std::shared_ptr<Pet>>> PetApi::findPetsByStatus(std::vector<utility::string_t> status) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet/findByStatus");

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/xml") );
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("status")] = ApiClient::parameterToString(status);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling findPetsByStatus: unsupported request type"));
    }

    // authentication (petstore_auth) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling findPetsByStatus: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling findPetsByStatus: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::vector<std::shared_ptr<Pet>> localVarResult;

        if (responseDeserialiser == JSON_DIALECT)
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);
            for( auto& localVarItem : localVarJson.as_array() )
            {
                std::shared_ptr<Pet> localVarItemObj;
                ModelBase::fromJson(localVarItem, localVarItemObj);
                localVarResult.push_back(localVarItemObj);
            }
        }
        // else if(responseDeserialiser == MULTIPART_FORM_DATA)
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling findPetsByStatus: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::vector<std::shared_ptr<Pet>>> PetApi::findPetsByTags(std::vector<utility::string_t> tags) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet/findByTags");

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/xml") );
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;

    {
        localVarQueryParams[utility::conversions::to_string_t("tags")] = ApiClient::parameterToString(tags);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling findPetsByTags: unsupported request type"));
    }

    // authentication (petstore_auth) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling findPetsByTags: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling findPetsByTags: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::vector<std::shared_ptr<Pet>> localVarResult;

        if (responseDeserialiser == JSON_DIALECT)
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);
            for( auto& localVarItem : localVarJson.as_array() )
            {
                std::shared_ptr<Pet> localVarItemObj;
                ModelBase::fromJson(localVarItem, localVarItemObj);
                localVarResult.push_back(localVarItemObj);
            }
        }
        // else if(responseDeserialiser == MULTIPART_FORM_DATA)
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling findPetsByTags: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<std::shared_ptr<Pet>> PetApi::getPetById(int64_t petId) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet/{petId}");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("petId") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(petId)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/xml") );
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;


    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling getPetById: unsupported request type"));
    }

    // authentication (api_key) required
    {
        utility::string_t localVarApiKey = localVarApiConfiguration->getApiKey(utility::conversions::to_string_t("api_key"));
        if ( localVarApiKey.size() > 0 )
        {
            localVarHeaderParams[utility::conversions::to_string_t("api_key")] = localVarApiKey;
        }
    }

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("GET"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling getPetById: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling getPetById: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::shared_ptr<Pet> localVarResult(new Pet());

        if (responseDeserialiser == JSON_DIALECT)
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(responseDeserialiser == MULTIPART_FORM_DATA)
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling getPetById: unsupported response type"));
        }

        return localVarResult;
    });
}
pplx::task<void> PetApi::updatePet(std::shared_ptr<Pet> body) const
{

    // verify the required parameter 'body' is set
    if (body == nullptr)
    {
        throw ApiException(400, utility::conversions::to_string_t("Missing required parameter 'body' when calling PetApi->updatePet"));
    }


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet");

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("application/xml") );


    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
        web::json::value localVarJson;

        localVarJson = ModelBase::toJson(body);
        

        localVarHttpBody = std::shared_ptr<IHttpBody>( new JsonBody( localVarJson ) );
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
        std::shared_ptr<MultipartFormData> localVarMultipart(new MultipartFormData);

        if(body.get())
        {
            body->toMultipart(localVarMultipart, utility::conversions::to_string_t("body"));
        }
        

        localVarHttpBody = localVarMultipart;
        localVarRequestHttpContentType += utility::conversions::to_string_t("; boundary=") + localVarMultipart->getBoundary();
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling updatePet: unsupported request type"));
    }

    // authentication (petstore_auth) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("PUT"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling updatePet: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling updatePet: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        return void();
    });
}
pplx::task<void> PetApi::updatePetWithForm(int64_t petId, boost::optional<utility::string_t> name, boost::optional<utility::string_t> status) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet/{petId}");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("petId") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(petId)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("application/x-www-form-urlencoded") );

    if (name)
    {
        localVarFormParams[ utility::conversions::to_string_t("name") ] = ApiClient::parameterToString(*name);
    }
    if (status)
    {
        localVarFormParams[ utility::conversions::to_string_t("status") ] = ApiClient::parameterToString(*status);
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling updatePetWithForm: unsupported request type"));
    }

    // authentication (petstore_auth) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling updatePetWithForm: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling updatePetWithForm: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        return void();
    });
}
pplx::task<std::shared_ptr<ApiResponse>> PetApi::uploadFile(int64_t petId, boost::optional<utility::string_t> additionalMetadata, boost::optional<std::shared_ptr<HttpContent>> file) const
{


    std::shared_ptr<const ApiConfiguration> localVarApiConfiguration( m_ApiClient->getConfiguration() );
    utility::string_t localVarPath = utility::conversions::to_string_t("/pet/{petId}/uploadImage");
    boost::replace_all(localVarPath, utility::conversions::to_string_t("{") + utility::conversions::to_string_t("petId") + utility::conversions::to_string_t("}"), web::uri::encode_uri(ApiClient::parameterToString(petId)));

    std::map<utility::string_t, utility::string_t> localVarQueryParams;
    std::map<utility::string_t, utility::string_t> localVarHeaderParams( localVarApiConfiguration->getDefaultHeaders() );
    std::map<utility::string_t, utility::string_t> localVarFormParams;
    std::map<utility::string_t, std::shared_ptr<HttpContent>> localVarFileParams;

    std::unordered_set<utility::string_t> localVarResponseHttpContentTypes;
    localVarResponseHttpContentTypes.insert( utility::conversions::to_string_t("application/json") );

    auto [localVarResponseHttpContentType, responseDeserialiser] = select_expected_response_content_type(localVarResponseHttpContentTypes);
    localVarHeaderParams[utility::conversions::to_string_t("Accept")] = localVarResponseHttpContentType;

    std::unordered_set<utility::string_t> localVarConsumeHttpContentTypes;
    localVarConsumeHttpContentTypes.insert( utility::conversions::to_string_t("multipart/form-data") );

    if (additionalMetadata)
    {
        localVarFormParams[ utility::conversions::to_string_t("additionalMetadata") ] = ApiClient::parameterToString(*additionalMetadata);
    }
    if (file && *file != nullptr)
    {
        localVarFileParams[ utility::conversions::to_string_t("file") ] = *file;
    }

    std::shared_ptr<IHttpBody> localVarHttpBody;
    auto [localVarRequestHttpContentType, requestSerialiser] = select_request_content_type(localVarConsumeHttpContentTypes);

    // use JSON if possible
    if (requestSerialiser == JSON_DIALECT)
    {
    }
    // multipart formdata
    else if(requestSerialiser == MULTIPART_FORM_DATA)
    {
    }
    else if (requestSerialiser == X_WWW_FORM_URLENCODED)
    {
        // TODO: serialise "application/x-www-form-urlencoded" format.
    }
    else if (requestSerialiser == TEXT_PLAIN)
    {
        // TODO: serialise "text/plain" format.
    }
    else if (requestSerialiser == BINARY)
    {
        // TODO: serialise "binary" format.
    }
    else
    {
        throw ApiException(500, utility::conversions::to_string_t("error calling uploadFile: unsupported request type"));
    }

    // authentication (petstore_auth) required
    // oauth2 authentication is added automatically as part of the http_client_config

    return m_ApiClient->callApi(localVarPath, utility::conversions::to_string_t("POST"), localVarQueryParams, localVarHttpBody, localVarHeaderParams, localVarFormParams, localVarFileParams, localVarRequestHttpContentType)
    .then([=](web::http::http_response localVarResponse)
    {
        if (m_ApiClient->getResponseHandler())
        {
            m_ApiClient->getResponseHandler()(localVarResponse.status_code(), localVarResponse.headers());
        }

        // 1xx - informational : OK
        // 2xx - successful       : OK
        // 3xx - redirection   : OK
        // 4xx - client error  : not OK
        // 5xx - client error  : not OK
        if (localVarResponse.status_code() >= 400)
        {
            throw ApiException(localVarResponse.status_code()
                , utility::conversions::to_string_t("error calling uploadFile: ") + localVarResponse.reason_phrase()
                , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
        }

        // check response content type
        if(localVarResponse.headers().has(utility::conversions::to_string_t("Content-Type")))
        {
            utility::string_t localVarContentType = localVarResponse.headers()[utility::conversions::to_string_t("Content-Type")];
            if( localVarContentType.find(localVarResponseHttpContentType) == std::string::npos )
            {
                throw ApiException(500
                    , utility::conversions::to_string_t("error calling uploadFile: unexpected response type: ") + localVarContentType
                    , std::make_shared<std::stringstream>(localVarResponse.extract_utf8string(true).get()));
            }
        }

        return localVarResponse.extract_string(true);
    })
    .then([=](utility::string_t localVarResponse)
    {
        std::shared_ptr<ApiResponse> localVarResult(new ApiResponse());

        if (responseDeserialiser == JSON_DIALECT)
        {
            web::json::value localVarJson = web::json::value::parse(localVarResponse);

            ModelBase::fromJson(localVarJson, localVarResult);
        }
        // else if(responseDeserialiser == MULTIPART_FORM_DATA)
        // {
        // TODO multipart response parsing
        // }
        else
        {
            throw ApiException(500
                , utility::conversions::to_string_t("error calling uploadFile: unsupported response type"));
        }

        return localVarResult;
    });
}

}
}
}
}

