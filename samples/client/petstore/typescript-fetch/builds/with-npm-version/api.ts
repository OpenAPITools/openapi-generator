/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at [http://swagger.io](http://swagger.io) or on [irc.freenode.net, #swagger](http://swagger.io/irc/).  For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@swagger.io
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

import { Configuration } from "./configuration";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://petstore.swagger.io/v2".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;
    public configuration: Configuration;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH, configuration: Configuration = new Configuration()) {
        this.basePath = basePath;
        this.fetch = fetch;
        this.configuration = configuration;
    }
};

/**
 * Describes the result of uploading an image resource
 */
export interface ApiResponse {
    "code"?: number;
    "type"?: string;
    "message"?: string;
}

/**
 * A category for a pet
 */
export interface Category {
    "id"?: number;
    "name"?: string;
}

/**
 * An order for a pets from the pet store
 */
export interface Order {
    "id"?: number;
    "petId"?: number;
    "quantity"?: number;
    "shipDate"?: Date;
    /**
     * Order Status
     */
    "status"?: OrderStatusEnum;
    "complete"?: boolean;
}

export type OrderStatusEnum = "placed" | "approved" | "delivered";
/**
 * A pet for sale in the pet store
 */
export interface Pet {
    "id"?: number;
    "category"?: Category;
    "name": string;
    "photoUrls": Array<string>;
    "tags"?: Array<Tag>;
    /**
     * pet status in the store
     */
    "status"?: PetStatusEnum;
}

export type PetStatusEnum = "available" | "pending" | "sold";
/**
 * A tag for a pet
 */
export interface Tag {
    "id"?: number;
    "name"?: string;
}

/**
 * A User who is purchasing from the pet store
 */
export interface User {
    "id"?: number;
    "username"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "email"?: string;
    "password"?: string;
    "phone"?: string;
    /**
     * User Status
     */
    "userStatus"?: number;
}



/**
 * PetApi - fetch parameter creator
 */
export const PetApiFetchParamCreator = {
    /**
     * 
     * @summary Add a new pet to the store
     * @param body Pet object that needs to be added to the store
     */
    addPet(params: {  body: Pet; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling addPet");
        }
        const baseUrl = `/pet`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (petstore_auth) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes a pet
     * @param petId Pet id to delete
     * @param apiKey 
     */
    deletePet(params: {  petId: number; apiKey?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling deletePet");
        }
        const baseUrl = `/pet/{petId}`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "api_key": params["apiKey"],
        }, contentTypeHeader, fetchOptions.headers);
        // authentication (petstore_auth) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param status Status values that need to be considered for filter
     */
    findPetsByStatus(params: {  status: Array<string>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "status" is set
        if (params["status"] == null) {
            throw new Error("Missing required parameter status when calling findPetsByStatus");
        }
        const baseUrl = `/pet/findByStatus`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["status"] !== undefined) {
            urlObj.query["status"] = params["status"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (petstore_auth) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param tags Tags to filter by
     */
    findPetsByTags(params: {  tags: Array<string>; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "tags" is set
        if (params["tags"] == null) {
            throw new Error("Missing required parameter tags when calling findPetsByTags");
        }
        const baseUrl = `/pet/findByTags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["tags"] !== undefined) {
            urlObj.query["tags"] = params["tags"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (petstore_auth) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param petId ID of pet to return
     */
    getPetById(params: {  petId: number; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling getPetById");
        }
        const baseUrl = `/pet/{petId}`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (api_key) required
        if (configuration.apiKey && configuration.apiKey.api_key) {
            fetchOptions.headers = assign({
                    "api_key": configuration.apiKey.api_key,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing pet
     * @param body Pet object that needs to be added to the store
     */
    updatePet(params: {  body: Pet; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updatePet");
        }
        const baseUrl = `/pet`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (petstore_auth) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param petId ID of pet that needs to be updated
     * @param name Updated name of the pet
     * @param status Updated status of the pet
     */
    updatePetWithForm(params: {  petId: number; name?: string; status?: string; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling updatePetWithForm");
        }
        const baseUrl = `/pet/{petId}`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "name": params["name"],
            "status": params["status"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (petstore_auth) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary uploads an image
     * @param petId ID of pet to update
     * @param additionalMetadata Additional data to pass to server
     * @param file file to upload
     */
    uploadFile(params: {  petId: number; additionalMetadata?: string; file?: any; }, configuration: Configuration, options: any = {}): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling uploadFile");
        }
        const baseUrl = `/pet/{petId}/uploadImage`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "additionalMetadata": params["additionalMetadata"],
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (petstore_auth) required
        // oauth required
        if (configuration.accessToken) {
            fetchOptions.headers = assign({
                    "Authorization": "Bearer " + configuration.accessToken,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PetApi - functional programming interface
 */
export const PetApiFp = {
    /**
     * 
     * @summary Add a new pet to the store
     * @param body Pet object that needs to be added to the store
     */
    addPet(params: { body: Pet;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.addPet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes a pet
     * @param petId Pet id to delete
     * @param apiKey 
     */
    deletePet(params: { petId: number; apiKey?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.deletePet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param status Status values that need to be considered for filter
     */
    findPetsByStatus(params: { status: Array<string>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<Pet>> {
        const fetchArgs = PetApiFetchParamCreator.findPetsByStatus(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param tags Tags to filter by
     */
    findPetsByTags(params: { tags: Array<string>;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Array<Pet>> {
        const fetchArgs = PetApiFetchParamCreator.findPetsByTags(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param petId ID of pet to return
     */
    getPetById(params: { petId: number;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Pet> {
        const fetchArgs = PetApiFetchParamCreator.getPetById(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing pet
     * @param body Pet object that needs to be added to the store
     */
    updatePet(params: { body: Pet;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.updatePet(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param petId ID of pet that needs to be updated
     * @param name Updated name of the pet
     * @param status Updated status of the pet
     */
    updatePetWithForm(params: { petId: number; name?: string; status?: string;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.updatePetWithForm(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary uploads an image
     * @param petId ID of pet to update
     * @param additionalMetadata Additional data to pass to server
     * @param file file to upload
     */
    uploadFile(params: { petId: number; additionalMetadata?: string; file?: any;  }, configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<ApiResponse> {
        const fetchArgs = PetApiFetchParamCreator.uploadFile(params, configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PetApi - object-oriented interface
 */
export class PetApi extends BaseAPI {
    /**
     * 
     * @summary Add a new pet to the store
     * @param body Pet object that needs to be added to the store
     */
    addPet(params: {  body: Pet; }, options: any = {}) {
        return PetApiFp.addPet(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes a pet
     * @param petId Pet id to delete
     * @param apiKey 
     */
    deletePet(params: {  petId: number; apiKey?: string; }, options: any = {}) {
        return PetApiFp.deletePet(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param status Status values that need to be considered for filter
     */
    findPetsByStatus(params: {  status: Array<string>; }, options: any = {}) {
        return PetApiFp.findPetsByStatus(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param tags Tags to filter by
     */
    findPetsByTags(params: {  tags: Array<string>; }, options: any = {}) {
        return PetApiFp.findPetsByTags(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a single pet
     * @summary Find pet by ID
     * @param petId ID of pet to return
     */
    getPetById(params: {  petId: number; }, options: any = {}) {
        return PetApiFp.getPetById(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing pet
     * @param body Pet object that needs to be added to the store
     */
    updatePet(params: {  body: Pet; }, options: any = {}) {
        return PetApiFp.updatePet(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param petId ID of pet that needs to be updated
     * @param name Updated name of the pet
     * @param status Updated status of the pet
     */
    updatePetWithForm(params: {  petId: number; name?: string; status?: string; }, options: any = {}) {
        return PetApiFp.updatePetWithForm(params, this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary uploads an image
     * @param petId ID of pet to update
     * @param additionalMetadata Additional data to pass to server
     * @param file file to upload
     */
    uploadFile(params: {  petId: number; additionalMetadata?: string; file?: any; }, options: any = {}) {
        return PetApiFp.uploadFile(params, this.configuration, options)(this.fetch, this.basePath);
    }
};

/**
 * PetApi - factory interface
 */
export const PetApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param body Pet object that needs to be added to the store
         */
        addPet(params: {  body: Pet; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.addPet(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a pet
         * @param petId Pet id to delete
         * @param apiKey 
         */
        deletePet(params: {  petId: number; apiKey?: string; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.deletePet(params, configuration, options)(fetch, basePath);
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param status Status values that need to be considered for filter
         */
        findPetsByStatus(params: {  status: Array<string>; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.findPetsByStatus(params, configuration, options)(fetch, basePath);
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param tags Tags to filter by
         */
        findPetsByTags(params: {  tags: Array<string>; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.findPetsByTags(params, configuration, options)(fetch, basePath);
        },
        /**
         * Returns a single pet
         * @summary Find pet by ID
         * @param petId ID of pet to return
         */
        getPetById(params: {  petId: number; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.getPetById(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing pet
         * @param body Pet object that needs to be added to the store
         */
        updatePet(params: {  body: Pet; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.updatePet(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param petId ID of pet that needs to be updated
         * @param name Updated name of the pet
         * @param status Updated status of the pet
         */
        updatePetWithForm(params: {  petId: number; name?: string; status?: string; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.updatePetWithForm(params, configuration, options)(fetch, basePath);
        },
        /**
         * 
         * @summary uploads an image
         * @param petId ID of pet to update
         * @param additionalMetadata Additional data to pass to server
         * @param file file to upload
         */
        uploadFile(params: {  petId: number; additionalMetadata?: string; file?: any; }, configuration: Configuration, options: any = {}) {
            return PetApiFp.uploadFile(params, configuration, options)(fetch, basePath);
        },
    };
};


/**
 * StoreApi - fetch parameter creator
 */
export const StoreApiFetchParamCreator = {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param orderId ID of the order that needs to be deleted
     */
    deleteOrder(params: {  orderId: string; }, options: any = {}): FetchArgs {
        // verify required parameter "orderId" is set
        if (params["orderId"] == null) {
            throw new Error("Missing required parameter orderId when calling deleteOrder");
        }
        const baseUrl = `/store/order/{orderId}`
            .replace(`{${"orderId"}}`, `${ params["orderId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     */
    getInventory(configuration: Configuration, options: any = {}): FetchArgs {
        const baseUrl = `/store/inventory`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        // authentication (api_key) required
        if (configuration.apiKey && configuration.apiKey.api_key) {
            fetchOptions.headers = assign({
                    "api_key": configuration.apiKey.api_key,
                    }, contentTypeHeader);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param orderId ID of pet that needs to be fetched
     */
    getOrderById(params: {  orderId: number; }, options: any = {}): FetchArgs {
        // verify required parameter "orderId" is set
        if (params["orderId"] == null) {
            throw new Error("Missing required parameter orderId when calling getOrderById");
        }
        const baseUrl = `/store/order/{orderId}`
            .replace(`{${"orderId"}}`, `${ params["orderId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Place an order for a pet
     * @param body order placed for purchasing the pet
     */
    placeOrder(params: {  body: Order; }, options: any = {}): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling placeOrder");
        }
        const baseUrl = `/store/order`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreApi - functional programming interface
 */
export const StoreApiFp = {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param orderId ID of the order that needs to be deleted
     */
    deleteOrder(params: { orderId: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     */
    getInventory(configuration: Configuration, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<{ [key: string]: number; }> {
        const fetchArgs = StoreApiFetchParamCreator.getInventory(configuration, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param orderId ID of pet that needs to be fetched
     */
    getOrderById(params: { orderId: number;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = StoreApiFetchParamCreator.getOrderById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Place an order for a pet
     * @param body order placed for purchasing the pet
     */
    placeOrder(params: { body: Order;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = StoreApiFetchParamCreator.placeOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreApi - object-oriented interface
 */
export class StoreApi extends BaseAPI {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param orderId ID of the order that needs to be deleted
     */
    deleteOrder(params: {  orderId: string; }, options: any = {}) {
        return StoreApiFp.deleteOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     */
    getInventory(options: any = {}) {
        return StoreApiFp.getInventory(this.configuration, options)(this.fetch, this.basePath);
    }
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param orderId ID of pet that needs to be fetched
     */
    getOrderById(params: {  orderId: number; }, options: any = {}) {
        return StoreApiFp.getOrderById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Place an order for a pet
     * @param body order placed for purchasing the pet
     */
    placeOrder(params: {  body: Order; }, options: any = {}) {
        return StoreApiFp.placeOrder(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreApi - factory interface
 */
export const StoreApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param orderId ID of the order that needs to be deleted
         */
        deleteOrder(params: {  orderId: string; }, options: any = {}) {
            return StoreApiFp.deleteOrder(params, options)(fetch, basePath);
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         */
        getInventory(configuration: Configuration, options: any = {}) {
            return StoreApiFp.getInventory(configuration, options)(fetch, basePath);
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param orderId ID of pet that needs to be fetched
         */
        getOrderById(params: {  orderId: number; }, options: any = {}) {
            return StoreApiFp.getOrderById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param body order placed for purchasing the pet
         */
        placeOrder(params: {  body: Order; }, options: any = {}) {
            return StoreApiFp.placeOrder(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param body Created user object
     */
    createUser(params: {  body: User; }, options: any = {}): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createUser");
        }
        const baseUrl = `/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithArrayInput(params: {  body: Array<User>; }, options: any = {}): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createUsersWithArrayInput");
        }
        const baseUrl = `/user/createWithArray`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithListInput(params: {  body: Array<User>; }, options: any = {}): FetchArgs {
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling createUsersWithListInput");
        }
        const baseUrl = `/user/createWithList`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param username The name that needs to be deleted
     */
    deleteUser(params: {  username: string; }, options: any = {}): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling deleteUser");
        }
        const baseUrl = `/user/{username}`
            .replace(`{${"username"}}`, `${ params["username"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get user by user name
     * @param username The name that needs to be fetched. Use user1 for testing. 
     */
    getUserByName(params: {  username: string; }, options: any = {}): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling getUserByName");
        }
        const baseUrl = `/user/{username}`
            .replace(`{${"username"}}`, `${ params["username"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logs user into the system
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: {  username: string; password: string; }, options: any = {}): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling loginUser");
        }
        // verify required parameter "password" is set
        if (params["password"] == null) {
            throw new Error("Missing required parameter password when calling loginUser");
        }
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query =  assign({}, urlObj.query);
        if (params["username"] !== undefined) {
            urlObj.query["username"] = params["username"];
        }
        if (params["password"] !== undefined) {
            urlObj.query["password"] = params["password"];
        }
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logs out current logged in user session
     */
    logoutUser(options: any = {}): FetchArgs {
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param username name that need to be deleted
     * @param body Updated user object
     */
    updateUser(params: {  username: string; body: User; }, options: any = {}): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling updateUser");
        }
        // verify required parameter "body" is set
        if (params["body"] == null) {
            throw new Error("Missing required parameter body when calling updateUser");
        }
        const baseUrl = `/user/{username}`
            .replace(`{${"username"}}`, `${ params["username"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }

        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param body Created user object
     */
    createUser(params: { body: User;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.createUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithArrayInput(params: { body: Array<User>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.createUsersWithArrayInput(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithListInput(params: { body: Array<User>;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.createUsersWithListInput(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param username The name that needs to be deleted
     */
    deleteUser(params: { username: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.deleteUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get user by user name
     * @param username The name that needs to be fetched. Use user1 for testing. 
     */
    getUserByName(params: { username: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.getUserByName(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logs user into the system
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: { username: string; password: string;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = UserApiFetchParamCreator.loginUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logs out current logged in user session
     */
    logoutUser(options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.logoutUser(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param username name that need to be deleted
     * @param body Updated user object
     */
    updateUser(params: { username: string; body: User;  }, options: any = {}): (fetch: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.updateUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param body Created user object
     */
    createUser(params: {  body: User; }, options: any = {}) {
        return UserApiFp.createUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithArrayInput(params: {  body: Array<User>; }, options: any = {}) {
        return UserApiFp.createUsersWithArrayInput(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithListInput(params: {  body: Array<User>; }, options: any = {}) {
        return UserApiFp.createUsersWithListInput(params, options)(this.fetch, this.basePath);
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param username The name that needs to be deleted
     */
    deleteUser(params: {  username: string; }, options: any = {}) {
        return UserApiFp.deleteUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get user by user name
     * @param username The name that needs to be fetched. Use user1 for testing. 
     */
    getUserByName(params: {  username: string; }, options: any = {}) {
        return UserApiFp.getUserByName(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logs user into the system
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: {  username: string; password: string; }, options: any = {}) {
        return UserApiFp.loginUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logs out current logged in user session
     */
    logoutUser(options: any = {}) {
        return UserApiFp.logoutUser(options)(this.fetch, this.basePath);
    }
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param username name that need to be deleted
     * @param body Updated user object
     */
    updateUser(params: {  username: string; body: User; }, options: any = {}) {
        return UserApiFp.updateUser(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param body Created user object
         */
        createUser(params: {  body: User; }, options: any = {}) {
            return UserApiFp.createUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param body List of user object
         */
        createUsersWithArrayInput(params: {  body: Array<User>; }, options: any = {}) {
            return UserApiFp.createUsersWithArrayInput(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param body List of user object
         */
        createUsersWithListInput(params: {  body: Array<User>; }, options: any = {}) {
            return UserApiFp.createUsersWithListInput(params, options)(fetch, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param username The name that needs to be deleted
         */
        deleteUser(params: {  username: string; }, options: any = {}) {
            return UserApiFp.deleteUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user by user name
         * @param username The name that needs to be fetched. Use user1 for testing. 
         */
        getUserByName(params: {  username: string; }, options: any = {}) {
            return UserApiFp.getUserByName(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs user into the system
         * @param username The user name for login
         * @param password The password for login in clear text
         */
        loginUser(params: {  username: string; password: string; }, options: any = {}) {
            return UserApiFp.loginUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs out current logged in user session
         */
        logoutUser(options: any = {}) {
            return UserApiFp.logoutUser(options)(fetch, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param username name that need to be deleted
         * @param body Updated user object
         */
        updateUser(params: {  username: string; body: User; }, options: any = {}) {
            return UserApiFp.updateUser(params, options)(fetch, basePath);
        },
    };
};

