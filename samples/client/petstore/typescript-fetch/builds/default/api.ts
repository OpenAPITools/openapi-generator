/**
 * Swagger Petstore
 * This is a sample server Petstore server.  You can find out more about Swagger at <a href=\"http://swagger.io\">http://swagger.io</a> or on irc.freenode.net, #swagger.  For this sample, you can use the api key \"special-key\" to test the authorization filters
 *
 * OpenAPI spec version: 1.0.0
 * Contact: apiteam@wordnik.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

import * as querystring from "querystring";
import * as url from "url";

import * as isomorphicFetch from "isomorphic-fetch";
import * as assign from "core-js/library/fn/object/assign";

interface Dictionary<T> { [index: string]: T; }
export interface FetchAPI { (url: string, init?: any): Promise<any>; }

const BASE_PATH = "http://petstore.swagger.io/v2".replace(/\/+$/, "");

export interface FetchArgs {
    url: string;
    options: any;
}

export class BaseAPI {
    basePath: string;
    fetch: FetchAPI;

    constructor(fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) {
        this.basePath = basePath;
        this.fetch = fetch;
    }
};

export interface Category {
    "id"?: number;
    "name"?: string;
}

export interface Order {
    "id"?: number;
    "petId"?: number;
    "quantity"?: number;
    "shipDate"?: Date;
    /**
     * Order Status
     */
    "status"?: OrderStatusEnum;
    "complete"?: boolean;
}

export type OrderStatusEnum = "placed" | "approved" | "delivered";
export interface Pet {
    "id"?: number;
    "category"?: Category;
    "name": string;
    "photoUrls": Array<string>;
    "tags"?: Array<Tag>;
    /**
     * pet status in the store
     */
    "status"?: PetStatusEnum;
}

export type PetStatusEnum = "available" | "pending" | "sold";
export interface Tag {
    "id"?: number;
    "name"?: string;
}

export interface User {
    "id"?: number;
    "username"?: string;
    "firstName"?: string;
    "lastName"?: string;
    "email"?: string;
    "password"?: string;
    "phone"?: string;
    /**
     * User Status
     */
    "userStatus"?: number;
}



/**
 * PetApi - fetch parameter creator
 */
export const PetApiFetchParamCreator = {
    /**
     * 
     * @summary Add a new pet to the store
     * @param body Pet object that needs to be added to the store
     */
    addPet(params: {  "body"?: Pet; }, options?: any): FetchArgs {
        const baseUrl = `/pet`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Deletes a pet
     * @param petId Pet id to delete
     * @param apiKey 
     */
    deletePet(params: {  "petId": number; "apiKey"?: string; }, options?: any): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling deletePet");
        }
        const baseUrl = `/pet/{petId}`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        fetchOptions.headers = assign({
            "api_key": params["apiKey"],
        }, contentTypeHeader, fetchOptions.headers);
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param status Status values that need to be considered for filter
     */
    findPetsByStatus(params: {  "status"?: Array<string>; }, options?: any): FetchArgs {
        const baseUrl = `/pet/findByStatus`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "status": params["status"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param tags Tags to filter by
     */
    findPetsByTags(params: {  "tags"?: Array<string>; }, options?: any): FetchArgs {
        const baseUrl = `/pet/findByTags`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "tags": params["tags"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns a pet when ID < 10.  ID > 10 or nonintegers will simulate API error conditions
     * @summary Find pet by ID
     * @param petId ID of pet that needs to be fetched
     */
    getPetById(params: {  "petId": number; }, options?: any): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling getPetById");
        }
        const baseUrl = `/pet/{petId}`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Update an existing pet
     * @param body Pet object that needs to be added to the store
     */
    updatePet(params: {  "body"?: Pet; }, options?: any): FetchArgs {
        const baseUrl = `/pet`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param petId ID of pet that needs to be updated
     * @param name Updated name of the pet
     * @param status Updated status of the pet
     */
    updatePetWithForm(params: {  "petId": string; "name"?: string; "status"?: string; }, options?: any): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling updatePetWithForm");
        }
        const baseUrl = `/pet/{petId}`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "name": params["name"],
            "status": params["status"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary uploads an image
     * @param petId ID of pet to update
     * @param additionalMetadata Additional data to pass to server
     * @param file file to upload
     */
    uploadFile(params: {  "petId": number; "additionalMetadata"?: string; "file"?: any; }, options?: any): FetchArgs {
        // verify required parameter "petId" is set
        if (params["petId"] == null) {
            throw new Error("Missing required parameter petId when calling uploadFile");
        }
        const baseUrl = `/pet/{petId}/uploadImage`
            .replace(`{${"petId"}}`, `${ params["petId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/x-www-form-urlencoded" };
        fetchOptions.body = querystring.stringify({
            "additionalMetadata": params["additionalMetadata"],
            "file": params["file"],
        });
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * PetApi - functional programming interface
 */
export const PetApiFp = {
    /**
     * 
     * @summary Add a new pet to the store
     * @param body Pet object that needs to be added to the store
     */
    addPet(params: { "body"?: Pet;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.addPet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Deletes a pet
     * @param petId Pet id to delete
     * @param apiKey 
     */
    deletePet(params: { "petId": number; "apiKey"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.deletePet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param status Status values that need to be considered for filter
     */
    findPetsByStatus(params: { "status"?: Array<string>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pet>> {
        const fetchArgs = PetApiFetchParamCreator.findPetsByStatus(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param tags Tags to filter by
     */
    findPetsByTags(params: { "tags"?: Array<string>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Pet>> {
        const fetchArgs = PetApiFetchParamCreator.findPetsByTags(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns a pet when ID < 10.  ID > 10 or nonintegers will simulate API error conditions
     * @summary Find pet by ID
     * @param petId ID of pet that needs to be fetched
     */
    getPetById(params: { "petId": number;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Pet> {
        const fetchArgs = PetApiFetchParamCreator.getPetById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Update an existing pet
     * @param body Pet object that needs to be added to the store
     */
    updatePet(params: { "body"?: Pet;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.updatePet(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param petId ID of pet that needs to be updated
     * @param name Updated name of the pet
     * @param status Updated status of the pet
     */
    updatePetWithForm(params: { "petId": string; "name"?: string; "status"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.updatePetWithForm(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary uploads an image
     * @param petId ID of pet to update
     * @param additionalMetadata Additional data to pass to server
     * @param file file to upload
     */
    uploadFile(params: { "petId": number; "additionalMetadata"?: string; "file"?: any;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = PetApiFetchParamCreator.uploadFile(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * PetApi - object-oriented interface
 */
export class PetApi extends BaseAPI {
    /**
     * 
     * @summary Add a new pet to the store
     * @param body Pet object that needs to be added to the store
     */
    addPet(params: {  "body"?: Pet; }, options?: any) {
        return PetApiFp.addPet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Deletes a pet
     * @param petId Pet id to delete
     * @param apiKey 
     */
    deletePet(params: {  "petId": number; "apiKey"?: string; }, options?: any) {
        return PetApiFp.deletePet(params, options)(this.fetch, this.basePath);
    }
    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds Pets by status
     * @param status Status values that need to be considered for filter
     */
    findPetsByStatus(params: {  "status"?: Array<string>; }, options?: any) {
        return PetApiFp.findPetsByStatus(params, options)(this.fetch, this.basePath);
    }
    /**
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @summary Finds Pets by tags
     * @param tags Tags to filter by
     */
    findPetsByTags(params: {  "tags"?: Array<string>; }, options?: any) {
        return PetApiFp.findPetsByTags(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a pet when ID < 10.  ID > 10 or nonintegers will simulate API error conditions
     * @summary Find pet by ID
     * @param petId ID of pet that needs to be fetched
     */
    getPetById(params: {  "petId": number; }, options?: any) {
        return PetApiFp.getPetById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Update an existing pet
     * @param body Pet object that needs to be added to the store
     */
    updatePet(params: {  "body"?: Pet; }, options?: any) {
        return PetApiFp.updatePet(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Updates a pet in the store with form data
     * @param petId ID of pet that needs to be updated
     * @param name Updated name of the pet
     * @param status Updated status of the pet
     */
    updatePetWithForm(params: {  "petId": string; "name"?: string; "status"?: string; }, options?: any) {
        return PetApiFp.updatePetWithForm(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary uploads an image
     * @param petId ID of pet to update
     * @param additionalMetadata Additional data to pass to server
     * @param file file to upload
     */
    uploadFile(params: {  "petId": number; "additionalMetadata"?: string; "file"?: any; }, options?: any) {
        return PetApiFp.uploadFile(params, options)(this.fetch, this.basePath);
    }
};

/**
 * PetApi - factory interface
 */
export const PetApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new pet to the store
         * @param body Pet object that needs to be added to the store
         */
        addPet(params: {  "body"?: Pet; }, options?: any) {
            return PetApiFp.addPet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a pet
         * @param petId Pet id to delete
         * @param apiKey 
         */
        deletePet(params: {  "petId": number; "apiKey"?: string; }, options?: any) {
            return PetApiFp.deletePet(params, options)(fetch, basePath);
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds Pets by status
         * @param status Status values that need to be considered for filter
         */
        findPetsByStatus(params: {  "status"?: Array<string>; }, options?: any) {
            return PetApiFp.findPetsByStatus(params, options)(fetch, basePath);
        },
        /**
         * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
         * @summary Finds Pets by tags
         * @param tags Tags to filter by
         */
        findPetsByTags(params: {  "tags"?: Array<string>; }, options?: any) {
            return PetApiFp.findPetsByTags(params, options)(fetch, basePath);
        },
        /**
         * Returns a pet when ID < 10.  ID > 10 or nonintegers will simulate API error conditions
         * @summary Find pet by ID
         * @param petId ID of pet that needs to be fetched
         */
        getPetById(params: {  "petId": number; }, options?: any) {
            return PetApiFp.getPetById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Update an existing pet
         * @param body Pet object that needs to be added to the store
         */
        updatePet(params: {  "body"?: Pet; }, options?: any) {
            return PetApiFp.updatePet(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a pet in the store with form data
         * @param petId ID of pet that needs to be updated
         * @param name Updated name of the pet
         * @param status Updated status of the pet
         */
        updatePetWithForm(params: {  "petId": string; "name"?: string; "status"?: string; }, options?: any) {
            return PetApiFp.updatePetWithForm(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary uploads an image
         * @param petId ID of pet to update
         * @param additionalMetadata Additional data to pass to server
         * @param file file to upload
         */
        uploadFile(params: {  "petId": number; "additionalMetadata"?: string; "file"?: any; }, options?: any) {
            return PetApiFp.uploadFile(params, options)(fetch, basePath);
        },
    };
};


/**
 * StoreApi - fetch parameter creator
 */
export const StoreApiFetchParamCreator = {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param orderId ID of the order that needs to be deleted
     */
    deleteOrder(params: {  "orderId": string; }, options?: any): FetchArgs {
        // verify required parameter "orderId" is set
        if (params["orderId"] == null) {
            throw new Error("Missing required parameter orderId when calling deleteOrder");
        }
        const baseUrl = `/store/order/{orderId}`
            .replace(`{${"orderId"}}`, `${ params["orderId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     */
    getInventory(options?: any): FetchArgs {
        const baseUrl = `/store/inventory`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param orderId ID of pet that needs to be fetched
     */
    getOrderById(params: {  "orderId": string; }, options?: any): FetchArgs {
        // verify required parameter "orderId" is set
        if (params["orderId"] == null) {
            throw new Error("Missing required parameter orderId when calling getOrderById");
        }
        const baseUrl = `/store/order/{orderId}`
            .replace(`{${"orderId"}}`, `${ params["orderId"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Place an order for a pet
     * @param body order placed for purchasing the pet
     */
    placeOrder(params: {  "body"?: Order; }, options?: any): FetchArgs {
        const baseUrl = `/store/order`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * StoreApi - functional programming interface
 */
export const StoreApiFp = {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param orderId ID of the order that needs to be deleted
     */
    deleteOrder(params: { "orderId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = StoreApiFetchParamCreator.deleteOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     */
    getInventory(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{ [key: string]: number; }> {
        const fetchArgs = StoreApiFetchParamCreator.getInventory(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param orderId ID of pet that needs to be fetched
     */
    getOrderById(params: { "orderId": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = StoreApiFetchParamCreator.getOrderById(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Place an order for a pet
     * @param body order placed for purchasing the pet
     */
    placeOrder(params: { "body"?: Order;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
        const fetchArgs = StoreApiFetchParamCreator.placeOrder(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * StoreApi - object-oriented interface
 */
export class StoreApi extends BaseAPI {
    /**
     * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
     * @summary Delete purchase order by ID
     * @param orderId ID of the order that needs to be deleted
     */
    deleteOrder(params: {  "orderId": string; }, options?: any) {
        return StoreApiFp.deleteOrder(params, options)(this.fetch, this.basePath);
    }
    /**
     * Returns a map of status codes to quantities
     * @summary Returns pet inventories by status
     */
    getInventory(options?: any) {
        return StoreApiFp.getInventory(options)(this.fetch, this.basePath);
    }
    /**
     * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param orderId ID of pet that needs to be fetched
     */
    getOrderById(params: {  "orderId": string; }, options?: any) {
        return StoreApiFp.getOrderById(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Place an order for a pet
     * @param body order placed for purchasing the pet
     */
    placeOrder(params: {  "body"?: Order; }, options?: any) {
        return StoreApiFp.placeOrder(params, options)(this.fetch, this.basePath);
    }
};

/**
 * StoreApi - factory interface
 */
export const StoreApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * For valid response try integer IDs with value < 1000. Anything above 1000 or nonintegers will generate API errors
         * @summary Delete purchase order by ID
         * @param orderId ID of the order that needs to be deleted
         */
        deleteOrder(params: {  "orderId": string; }, options?: any) {
            return StoreApiFp.deleteOrder(params, options)(fetch, basePath);
        },
        /**
         * Returns a map of status codes to quantities
         * @summary Returns pet inventories by status
         */
        getInventory(options?: any) {
            return StoreApiFp.getInventory(options)(fetch, basePath);
        },
        /**
         * For valid response try integer IDs with value <= 5 or > 10. Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param orderId ID of pet that needs to be fetched
         */
        getOrderById(params: {  "orderId": string; }, options?: any) {
            return StoreApiFp.getOrderById(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Place an order for a pet
         * @param body order placed for purchasing the pet
         */
        placeOrder(params: {  "body"?: Order; }, options?: any) {
            return StoreApiFp.placeOrder(params, options)(fetch, basePath);
        },
    };
};


/**
 * UserApi - fetch parameter creator
 */
export const UserApiFetchParamCreator = {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param body Created user object
     */
    createUser(params: {  "body"?: User; }, options?: any): FetchArgs {
        const baseUrl = `/user`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithArrayInput(params: {  "body"?: Array<User>; }, options?: any): FetchArgs {
        const baseUrl = `/user/createWithArray`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithListInput(params: {  "body"?: Array<User>; }, options?: any): FetchArgs {
        const baseUrl = `/user/createWithList`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "POST" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param username The name that needs to be deleted
     */
    deleteUser(params: {  "username": string; }, options?: any): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling deleteUser");
        }
        const baseUrl = `/user/{username}`
            .replace(`{${"username"}}`, `${ params["username"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "DELETE" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Get user by user name
     * @param username The name that needs to be fetched. Use user1 for testing. 
     */
    getUserByName(params: {  "username": string; }, options?: any): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling getUserByName");
        }
        const baseUrl = `/user/{username}`
            .replace(`{${"username"}}`, `${ params["username"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logs user into the system
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: {  "username"?: string; "password"?: string; }, options?: any): FetchArgs {
        const baseUrl = `/user/login`;
        let urlObj = url.parse(baseUrl, true);
        urlObj.query = assign({}, urlObj.query, {
            "username": params["username"],
            "password": params["password"],
        });
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * 
     * @summary Logs out current logged in user session
     */
    logoutUser(options?: any): FetchArgs {
        const baseUrl = `/user/logout`;
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "GET" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param username name that need to be deleted
     * @param body Updated user object
     */
    updateUser(params: {  "username": string; "body"?: User; }, options?: any): FetchArgs {
        // verify required parameter "username" is set
        if (params["username"] == null) {
            throw new Error("Missing required parameter username when calling updateUser");
        }
        const baseUrl = `/user/{username}`
            .replace(`{${"username"}}`, `${ params["username"] }`);
        let urlObj = url.parse(baseUrl, true);
        let fetchOptions: RequestInit = assign({}, { method: "PUT" }, options);

        let contentTypeHeader: Dictionary<string> = {};
        contentTypeHeader = { "Content-Type": "application/json" };
        if (params["body"]) {
            fetchOptions.body = JSON.stringify(params["body"] || {});
        }
        if (contentTypeHeader) {
            fetchOptions.headers = assign({}, contentTypeHeader, fetchOptions.headers);
        }
        return {
            url: url.format(urlObj),
            options: fetchOptions,
        };
    },
};

/**
 * UserApi - functional programming interface
 */
export const UserApiFp = {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param body Created user object
     */
    createUser(params: { "body"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.createUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithArrayInput(params: { "body"?: Array<User>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.createUsersWithArrayInput(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithListInput(params: { "body"?: Array<User>;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.createUsersWithListInput(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param username The name that needs to be deleted
     */
    deleteUser(params: { "username": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.deleteUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Get user by user name
     * @param username The name that needs to be fetched. Use user1 for testing. 
     */
    getUserByName(params: { "username": string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
        const fetchArgs = UserApiFetchParamCreator.getUserByName(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logs user into the system
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: { "username"?: string; "password"?: string;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
        const fetchArgs = UserApiFetchParamCreator.loginUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * 
     * @summary Logs out current logged in user session
     */
    logoutUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.logoutUser(options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param username name that need to be deleted
     * @param body Updated user object
     */
    updateUser(params: { "username": string; "body"?: User;  }, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
        const fetchArgs = UserApiFetchParamCreator.updateUser(params, options);
        return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
            return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response;
                } else {
                    throw response;
                }
            });
        };
    },
};

/**
 * UserApi - object-oriented interface
 */
export class UserApi extends BaseAPI {
    /**
     * This can only be done by the logged in user.
     * @summary Create user
     * @param body Created user object
     */
    createUser(params: {  "body"?: User; }, options?: any) {
        return UserApiFp.createUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithArrayInput(params: {  "body"?: Array<User>; }, options?: any) {
        return UserApiFp.createUsersWithArrayInput(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Creates list of users with given input array
     * @param body List of user object
     */
    createUsersWithListInput(params: {  "body"?: Array<User>; }, options?: any) {
        return UserApiFp.createUsersWithListInput(params, options)(this.fetch, this.basePath);
    }
    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param username The name that needs to be deleted
     */
    deleteUser(params: {  "username": string; }, options?: any) {
        return UserApiFp.deleteUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Get user by user name
     * @param username The name that needs to be fetched. Use user1 for testing. 
     */
    getUserByName(params: {  "username": string; }, options?: any) {
        return UserApiFp.getUserByName(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logs user into the system
     * @param username The user name for login
     * @param password The password for login in clear text
     */
    loginUser(params: {  "username"?: string; "password"?: string; }, options?: any) {
        return UserApiFp.loginUser(params, options)(this.fetch, this.basePath);
    }
    /**
     * 
     * @summary Logs out current logged in user session
     */
    logoutUser(options?: any) {
        return UserApiFp.logoutUser(options)(this.fetch, this.basePath);
    }
    /**
     * This can only be done by the logged in user.
     * @summary Updated user
     * @param username name that need to be deleted
     * @param body Updated user object
     */
    updateUser(params: {  "username": string; "body"?: User; }, options?: any) {
        return UserApiFp.updateUser(params, options)(this.fetch, this.basePath);
    }
};

/**
 * UserApi - factory interface
 */
export const UserApiFactory = function (fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This can only be done by the logged in user.
         * @summary Create user
         * @param body Created user object
         */
        createUser(params: {  "body"?: User; }, options?: any) {
            return UserApiFp.createUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param body List of user object
         */
        createUsersWithArrayInput(params: {  "body"?: Array<User>; }, options?: any) {
            return UserApiFp.createUsersWithArrayInput(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Creates list of users with given input array
         * @param body List of user object
         */
        createUsersWithListInput(params: {  "body"?: Array<User>; }, options?: any) {
            return UserApiFp.createUsersWithListInput(params, options)(fetch, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param username The name that needs to be deleted
         */
        deleteUser(params: {  "username": string; }, options?: any) {
            return UserApiFp.deleteUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user by user name
         * @param username The name that needs to be fetched. Use user1 for testing. 
         */
        getUserByName(params: {  "username": string; }, options?: any) {
            return UserApiFp.getUserByName(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs user into the system
         * @param username The user name for login
         * @param password The password for login in clear text
         */
        loginUser(params: {  "username"?: string; "password"?: string; }, options?: any) {
            return UserApiFp.loginUser(params, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs out current logged in user session
         */
        logoutUser(options?: any) {
            return UserApiFp.logoutUser(options)(fetch, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Updated user
         * @param username name that need to be deleted
         * @param body Updated user object
         */
        updateUser(params: {  "username": string; "body"?: User; }, options?: any) {
            return UserApiFp.updateUser(params, options)(fetch, basePath);
        },
    };
};

