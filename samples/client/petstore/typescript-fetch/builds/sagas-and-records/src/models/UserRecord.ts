/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import {ApiRecordUtils, knownRecordFactories} from "../runtimeSagasAndRecords";
import {getApiEntitiesState} from "../ApiEntitiesSelectors"
import {List, Record, RecordOf, Map} from 'immutable';
import {Schema, schema, NormalizedSchema} from "normalizr";
import {select, call} from "redux-saga/effects";

import {
    User,
} from './User';



export const UserRecordProps = {
    recType: "UserApiRecord" as "UserApiRecord",
    id: "-1",
    username: null as string | null,
    firstName: null as string | null,
    lastName: null as string | null,
    email: null as string | null,
    password: null as string | null,
    phone: null as string | null,
    userStatus: null as number | null,
    subUser: null as User | null,
    subUser2: {} as any as User,
};

export type UserRecordPropsType = typeof UserRecordProps;
export const UserRecord = Record(UserRecordProps, UserRecordProps.recType);
export type UserRecord = RecordOf<UserRecordPropsType>;

knownRecordFactories.set(UserRecordProps.recType, UserRecord);

export const UserRecordEntityProps = {
    ...UserRecordProps,
    recType: "UserApiRecordEntity" as "UserApiRecordEntity",
};

export type UserRecordEntityPropsType = typeof UserRecordEntityProps;
export const UserRecordEntity = Record(UserRecordEntityProps, UserRecordEntityProps.recType);
export type UserRecordEntity = RecordOf<UserRecordEntityPropsType>;

knownRecordFactories.set(UserRecordEntityProps.recType, UserRecordEntity);

class UserRecordUtils extends ApiRecordUtils<User, UserRecord> {
    public normalize(apiObject: User, asEntity?: boolean): User {
        (apiObject as any).recType = asEntity ? UserRecordEntityProps.recType : UserRecordProps.recType;
        (apiObject as any).id = apiObject.id.toString();
        return apiObject;
    }

    public getSchema(): Schema {
        return new schema.Entity("user", {
        });
    }

    public *toInlined(entityId?: string | null) {
        if (!entityId) {return undefined; }
        const entity = yield select(apiEntityUserSelector, {id: entityId});
        if (!entity) {return undefined; }

        const {
            recType,
		    ...unchangedProperties
		} = entity;

        const entityProperties = {
        }

        return UserRecord({
            ...unchangedProperties,
            ...entityProperties
        });
    }

    public *toInlinedArray(entityIds: List<string> | null) {
        if (!entityIds) {return null; }
        let entities = List<UserRecord>();
        for (let entityIndex = 0; entityIndex < entityIds.count(); entityIndex++) {
            const entity = yield call(this.toInlined, entityIds.get(entityIndex));
            if (entity) {
                entities.push(entity);
            }
        }
        return entities;
    }

    public toApi(record: UserRecord): User {
        const apiObject = super.toApi(record);
        apiObject.id = parseFloat(record.id);
        return apiObject;
    }
}

export const userRecordUtils = new UserRecordUtils();

export const apiEntitiesUserSelector = (state: any) => getApiEntitiesState(state).user as Map<string, UserRecordEntity>;
export const apiEntityUserSelector = (state: any, {id}: {id?: string | null}) => id ? apiEntitiesUserSelector(state).get(id) : undefined;

