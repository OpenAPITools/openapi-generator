#
# OpenAPI Petstore
# This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: "" \
# Version: 1.0.0
# Generated by OpenAPI Generator: https://openapi-generator.tech
#

<#
.SYNOPSIS

No summary available.

.DESCRIPTION

No description available.

.PARAMETER Integer
No description available.
.PARAMETER Int32
No description available.
.PARAMETER Int64
No description available.
.PARAMETER Number
No description available.
.PARAMETER Float
No description available.
.PARAMETER Double
No description available.
.PARAMETER Decimal
No description available.
.PARAMETER String
No description available.
.PARAMETER Byte
No description available.
.PARAMETER Binary
No description available.
.PARAMETER Date
No description available.
.PARAMETER DateTime
No description available.
.PARAMETER Uuid
No description available.
.PARAMETER Password
No description available.
.PARAMETER PatternWithDigits
A string that is a 10 digit number. Can have leading zeros.
.PARAMETER PatternWithDigitsAndDelimiter
A string starting with 'image_' (case insensitive) and one to three digits following i.e. Image_01.
.OUTPUTS

FormatTest<PSCustomObject>
#>

function Initialize-PSFormatTest {
    [CmdletBinding()]
    Param (
        [Parameter(Position = 0, ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${Integer},
        [Parameter(Position = 1, ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int32]]
        ${Int32},
        [Parameter(Position = 2, ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Int64]]
        ${Int64},
        [Parameter(Position = 3, ValueFromPipelineByPropertyName = $true)]
        [Decimal]
        ${Number},
        [Parameter(Position = 4, ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Double]]
        ${Float},
        [Parameter(Position = 5, ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Double]]
        ${Double},
        [Parameter(Position = 6, ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[Decimal]]
        ${Decimal},
        [Parameter(Position = 7, ValueFromPipelineByPropertyName = $true)]
        [ValidatePattern("/[a-z]/i")]
        [String]
        ${String},
        [Parameter(Position = 8, ValueFromPipelineByPropertyName = $true)]
        [PSCustomObject]
        ${Byte},
        [Parameter(Position = 9, ValueFromPipelineByPropertyName = $true)]
        [System.IO.FileInfo]
        ${Binary},
        [Parameter(Position = 10, ValueFromPipelineByPropertyName = $true)]
        [System.DateTime]
        ${Date},
        [Parameter(Position = 11, ValueFromPipelineByPropertyName = $true)]
        [System.Nullable[System.DateTime]]
        ${DateTime},
        [Parameter(Position = 12, ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Uuid},
        [Parameter(Position = 13, ValueFromPipelineByPropertyName = $true)]
        [String]
        ${Password},
        [Parameter(Position = 14, ValueFromPipelineByPropertyName = $true)]
        [ValidatePattern("^\d{10}$")]
        [String]
        ${PatternWithDigits},
        [Parameter(Position = 15, ValueFromPipelineByPropertyName = $true)]
        [ValidatePattern("/^image_\d{1,3}$/i")]
        [String]
        ${PatternWithDigitsAndDelimiter}
    )

    Process {
        'Creating PSCustomObject: PSPetstore => PSFormatTest' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        if ($Integer -and $Integer -gt 100) {
          throw "invalid value for 'Integer', must be smaller than or equal to 100."
        }

        if ($Integer -and $Integer -lt 10) {
          throw "invalid value for 'Integer', must be greater than or equal to 10."
        }

        if ($Int32 -and $Int32 -gt 200) {
          throw "invalid value for 'Int32', must be smaller than or equal to 200."
        }

        if ($Int32 -and $Int32 -lt 20) {
          throw "invalid value for 'Int32', must be greater than or equal to 20."
        }

        if ($null -eq $Number) {
            throw "invalid value for 'Number', 'Number' cannot be null."
        }

        if ($Number -gt 543.2) {
          throw "invalid value for 'Number', must be smaller than or equal to 543.2."
        }

        if ($Number -lt 32.1) {
          throw "invalid value for 'Number', must be greater than or equal to 32.1."
        }

        if ($Float -and $Float -gt 987.6) {
          throw "invalid value for 'Float', must be smaller than or equal to 987.6."
        }

        if ($Float -and $Float -lt 54.3) {
          throw "invalid value for 'Float', must be greater than or equal to 54.3."
        }

        if ($Double -and $Double -gt 123.4) {
          throw "invalid value for 'Double', must be smaller than or equal to 123.4."
        }

        if ($Double -and $Double -lt 67.8) {
          throw "invalid value for 'Double', must be greater than or equal to 67.8."
        }

        if ($null -eq $Byte) {
            throw "invalid value for 'Byte', 'Byte' cannot be null."
        }

        if ($null -eq $Date) {
            throw "invalid value for 'Date', 'Date' cannot be null."
        }

        if ($null -eq $Password) {
            throw "invalid value for 'Password', 'Password' cannot be null."
        }

        if ($Password.length -gt 64) {
            throw "invalid value for 'Password', the character length must be smaller than or equal to 64."
        }

        if ($Password.length -lt 10) {
            throw "invalid value for 'Password', the character length must be great than or equal to 10."
        }


        $PSO = [PSCustomObject]@{
            "integer" = ${Integer}
            "int32" = ${Int32}
            "int64" = ${Int64}
            "number" = ${Number}
            "float" = ${Float}
            "double" = ${Double}
            "decimal" = ${Decimal}
            "string" = ${String}
            "byte" = ${Byte}
            "binary" = ${Binary}
            "date" = ${Date}
            "dateTime" = ${DateTime}
            "uuid" = ${Uuid}
            "password" = ${Password}
            "pattern_with_digits" = ${PatternWithDigits}
            "pattern_with_digits_and_delimiter" = ${PatternWithDigitsAndDelimiter}
        }


        return $PSO
    }
}

<#
.SYNOPSIS

Convert from JSON to FormatTest<PSCustomObject>

.DESCRIPTION

Convert from JSON to FormatTest<PSCustomObject>

.PARAMETER Json

Json object

.OUTPUTS

FormatTest<PSCustomObject>
#>
function ConvertFrom-PSJsonToFormatTest {
    Param(
        [AllowEmptyString()]
        [string]$Json
    )

    Process {
        'Converting JSON to PSCustomObject: PSPetstore => PSFormatTest' | Write-Debug
        $PSBoundParameters | Out-DebugParameter | Write-Debug

        $JsonParameters = ConvertFrom-Json -InputObject $Json

        # check if Json contains properties not defined in PSFormatTest
        $AllProperties = ("integer", "int32", "int64", "number", "float", "double", "decimal", "string", "byte", "binary", "date", "dateTime", "uuid", "password", "pattern_with_digits", "pattern_with_digits_and_delimiter")
        foreach ($name in $JsonParameters.PsObject.Properties.Name) {
            if (!($AllProperties.Contains($name))) {
                throw "Error! JSON key '$name' not found in the properties: $($AllProperties)"
            }
        }

        If ([string]::IsNullOrEmpty($Json) -or $Json -eq "{}") { # empty json
            throw "Error! Empty JSON cannot be serialized due to the required property 'number' missing."
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "number"))) {
            throw "Error! JSON cannot be serialized due to the required property 'number' missing."
        } else {
            $Number = $JsonParameters.PSobject.Properties["number"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "byte"))) {
            throw "Error! JSON cannot be serialized due to the required property 'byte' missing."
        } else {
            $Byte = $JsonParameters.PSobject.Properties["byte"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "date"))) {
            throw "Error! JSON cannot be serialized due to the required property 'date' missing."
        } else {
            $Date = $JsonParameters.PSobject.Properties["date"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "password"))) {
            throw "Error! JSON cannot be serialized due to the required property 'password' missing."
        } else {
            $Password = $JsonParameters.PSobject.Properties["password"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "integer"))) { #optional property not found
            $Integer = $null
        } else {
            $Integer = $JsonParameters.PSobject.Properties["integer"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "int32"))) { #optional property not found
            $Int32 = $null
        } else {
            $Int32 = $JsonParameters.PSobject.Properties["int32"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "int64"))) { #optional property not found
            $Int64 = $null
        } else {
            $Int64 = $JsonParameters.PSobject.Properties["int64"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "float"))) { #optional property not found
            $Float = $null
        } else {
            $Float = $JsonParameters.PSobject.Properties["float"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "double"))) { #optional property not found
            $Double = $null
        } else {
            $Double = $JsonParameters.PSobject.Properties["double"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "decimal"))) { #optional property not found
            $Decimal = $null
        } else {
            $Decimal = $JsonParameters.PSobject.Properties["decimal"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "string"))) { #optional property not found
            $String = $null
        } else {
            $String = $JsonParameters.PSobject.Properties["string"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "binary"))) { #optional property not found
            $Binary = $null
        } else {
            $Binary = $JsonParameters.PSobject.Properties["binary"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "dateTime"))) { #optional property not found
            $DateTime = $null
        } else {
            $DateTime = $JsonParameters.PSobject.Properties["dateTime"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "uuid"))) { #optional property not found
            $Uuid = $null
        } else {
            $Uuid = $JsonParameters.PSobject.Properties["uuid"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "pattern_with_digits"))) { #optional property not found
            $PatternWithDigits = $null
        } else {
            $PatternWithDigits = $JsonParameters.PSobject.Properties["pattern_with_digits"].value
        }

        if (!([bool]($JsonParameters.PSobject.Properties.name -match "pattern_with_digits_and_delimiter"))) { #optional property not found
            $PatternWithDigitsAndDelimiter = $null
        } else {
            $PatternWithDigitsAndDelimiter = $JsonParameters.PSobject.Properties["pattern_with_digits_and_delimiter"].value
        }

        $PSO = [PSCustomObject]@{
            "integer" = ${Integer}
            "int32" = ${Int32}
            "int64" = ${Int64}
            "number" = ${Number}
            "float" = ${Float}
            "double" = ${Double}
            "decimal" = ${Decimal}
            "string" = ${String}
            "byte" = ${Byte}
            "binary" = ${Binary}
            "date" = ${Date}
            "dateTime" = ${DateTime}
            "uuid" = ${Uuid}
            "password" = ${Password}
            "pattern_with_digits" = ${PatternWithDigits}
            "pattern_with_digits_and_delimiter" = ${PatternWithDigitsAndDelimiter}
        }

        return $PSO
    }

}

