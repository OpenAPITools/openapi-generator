/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.apis

import org.openapitools.client.models.ApiResponse
import org.openapitools.client.models.Pet

import org.openapitools.client.infrastructure.*
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import io.ktor.client.request.forms.FormPart
import io.ktor.client.utils.EmptyContent
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.Serializable
import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.builtins.list
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

class PetApi constructor(
    baseUrl: kotlin.String = "http://petstore.swagger.io/v2",
    httpClientEngine: HttpClientEngine? = null,
    json: Json = Json {},
) : ApiClientBase(baseUrl, httpClientEngine, json) {
    /**
     * Add a new pet to the store
     * 
     * @param body Pet object that needs to be added to the store 
     * @return void
     */
    suspend fun addPet(
        body: Pet
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>("petstore_auth")

        val bodyOag = body

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.POST,
            "/pet",
            queries = queriesOag,
            headers = headersOag
        )

        return jsonRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }


    /**
     * Deletes a pet
     * 
     * @param petId Pet id to delete 
     * @param apiKey  (optional)
     * @return void
     */
    suspend fun deletePet(
        petId: kotlin.Long,
        apiKey: kotlin.String? = null
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>("petstore_auth")

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
            "api_key" to this?.toString()
        )

        val configOag = RequestConfig(
            RequestMethod.DELETE,
            "/pet/{petId}".replace("{" + "petId" + "}", petId.toString()),
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
    /**
     * Finds Pets by status
     * Multiple status values can be provided with comma separated strings
     * @param status Status values that need to be considered for filter 
     * @return kotlin.collections.List<Pet>
     */
    @Suppress("UNCHECKED_CAST")
    suspend fun findPetsByStatus(
        status: kotlin.collections.List<kotlin.String>
    ): HttpResponse<kotlin.collections.List<Pet>> {
        val authNamesOag = listOf<String>("petstore_auth")

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
            addMulti("status", status, "csv")
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.GET,
            "/pet/findByStatus",
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap<FindPetsByStatusResponse>().map { value }
    }
    @Serializable(with = FindPetsByStatusResponse.Companion::class)
    private class FindPetsByStatusResponse(val value: List<Pet>) {
        companion object : KSerializer<FindPetsByStatusResponse> {
            private val serializer = ListSerializer(Pet.serializer())
            override val descriptor = PrimitiveSerialDescriptor("FindPetsByStatusResponse", PrimitiveKind.STRING)

            override fun serialize(encoder: Encoder, value: FindPetsByStatusResponse): Unit =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder): FindPetsByStatusResponse =
                FindPetsByStatusResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Finds Pets by tags
     * Multiple tags can be provided with comma separated strings. Use tag1, tag2, tag3 for testing.
     * @param tags Tags to filter by 
     * @return kotlin.collections.List<Pet>
     */
    @Suppress("UNCHECKED_CAST")
    suspend fun findPetsByTags(
        tags: kotlin.collections.List<kotlin.String>
    ): HttpResponse<kotlin.collections.List<Pet>> {
        val authNamesOag = listOf<String>("petstore_auth")

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
            addMulti("tags", tags, "csv")
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.GET,
            "/pet/findByTags",
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap<FindPetsByTagsResponse>().map { value }
    }
    @Serializable(with = FindPetsByTagsResponse.Companion::class)
    private class FindPetsByTagsResponse(val value: List<Pet>) {
        companion object : KSerializer<FindPetsByTagsResponse> {
            private val serializer = ListSerializer(Pet.serializer())
            override val descriptor = PrimitiveSerialDescriptor("FindPetsByTagsResponse", PrimitiveKind.STRING)

            override fun serialize(encoder: Encoder, value: FindPetsByTagsResponse): Unit =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder): FindPetsByTagsResponse =
                FindPetsByTagsResponse(serializer.deserialize(decoder))
        }
    }

    /**
     * Find pet by ID
     * Returns a single pet
     * @param petId ID of pet to return 
     * @return Pet
     */
    @Suppress("UNCHECKED_CAST")
    suspend fun getPetById(
        petId: kotlin.Long
    ): HttpResponse<Pet> {
        val authNamesOag = listOf<String>("api_key")

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.GET,
            "/pet/{petId}".replace("{" + "petId" + "}", petId.toString()),
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
    /**
     * Update an existing pet
     * 
     * @param body Pet object that needs to be added to the store 
     * @return void
     */
    suspend fun updatePet(
        body: Pet
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>("petstore_auth")

        val bodyOag = body

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.PUT,
            "/pet",
            queries = queriesOag,
            headers = headersOag
        )

        return jsonRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }


    /**
     * Updates a pet in the store with form data
     * 
     * @param petId ID of pet that needs to be updated 
     * @param name Updated name of the pet (optional)
     * @param status Updated status of the pet (optional)
     * @return void
     */
    suspend fun updatePetWithForm(
        petId: kotlin.Long,
        name: kotlin.String? = null,
        status: kotlin.String? = null
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>("petstore_auth")

        val bodyOag = 
            ParametersBuilder().also {
                name?.apply { it.append("name", name.toString()) }
                status?.apply { it.append("status", status.toString()) }
            }.build()

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.POST,
            "/pet/{petId}".replace("{" + "petId" + "}", petId.toString()),
            queries = queriesOag,
            headers = headersOag
        )

        return urlEncodedFormRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
    /**
     * uploads an image
     * 
     * @param petId ID of pet to update 
     * @param additionalMetadata Additional data to pass to server (optional)
     * @param file file to upload (optional)
     * @return ApiResponse
     */
    @Suppress("UNCHECKED_CAST")
    suspend fun uploadFile(
        petId: kotlin.Long,
        additionalMetadata: kotlin.String? = null,
        file: io.ktor.client.request.forms.InputProvider? = null
    ): HttpResponse<ApiResponse> {
        val authNamesOag = listOf<String>("petstore_auth")

        val bodyOag = 
            formData {
                additionalMetadata?.let { append(FormPart("additionalMetadata", additionalMetadata)) }
                file?.let { append(FormPart("file", file)) }
            }

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.POST,
            "/pet/{petId}/uploadImage".replace("{" + "petId" + "}", petId.toString()),
            queries = queriesOag,
            headers = headersOag
        )

        return multipartFormRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
}
