/**
 * OpenAPI Petstore
 * This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.apis

import org.openapitools.client.models.User

import org.openapitools.client.infrastructure.*
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import io.ktor.client.request.forms.FormPart
import io.ktor.client.utils.EmptyContent
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.Serializable
import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.builtins.list
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

class UserApi constructor(
    baseUrl: kotlin.String = "http://petstore.swagger.io/v2",
    httpClientEngine: HttpClientEngine? = null,
    json: Json = Json {},
) : ApiClientBase(baseUrl, httpClientEngine, json) {
    /**
     * Create user
     * This can only be done by the logged in user.
     * @param body Created user object 
     * @return void
     */
    suspend fun createUser(
        body: User
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>()

        val bodyOag = body

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.POST,
            "/user",
            queries = queriesOag,
            headers = headersOag
        )

        return jsonRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }


    /**
     * Creates list of users with given input array
     * 
     * @param body List of user object 
     * @return void
     */
    suspend fun createUsersWithArrayInput(
        body: kotlin.collections.List<User>
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>()

        val bodyOag = CreateUsersWithArrayInputRequest(body)

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.POST,
            "/user/createWithArray",
            queries = queriesOag,
            headers = headersOag
        )

        return jsonRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }

    @Serializable(with = CreateUsersWithArrayInputRequest.Companion::class)
    private class CreateUsersWithArrayInputRequest(val value: List<User>) {
        companion object : KSerializer<CreateUsersWithArrayInputRequest> {
            private val serializer = ListSerializer(User.serializer())
            override val descriptor = PrimitiveSerialDescriptor("CreateUsersWithArrayInputRequest", PrimitiveKind.STRING)

            override fun serialize(encoder: Encoder, value: CreateUsersWithArrayInputRequest): Unit =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder): CreateUsersWithArrayInputRequest =
                CreateUsersWithArrayInputRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Creates list of users with given input array
     * 
     * @param body List of user object 
     * @return void
     */
    suspend fun createUsersWithListInput(
        body: kotlin.collections.List<User>
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>()

        val bodyOag = CreateUsersWithListInputRequest(body)

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.POST,
            "/user/createWithList",
            queries = queriesOag,
            headers = headersOag
        )

        return jsonRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }

    @Serializable(with = CreateUsersWithListInputRequest.Companion::class)
    private class CreateUsersWithListInputRequest(val value: List<User>) {
        companion object : KSerializer<CreateUsersWithListInputRequest> {
            private val serializer = ListSerializer(User.serializer())
            override val descriptor = PrimitiveSerialDescriptor("CreateUsersWithListInputRequest", PrimitiveKind.STRING)

            override fun serialize(encoder: Encoder, value: CreateUsersWithListInputRequest): Unit =
                serializer.serialize(encoder, value.value)

            override fun deserialize(decoder: Decoder): CreateUsersWithListInputRequest =
                CreateUsersWithListInputRequest(serializer.deserialize(decoder))
        }
    }

    /**
     * Delete user
     * This can only be done by the logged in user.
     * @param username The name that needs to be deleted 
     * @return void
     */
    suspend fun deleteUser(
        username: kotlin.String
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>()

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.DELETE,
            "/user/{username}".replace("{" + "username" + "}", username.toString()),
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
    /**
     * Get user by user name
     * 
     * @param username The name that needs to be fetched. Use user1 for testing. 
     * @return User
     */
    @Suppress("UNCHECKED_CAST")
    suspend fun getUserByName(
        username: kotlin.String
    ): HttpResponse<User> {
        val authNamesOag = listOf<String>()

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.GET,
            "/user/{username}".replace("{" + "username" + "}", username.toString()),
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
    /**
     * Logs user into the system
     * 
     * @param username The user name for login 
     * @param password The password for login in clear text 
     * @return kotlin.String
     */
    @Suppress("UNCHECKED_CAST")
    suspend fun loginUser(
        username: kotlin.String,
        password: kotlin.String
    ): HttpResponse<kotlin.String> {
        val authNamesOag = listOf<String>()

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
            add("username", username)
            add("password", password)
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.GET,
            "/user/login",
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
    /**
     * Logs out current logged in user session
     * 
     * @return void
     */
    suspend fun logoutUser(
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>()

        val bodyOag = 
            EmptyContent

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.GET,
            "/user/logout",
            queries = queriesOag,
            headers = headersOag
        )

        return request(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }
    /**
     * Updated user
     * This can only be done by the logged in user.
     * @param username name that need to be deleted 
     * @param body Updated user object 
     * @return void
     */
    suspend fun updateUser(
        username: kotlin.String,
        body: User
    ): HttpResponse<Unit> {
        val authNamesOag = listOf<String>()

        val bodyOag = body

        val queriesOag = Queries {
        }

        val headersOag = mutableMapOf<String, String?>(
        )

        val configOag = RequestConfig(
            RequestMethod.PUT,
            "/user/{username}".replace("{" + "username" + "}", username.toString()),
            queries = queriesOag,
            headers = headersOag
        )

        return jsonRequest(
            configOag,
            bodyOag,
            authNamesOag
        ).wrap()
    }


}
