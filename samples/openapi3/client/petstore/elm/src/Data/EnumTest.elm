{-
   OpenAPI Petstore
   This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\

   OpenAPI spec version: 1.0.0

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git
   Do not edit this file manually.
-}


module Data.EnumTest exposing (EnumInteger(..), EnumNumber(..), EnumString(..), EnumStringRequired(..), EnumTest, decoder, encoder)

import Data.OuterEnum as OuterEnum exposing (OuterEnum)
import Json.Decode as Decode exposing (Decoder)
import Json.Decode.Pipeline exposing (optional, required)
import Json.Encode as Encode


type alias EnumTest =
    { enum_string : Maybe EnumString
    , enum_string_required : EnumStringRequired
    , enum_integer : Maybe EnumInteger
    , enum_number : Maybe EnumNumber
    , outerEnum : Maybe OuterEnum
    }


type EnumString
    = UPPER
    | Lower
    | Empty


type EnumStringRequired
    = UPPER
    | Lower
    | Empty


type EnumInteger
    = N1
    | N_1


type EnumNumber
    = N1Dot1
    | N_1Dot2


decoder : Decoder EnumTest
decoder =
    Decode.succeed EnumTest
        |> optional "enum_string" (Decode.nullable enumStringDecoder) Nothing
        |> required "enum_string_required" enumStringRequiredDecoder
        |> optional "enum_integer" (Decode.nullable enumIntegerDecoder) Nothing
        |> optional "enum_number" (Decode.nullable enumNumberDecoder) Nothing
        |> optional "outerEnum" (Decode.nullable OuterEnum.decoder) Nothing


encoder : EnumTest -> Encode.Value
encoder model =
    Encode.object
        [ ( "enum_string", Maybe.withDefault Encode.null (Maybe.map enumStringEncoder model.enum_string) )
        , ( "enum_string_required", enumStringRequiredEncoder model.enum_string_required )
        , ( "enum_integer", Maybe.withDefault Encode.null (Maybe.map enumIntegerEncoder model.enum_integer) )
        , ( "enum_number", Maybe.withDefault Encode.null (Maybe.map enumNumberEncoder model.enum_number) )
        , ( "outerEnum", Maybe.withDefault Encode.null (Maybe.map OuterEnum.encoder model.outerEnum) )
        ]


enumStringDecoder : Decoder EnumString
enumStringDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "UPPER" ->
                        Decode.succeed UPPER

                    "lower" ->
                        Decode.succeed Lower

                    "" ->
                        Decode.succeed Empty

                    other ->
                        Decode.fail <| "Unknown type: " ++ other
            )


enumStringEncoder : EnumString -> Encode.Value
enumStringEncoder model =
    case model of
        UPPER ->
            Encode.string "UPPER"

        Lower ->
            Encode.string "lower"

        Empty ->
            Encode.string ""


enumStringRequiredDecoder : Decoder EnumStringRequired
enumStringRequiredDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "UPPER" ->
                        Decode.succeed UPPER

                    "lower" ->
                        Decode.succeed Lower

                    "" ->
                        Decode.succeed Empty

                    other ->
                        Decode.fail <| "Unknown type: " ++ other
            )


enumStringRequiredEncoder : EnumStringRequired -> Encode.Value
enumStringRequiredEncoder model =
    case model of
        UPPER ->
            Encode.string "UPPER"

        Lower ->
            Encode.string "lower"

        Empty ->
            Encode.string ""


enumIntegerDecoder : Decoder EnumInteger
enumIntegerDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "1" ->
                        Decode.succeed N1

                    "-1" ->
                        Decode.succeed N_1

                    other ->
                        Decode.fail <| "Unknown type: " ++ other
            )


enumIntegerEncoder : EnumInteger -> Encode.Value
enumIntegerEncoder model =
    case model of
        N1 ->
            Encode.string "1"

        N_1 ->
            Encode.string "-1"


enumNumberDecoder : Decoder EnumNumber
enumNumberDecoder =
    Decode.string
        |> Decode.andThen
            (\str ->
                case str of
                    "1.1" ->
                        Decode.succeed N1Dot1

                    "-1.2" ->
                        Decode.succeed N_1Dot2

                    other ->
                        Decode.fail <| "Unknown type: " ++ other
            )


enumNumberEncoder : EnumNumber -> Encode.Value
enumNumberEncoder model =
    case model of
        N1Dot1 ->
            Encode.string "1.1"

        N_1Dot2 ->
            Encode.string "-1.2"
