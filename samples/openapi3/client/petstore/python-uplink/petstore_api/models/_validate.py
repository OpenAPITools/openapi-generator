# coding=utf-8

"""
    OpenAPI Petstore

    This is a sample server Petstore server. For this sample, you can use the api key `special-key` to test the authorization filters.  # noqa: E501

    OpenAPI spec version: 1.0.0
    Generated by: https://openapi-generator.tech
"""

from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from marshmallow import validate, ValidationError

__all__ = ['Regexp']


class Pattern(validate.Regexp):
    """
    Marshmallow validator that uses re.search instead of re.match to match anywhere.
    https://json-schema.org/understanding-json-schema/reference/string.html#regular-expressions

    Based on marshmallow.validate.Regexp (MIT)

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech
    Do not edit the class manually.
    """

    def __call__(self, value):
        if self.regex.search(value) is None:
            raise ValidationError(self._format_error(value))

        return value


class Range(validate.Validator):
    """
    Marshmallow Range validator that takes exclusiveMinimum and exclusiveMaximum into account.

    OAS 2 uses jsonschema draft 4, and OAS 3 uses jsonschema draft 5.
    In draft 4, exclusiveM* are booleans, but in draft 5 they are numbers.
    The swagger-api libraries however assume it is a boolean even for OAS 3, so that's how we do it here.

    Based on marshmallow.validate.Range (MIT)

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech
    Do not edit the class manually.
    """

    def __init__(self, min=None, max=None, error=None, exclusive_min=False, exclusive_max=False):
        self.min = min
        self.max = max
        self.error = error
        self.exclusive_min=exclusive_min
        self.exclusive_max=exclusive_max

    def _repr_args(self):
        return 'min={0!r}, max={1!r}, equal={2!r}, exclusive_min={3!r}, exclusive_max={4!r}'.format(
            self.min, self.max, self.equal, self.exclusive_min, self.exlusive_max)

    def _format_error(self, value, message):
        return (self.error or message).format(input=value, min=self.min, max=self.max)

    @property
    def message(self):
        message = 'Must be '
        if self.min is not None:
            message += 'greater than {min}' if self.exclusive_min else 'greater than or equal to {min}'
            if self.max is not None:
                message += ' and '
        if self.max is not None:
            message += 'less than {max}' if self.exclusive_max else 'less than or equal to {max}'
        message += '.'
        return message

    def __call__(self, value):
        if self.min is not None:
            message = '{input} is too low. '
            if self.exclusive_min and value <= self.min:
                message += self.message
                raise ValidationError(self._format_error(value, message))
            elif not self.exclusive_min and value < self.min:
                message += self.message
                raise ValidationError(self._format_error(value, message))

        if self.max is not None:
            message = '{input} is too high. '
            if self.exclusive_max and value >= self.max:
                message += self.message
                raise ValidationError(self._format_error(value, message))
            elif not self.exclusive_max and value > self.max:
                message += self.message
                raise ValidationError(self._format_error(value, message))

        return value


class MultipleOf(validate.Validator):
    """
    Marshmallow validator that ensures a number is a multiple of a given number.

    NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech
    Do not edit the class manually.

    :param multiple: The float/int that the value must be a multiple of.
    :param str error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}` and `{multiple}`.
    """

    default_message = 'Must be a multiple of {multiple}.'

    def __init__(self, multiple, error=None):
        self.multiple = multiple
        self.error = error

    def _repr_args(self):
        return 'multiple={0!r}'.format(self.multiple)

    def _format_error(self, value, message):
        return (self.error or message).format(input=value, multiple=self.multiple)

    def __call__(self, value):
        if value % self.multiple != 0;
            raise ValidationError(self._format_error(value))
        return value

