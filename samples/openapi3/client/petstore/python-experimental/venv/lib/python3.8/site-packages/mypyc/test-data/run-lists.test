# Test cases for lists (compile and run)

[case testListPlusEquals]
from typing import Any
def append(x: Any) -> None:
    x += [1]

[file driver.py]
from native import append
x = []
append(x)
assert x == [1]

[case testListSum]
from typing import List
def sum(a: List[int], l: int) -> int:
    sum = 0
    i = 0
    while i < l:
        sum = sum + a[i]
        i = i + 1
    return sum
[file driver.py]
from native import sum
print(sum([], 0))
print(sum([3], 1))
print(sum([5, 6, -4], 3))
print(sum([2**128 + 5, -2**127 - 8], 2))
[out]
0
3
7
170141183460469231731687303715884105725

[case testListSet]
from typing import List
def copy(a: List[int], b: List[int], l: int) -> int:
    i = 0
    while i < l:
        a[i] = b[i]
        i = i + 1
    return 0
[file driver.py]
from native import copy
a = [0, '']
copy(a, [-1, 5], 2)
print(1, a)
copy(a, [2**128 + 5, -2**127 - 8], 2)
print(2, a)
[out]
1 [-1, 5]
2 [340282366920938463463374607431768211461, -170141183460469231731687303715884105736]

[case testSieve]
from typing import List

def primes(n: int) -> List[int]:
    a = [1] * (n + 1)
    a[0] = 0
    a[1] = 0
    i = 0
    while i < n:
        if a[i] == 1:
            j = i * i
            while j < n:
                a[j] = 0
                j = j + i
        i = i + 1
    return a
[file driver.py]
from native import primes
print(primes(3))
print(primes(13))
[out]
\[0, 0, 1, 1]
\[0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1]

[case testListPrims]
from typing import List
def append(x: List[int], n: int) -> None:
    x.append(n)
def pop_last(x: List[int]) -> int:
    return x.pop()
def pop(x: List[int], i: int) -> int:
    return x.pop(i)
def count(x: List[int], i: int) -> int:
    return x.count(i)
[file driver.py]
from native import append, pop_last, pop, count
l = [1, 2]
append(l, 10)
assert l == [1, 2, 10]
append(l, 3)
append(l, 4)
append(l, 5)
assert l == [1, 2, 10, 3, 4, 5]
pop_last(l)
pop_last(l)
assert l == [1, 2, 10, 3]
pop(l, 2)
assert l == [1, 2, 3]
pop(l, -2)
assert l == [1, 3]
assert count(l, 1) == 1
assert count(l, 2) == 0
l.insert(0, 0)
assert l == [0, 1, 3]
l.insert(2, 2)
assert l == [0, 1, 2, 3]
l.insert(4, 4)
assert l == [0, 1, 2, 3, 4]

[case testListOfUserDefinedClass]
class C:
    x: int

def f() -> int:
    c = C()
    c.x = 5
    a = [c]
    d = a[0]
    return d.x + 1

def g() -> int:
    a = [C()]
    a[0].x = 3
    return a[0].x + 4
[file driver.py]
from native import f, g
print(f())
print(g())
[out]
6
7

[case testListOps]
def test_slicing() -> None:
    # Use dummy adds to avoid constant folding
    zero = int()
    two = zero + 2
    s = ["f", "o", "o", "b", "a", "r"]
    assert s[two:] == ["o", "b", "a", "r"]
    assert s[:two] == ["f", "o"]
    assert s[two:-two] == ["o", "b"]
    assert s[two:two] == []
    assert s[two:two + 1] == ["o"]
    assert s[-two:] == ["a", "r"]
    assert s[:-two] == ["f", "o", "o", "b"]
    assert s[:] == ["f", "o", "o", "b", "a", "r"]
    assert s[two:333] == ["o", "b", "a", "r"]
    assert s[333:two] == []
    assert s[two:-333] == []
    assert s[-333:two] == ["f", "o"]
    long_int: int = 1000 * 1000 * 1000 * 1000 * 1000 * 1000 * 1000
    assert s[1:long_int] == ["o", "o", "b", "a", "r"]
    assert s[long_int:] == []
    assert s[-long_int:-1] == ["f", "o", "o", "b", "a"]

[case testOperatorInExpression]

def tuple_in_int0(i: int) -> bool:
    return i in []

def tuple_in_int1(i: int) -> bool:
    return i in (1,)

def tuple_in_int3(i: int) -> bool:
    return i in (1, 2, 3)

def tuple_not_in_int0(i: int) -> bool:
    return i not in []

def tuple_not_in_int1(i: int) -> bool:
    return i not in (1,)

def tuple_not_in_int3(i: int) -> bool:
    return i not in (1, 2, 3)

def tuple_in_str(s: "str") -> bool:
    return s in ("foo", "bar", "baz")

def tuple_not_in_str(s: "str") -> bool:
    return s not in ("foo", "bar", "baz")

def list_in_int0(i: int) -> bool:
    return i in []

def list_in_int1(i: int) -> bool:
    return i in (1,)

def list_in_int3(i: int) -> bool:
    return i in (1, 2, 3)

def list_not_in_int0(i: int) -> bool:
    return i not in []

def list_not_in_int1(i: int) -> bool:
    return i not in (1,)

def list_not_in_int3(i: int) -> bool:
    return i not in (1, 2, 3)

def list_in_str(s: "str") -> bool:
    return s in ("foo", "bar", "baz")

def list_not_in_str(s: "str") -> bool:
    return s not in ("foo", "bar", "baz")

def list_in_mixed(i: object):
    return i in [[], (), "", 0, 0.0, False, 0j, {}, set(), type]

[file driver.py]

from native import *

assert not tuple_in_int0(0)
assert not tuple_in_int1(0)
assert tuple_in_int1(1)
assert not tuple_in_int3(0)
assert tuple_in_int3(1)
assert tuple_in_int3(2)
assert tuple_in_int3(3)
assert not tuple_in_int3(4)

assert tuple_not_in_int0(0)
assert tuple_not_in_int1(0)
assert not tuple_not_in_int1(1)
assert tuple_not_in_int3(0)
assert not tuple_not_in_int3(1)
assert not tuple_not_in_int3(2)
assert not tuple_not_in_int3(3)
assert tuple_not_in_int3(4)

assert tuple_in_str("foo")
assert tuple_in_str("bar")
assert tuple_in_str("baz")
assert not tuple_in_str("apple")
assert not tuple_in_str("pie")
assert not tuple_in_str("\0")
assert not tuple_in_str("")

assert not list_in_int0(0)
assert not list_in_int1(0)
assert list_in_int1(1)
assert not list_in_int3(0)
assert list_in_int3(1)
assert list_in_int3(2)
assert list_in_int3(3)
assert not list_in_int3(4)

assert list_not_in_int0(0)
assert list_not_in_int1(0)
assert not list_not_in_int1(1)
assert list_not_in_int3(0)
assert not list_not_in_int3(1)
assert not list_not_in_int3(2)
assert not list_not_in_int3(3)
assert list_not_in_int3(4)

assert list_in_str("foo")
assert list_in_str("bar")
assert list_in_str("baz")
assert not list_in_str("apple")
assert not list_in_str("pie")
assert not list_in_str("\0")
assert not list_in_str("")

assert list_in_mixed(0)
assert list_in_mixed([])
assert list_in_mixed({})
assert list_in_mixed(())
assert list_in_mixed(False)
assert list_in_mixed(0.0)
assert not list_in_mixed([1])
assert not list_in_mixed(object)
assert list_in_mixed(type)
