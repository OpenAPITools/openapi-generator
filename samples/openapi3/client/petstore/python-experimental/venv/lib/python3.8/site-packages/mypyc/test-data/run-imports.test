# Test cases for imports and related features (compile and run)

[case testImports]
import testmodule

def f(x: int) -> int:
    return testmodule.factorial(5)

def g(x: int) -> int:
    from welp import foo
    return foo(x)

def test_import_basics() -> None:
    assert f(5) == 120
    assert g(5) == 5

def test_import_submodule_within_function() -> None:
    import pkg.mod
    assert pkg.x == 1
    assert pkg.mod.y == 2

def test_import_as_submodule_within_function() -> None:
    import pkg.mod as mm
    assert mm.y == 2

# TODO: Don't add local imports to globals()
#
# def test_local_import_not_in_globals() -> None:
#     import nob
#     assert 'nob' not in globals()

def test_import_module_without_stub_in_function() -> None:
    # 'virtualenv' must not have a stub in typeshed for this test case
    import virtualenv  # type: ignore
    # TODO: We shouldn't add local imports to globals()
    # assert 'virtualenv' not in globals()
    assert isinstance(virtualenv.__name__, str)

def test_import_as_module_without_stub_in_function() -> None:
    # 'virtualenv' must not have a stub in typeshed for this test case
    import virtualenv as vv  # type: ignore
    assert 'virtualenv' not in globals()
    # TODO: We shouldn't add local imports to globals()
    # assert 'vv' not in globals()
    assert isinstance(vv.__name__, str)

[file testmodule.py]
def factorial(x: int) -> int:
    if x == 0:
        return 1
    else:
        return x * factorial(x-1)
[file welp.py]
def foo(x: int) -> int:
    return x
[file pkg/__init__.py]
x = 1
[file pkg/mod.py]
y = 2
[file nob.py]
z = 3

[case testImportMissing]
# The unchecked module is configured by the test harness to not be
# picked up by mypy, so we can test that we do that right thing when
# calling library modules without stubs.
import unchecked  # type: ignore
import unchecked as lol  # type: ignore
assert unchecked.x == 10
assert lol.x == 10
[file unchecked.py]
x = 10

[file driver.py]
import native

[case testFromImport]
from testmodule import g

def f(x: int) -> int:
    return g(x)
[file testmodule.py]
def g(x: int) -> int:
    return x + 1
[file driver.py]
from native import f
assert f(1) == 2

[case testReexport]
# Test that we properly handle accessing values that have been reexported
import a
def f(x: int) -> int:
    return a.g(x) + a.foo + a.b.foo

whatever = a.A()

[file a.py]
from b import g as g, A as A, foo as foo
import b

[file b.py]
def g(x: int) -> int:
    return x + 1

class A:
    pass

foo = 20

[file driver.py]
from native import f, whatever
import b

assert f(20) == 61
assert isinstance(whatever, b.A)

[case testAssignModule]
import a
assert a.x == 20
a.x = 10
[file a.py]
x = 20
[file driver.py]
import native
