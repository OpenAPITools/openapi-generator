# coding: utf-8

"""
    OpenAPI Petstore

    This spec is mainly for testing Petstore server and contains fake endpoints, models. Please do not use this for any other purpose. Special characters: \" \\  # noqa: E501

    The version of the OpenAPI document: 1.0.0
    Generated by: https://openapi-generator.tech
"""


import sys
import unittest

import petstore_api
from petstore_api.model.date_with_validations import DateWithValidations
from petstore_api.model.date_time_with_validations import DateTimeWithValidations
from petstore_api.model.string_with_validation import StringWithValidation
from petstore_api.model.integer_enum_one_value import IntegerEnumOneValue
from petstore_api.model.integer_enum import IntegerEnum
from petstore_api.model.integer_enum_big import IntegerEnumBig
from petstore_api.model.integer_max10 import IntegerMax10
from petstore_api.model.integer_min15 import IntegerMin15
from petstore_api.model.nullable_string import NullableString
from petstore_api.model_utils import AnyTypeSchema, combine_validations, Schema, Enum
from datetime import date, datetime


class TestCombineNonObjectSchemas(unittest.TestCase):

    def test_combine_schemas(self):
        """Test DateWithValidations"""

        cls_pair_by_expected_cls = {
            date: [DateWithValidations, AnyTypeSchema],
            datetime: [DateTimeWithValidations, AnyTypeSchema],
            str: [NullableString, StringWithValidation],
        }
        for expected_cls, cls_pair in cls_pair_by_expected_cls.items():
            new_cls = type("NewClass", tuple(cls_pair), {})
            assert new_cls._types == (expected_cls,)

            # order of base classes does not matter
            cls_pair.reverse()
            new_cls = type("NewClass", tuple(cls_pair), {})
            assert new_cls._types == (expected_cls,)

            if expected_cls is str:
                assert new_cls._nullable is False

    def test_string_combined_with_dateX_makes_dateX(self):
        class StringDate(StringWithValidation, DateWithValidations):
            pass

        assert StringDate._types == (date,)

        class StringDateTime(StringWithValidation, DateTimeWithValidations):
            pass

        assert StringDateTime._types == (datetime,)
        # validations also combined
        assert StringDateTime._validations == {'min_length': 7, 'regex': [{'pattern': '^2020.*'}]}

        # TODO test that min length is checked
        # TODO test that regex is checked

    def test_valid_enum_plus_prim(self):
        class EnumPlusPrim(IntegerMax10, IntegerEnumOneValue):
            pass

        assert EnumPlusPrim._enum_info_by_value == {0: ("POSITIVE_0", int),}

        # order of base classes does not matter
        class EnumPlusPrim(IntegerEnumOneValue, IntegerMax10):
            pass

        assert EnumPlusPrim._enum_info_by_value == {0: ("POSITIVE_0", int),}

        # _enum_by_value only contains one key
        assert set(EnumPlusPrim._enum_by_value) == {0}
        # the value is the expected enum class
        enum_value_cls = EnumPlusPrim._enum_by_value[0]
        assert issubclass(enum_value_cls, EnumPlusPrim)
        assert issubclass(enum_value_cls, int)
        assert issubclass(enum_value_cls, Enum)
        # the enum stored in that class is expected
        enum_value = enum_value_cls.POSITIVE_0
        assert isinstance(enum_value, EnumPlusPrim)
        assert isinstance(enum_value, int)
        assert isinstance(enum_value, Enum)
        # we can access this enum from our class
        assert EnumPlusPrim.POSITIVE_0 == enum_value

        # invalid value throws an exception
        with self.assertRaises(petstore_api.ApiValueError):
            EnumPlusPrim(9)

        # valid value succeeds
        val = EnumPlusPrim(0)
        assert val == 0
        assert isinstance(val, EnumPlusPrim)
        assert isinstance(val, int)
        assert isinstance(val, Enum)

    def test_invalid_enum_plus_enum(self):
        regex_err = (
            r"Cannot combine schemas.+?IntegerEnum.+?and.+?IntegerEnumBig.+?"
            r"in.+?InvalidEnumCombo.+?because their enums do not intersect"
        )
        with self.assertRaisesRegex(petstore_api.ApiValueError, regex_err):
            class InvalidEnumCombo(IntegerEnum, IntegerEnumBig):
                pass

    def test_invalid_validation_combination(self):
        regex_err = (
            r"Cannot combine schemas.+?IntegerMax10.+?and.+?IntegerMin15.+?"
            r"in.+?InvalidValidationCombo.+?because inclusive_maximum 10 is less than inclusive_minimum 15"
        )
        with self.assertRaisesRegex(petstore_api.ApiValueError, regex_err):
            class InvalidValidationCombo(IntegerMax10, IntegerMin15):
                pass

    def test_valid_enum_plus_enum(self):
        class IntegerOneEnum(IntegerEnum, IntegerEnumOneValue):
            pass

        assert IntegerOneEnum._enum_info_by_value == {0: ("POSITIVE_0", int),}

        # order of base classes does not matter
        class IntegerOneEnum(IntegerEnumOneValue, IntegerEnum):
            pass

        assert IntegerOneEnum._enum_info_by_value == {0: ("POSITIVE_0", int),}

        # _enum_by_value only contains one key
        assert set(IntegerOneEnum._enum_by_value) == {0}
        # the value is the expected enum class
        enum_value_cls = IntegerOneEnum._enum_by_value[0]
        assert issubclass(enum_value_cls, IntegerOneEnum)
        assert issubclass(enum_value_cls, int)
        assert issubclass(enum_value_cls, Enum)
        # the enum stored in that class is expected
        enum_value = enum_value_cls.POSITIVE_0
        assert isinstance(enum_value, IntegerOneEnum)
        assert isinstance(enum_value, int)
        assert isinstance(enum_value, Enum)
        # we can access this enum from our class
        assert IntegerOneEnum.POSITIVE_0 == enum_value

        # accessing invalid enum throws an exception
        invalid_enums = ['POSITIVE_1', 'POSITIVE_2']
        for invalid_enum in invalid_enums:
            with self.assertRaises(KeyError):
                getattr(IntegerOneEnum, invalid_enum)

    def test_invalid_type_combinations(self):
        regex_err = (
            r"Cannot combine schemas.+?StringWithValidation.+?and.+?IntegerMax10.+?in.+?Combo.+?because their types do not intersect"
        )
        with self.assertRaisesRegex(petstore_api.ApiTypeError, regex_err):
            class Combo(StringWithValidation, IntegerMax10):
                pass

    def test_combine_validations(self):
        # separate validations combined
        validations_a = {"max_length": 10}
        validations_b = {"min_length": 5}
        combined_validations = combine_validations(validations_a, validations_b)
        self.assertEqual(combined_validations, {"max_length": 10, "min_length": 5})

        # identical values stay the same
        validations_a = {"max_length": 10}
        combined_validations = combine_validations(validations_a, validations_a)
        self.assertEqual(combined_validations, validations_a)

        # new values combined correctly
        validations_a = {
            'max_length': 10,
            'min_length': 1,
            'max_items': 10,
            'min_items': 1,
            'exclusive_maximum': 10,
            'inclusive_maximum': 10,
            'exclusive_minimum': 1,
            'inclusive_minimum': 1,
            'regex': [{'pattern': r"10"}],
            'multiple_of': [10],
        }
        validations_b = {
            'max_length': 20,
            'min_length': 2,
            'max_items': 20,
            'min_items': 2,
            'exclusive_maximum': 20,
            'inclusive_maximum': 20,
            'exclusive_minimum': 2,
            'inclusive_minimum': 2,
            'regex': [{'pattern': r"20"}],
            'multiple_of': [20],
        }
        combined_validations = combine_validations(validations_a, validations_b)
        self.assertEqual(
            combined_validations,
            {
                'max_length': 10,
                'min_length': 2,
                'max_items': 10,
                'min_items': 2,
                'exclusive_maximum': 10,
                'inclusive_maximum': 10,
                'exclusive_minimum': 2,
                'inclusive_minimum': 2,
                'regex': [{'pattern': r"10"}, {'pattern': r"20"}],
                'multiple_of': [10, 20],
            }
        )
        # flipping the order reverses regex and multiple_of values
        combined_validations = combine_validations(validations_b, validations_a)
        self.assertEqual(
            combined_validations,
            {
                'max_length': 10,
                'min_length': 2,
                'max_items': 10,
                'min_items': 2,
                'exclusive_maximum': 10,
                'inclusive_maximum': 10,
                'exclusive_minimum': 2,
                'inclusive_minimum': 2,
                'regex': [{'pattern': r"20"}, {'pattern': r"10"}],
                'multiple_of': [20, 10],
            }
        )

        # value errors raised for invalid combinations
        var_pairs = [
            ('max_length', 'min_length'),
            ('max_items', 'min_items'),
            ('inclusive_maximum', 'inclusive_minimum')
        ]
        for (max_var, min_var) in var_pairs:
            with self.assertRaisesRegex(
                petstore_api.ApiValueError,
                r"because {} 9 is less than {} 10".format(
                    max_var, min_var
                )
            ):
                combine_validations({max_var: 9}, {min_var: 10})

        # value errors raised for invalid combinations of exclusive_maximum + exclusive_minimum
        max_min_pairs = [(9, 10), (10, 10)]
        err_regex = (
            r"because exclusive_maximum {} is less than or equal to exclusive_minimum {}"
        )
        for (max_val, min_val) in max_min_pairs:
            with self.assertRaisesRegex(petstore_api.ApiValueError, err_regex.format(max_val, min_val)):
                combine_validations({'exclusive_maximum': max_val}, {'exclusive_minimum': min_val})

if __name__ == '__main__':
    unittest.main()
