// Extensions.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Alamofire
import PromiseKit
import SwiftyJSON

extension Request {
    func responsePromise<T>() -> Promise<Response<T>> {
        let defer = Promise<Response<T>>.defer()
        responseJSON(options: .AllowFragments) { (req, res, json, error) in
            if let error = error {
                defer.reject(error)
                return
            }
            if res!.statusCode >= 400 {
                let error = NSError(domain: res!.URL!.URLString, code: res!.statusCode, userInfo: [:])
                defer.reject(error)
                return
            }

            if Empty.instance is T {
                let response = Response(response: res!, body: Empty.instance as! T)
                defer.fulfill(response)
                return
            }
            if let json: AnyObject = json {
                if let body = T.decode(json) {
                    let response = Response(response: res!, body: body)
                    defer.fulfill(response)
                } else {
                    defer.reject(NSError(domain: "localhost", code: 500, userInfo: ["reason": "cannot convertible: \(json)"]))
                }
                return
            }

            defer.reject(NSError(domain: "localhost", code: 500, userInfo: ["reason": "unreacheable code"]))
        }
        return defer.promise
    }
}


extension Bool: JSONEncodable, JSONDecodable {
    static func decode(source: AnyObject) -> Bool? {
        return source as? Bool
    }
    func encode() -> AnyObject { return self }
}

extension Float: JSONEncodable, JSONDecodable {
    static func decode(source: AnyObject) -> Float? {
        return source as? Float
    }
    func encode() -> AnyObject { return self }
}

extension Int: JSONEncodable, JSONDecodable {
    static func decode(source: AnyObject) -> Int? {
        return source as? Int
    }
    func encode() -> AnyObject { return self }
}

extension Double: JSONEncodable, JSONDecodable {
    static func decode(source: AnyObject) -> Double? {
        return source as? Double
    }
    func encode() -> AnyObject { return self }
}

extension String: JSONEncodable, JSONDecodable {
    static func decode(source: AnyObject) -> String? {
        return source as? String
    }
    func encode() -> AnyObject { return self }
}

extension JSON {
    func decode() -> Bool? {
        return self.bool
    }
    func decode() -> Bool {
        return self.boolValue
    }
    func decode() -> Int? {
        return self.int
    }
    func decode() -> Int {
        return self.intValue
    }
    func decode() -> Float? {
        return self.float
    }
    func decode() -> Float {
        return self.floatValue
    }
    func decode() -> Double? {
        return self.double
    }
    func decode() -> Double {
        return self.doubleValue
    }
    func decode() -> String? {
        return self.string
    }
    func decode() -> String {
        return self.stringValue
    }
    func decode<T: JSONDecodable>() -> T? {
        return T.decode(self.object)
    }
    func decode<T: JSONDecodable>() -> [T]? {
        return self.arrayObject?.map(T.decode).filter({ $0 != nil }).map({ $0! })
    }
    func decode<T>() -> [T]? {
        return self.array?.map({ $0 as! T })
    }
    static let DateFormat: NSDateFormatter = {
        let formatter = NSDateFormatter()
        formatter.dateFormat = "yyyy-MM-dd'T'HH:mm:ss'Z'"
        return formatter
    }()
    func decode() -> NSDate? {
        return JSON.DateFormat.dateFromString(self.string ?? "")
    }
    func decode() -> NSData? {
        return self.rawData(options: .allZeros, error: nil)
    }
    func decode() -> NSData {
        return self.decode()!
    }
}

