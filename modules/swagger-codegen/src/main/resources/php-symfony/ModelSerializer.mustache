<?php
/**
 * ModelSerializer
 *
 * PHP version 5
 *
 * @category Class
 * @package  {{modelPackage}}
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

{{>partial_header}}
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace {{modelPackage}};

/**
 * ModelSerializer Class Doc Comment
 *
 * @category Class
 * @package  {{modelPackage}}
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ModelSerializer
{

    /**
     * Serializes data to a given type format.
     *
     * @param mixed $data     The data to serialize.
     * @param string $format  The target serialization format.
     *
     * @return string  A serialized data string.
     * @throws \InvalidArgumentException When invalid serialization format was used.
     */
    public function serialize($data, $format)
    {
        $normalized = $this->normalize($data);
        if ($format === 'json') {
            return json_encode($normalized, 15, 512);
        }

        throw new \InvalidArgumentException('Unsupported serialization format: '.$format);
    }

    /**
     * Deserializes data from a given type format.
     *
     * @param string $data   The data to deserialize.
     * @param string $class  The target class to deserialize to.
     * @param string $format The source serialization format.
     *
     * @return mixed  A deserialized value.
     * @throws \InvalidArgumentException When invalid serialization format was used.
     */
    public function deserialize($data, $class, $format)
    {
        switch ($format) {
            case 'json':
                $normalized = json_decode($data, true, 512, 15);
                break;
            default:
                throw new \InvalidArgumentException('Unsupported serialization format: '.$format);
        }

        return $this->denormalize($normalized, $class);
    }

    public function normalize($data, $format = null)
    {
        if (is_scalar($data) || null === $data) {
            return $data;
        }

        if (is_array($data)) {
            return array_map(function ($value) use ($format) {
               return $this->normalize($value, $format);
            }, $data);
        }

        if ($data instanceof \DateTime) {
            return ($format === 'date') ? $data->format('Y-m-d') : $data->format(\DateTime::ATOM);
        }

        if ($data instanceof ModelInterface) {
            $values = [];
            foreach ($data->modelAttributes() as $name => $attribute) {
                list($baseName, , $format, , $getter) = $attribute;
                $value = $this->normalize($data->$getter(), $format);
                if ($value !== null && method_exists($data, 'getAllowableEnumValues')
                    && !in_array($value, $data::getAllowableEnumValues())) {
                    $imploded = implode("', '", $data::getAllowableEnumValues());
                    throw new \InvalidArgumentException("Invalid value for enum '$data', must be one of: '$imploded'");
                }

                if ($value !== null) {
                    $values[$baseName] = $value;
                }
            }

            return $values;
        }

        return (string) $data;
    }

    public function denormalize($data, $class, $format = null)
    {
        if ($data === null) {
            return null;
        }

        if (in_array($class, ['DateTime', 'bool', 'boolean', 'byte', 'double', 'float', 'int', 'integer', 'mixed', 'number', 'object', 'string', 'void'], true)) {
            settype($data, $class);
            return $data;
        }

        // Denormalize array
        if (substr($class, -2) === '[]') {
            $innerClass = substr($class, 0, -2);
            return array_map(function ($value) use ($format, $innerClass) {
                return $this->denormalize($value, $innerClass, $format);
            }, $data);
        }

        if (!class_exists($class)) {
            return $data;
        }

        // Denormalize enum
        if (method_exists($class, 'getAllowableEnumValues')) {
            if (!in_array($data, $class::getAllowableEnumValues())) {
                $imploded = implode("', '", $class::getAllowableEnumValues());
                throw new \InvalidArgumentException("Invalid value for enum '$class', must be one of: '$imploded'");
            }

            return $data;
        }

        // If a discriminator is defined and points to a valid subclass, use it.
        $discriminator = $class::DISCRIMINATOR;
        if (!empty($discriminator) && isset($data[$discriminator]) && is_string($data[$discriminator])) {
            $subclass = '{{modelPackage}}\\'.$data[$discriminator];
            if (is_subclass_of($subclass, $class)) {
                $class = $subclass;
            }
        }

        // Denormalize another model
        $values = new $class();
        if ($values instanceof ModelInterface) {
            foreach ($values->modelAttributes() as $name => $attribute) {
                list($baseName, $innerClass, $format, $setter) = $attribute;

                if (!isset($data[$baseName])) {
                    continue;
                }

                $value = $this->denormalize($data[$baseName], $innerClass, $format);
                $values->$setter($value);
            }

            return $values;
        }

        return $data;
    }
}
