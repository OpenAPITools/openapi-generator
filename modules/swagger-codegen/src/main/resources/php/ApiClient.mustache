<?php
/**
 * ApiClient
 *
 * PHP version 5
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */

{{>partial_header}}
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace {{invokerPackage}};

/**
 * ApiClient Class Doc Comment
 *
 * @category Class
 * @package  {{invokerPackage}}
 * @author   http://github.com/swagger-api/swagger-codegen
 * @license  http://www.apache.org/licenses/LICENSE-2.0 Apache License v2
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ApiClient
{
    public static $PATCH = 'PATCH';
    public static $POST = 'POST';
    public static $GET = 'GET';
    public static $HEAD = 'HEAD';
    public static $OPTIONS = 'OPTIONS';
    public static $PUT = 'PUT';
    public static $DELETE = 'DELETE';

    /**
     * Configuration
     *
     * @var Configuration
     */
    protected $config;

    /**
     * Object Serializer
     *
     * @var ObjectSerializer
     */
    protected $serializer;

    /**
     * Constructor of the class
     *
     * @param Configuration $config config for this ApiClient
     */
    public function __construct(Configuration $config = null)
    {
        if ($config === null) {
            $config = Configuration::getDefaultConfiguration();
        }

        $this->config = $config;
        $this->serializer = new ObjectSerializer();
    }

    /**
     * Get the config
     *
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Get the serializer
     *
     * @return ObjectSerializer
     */
    public function getSerializer()
    {
        return $this->serializer;
    }

    /**
     * Get API key (with prefix if set)
     *
     * @param  string $apiKeyIdentifier name of API key
     *
     * @return string API key with the prefix
     */
    public function getApiKeyWithPrefix($apiKeyIdentifier)
    {
        $prefix = $this->config->getApiKeyPrefix($apiKeyIdentifier);
        $apiKey = $this->config->getApiKey($apiKeyIdentifier);

        if ($apiKey === null) {
            return null;
        }

        $keyWithPrefix = $apiKey;
        if ($prefix !== null) {
            $keyWithPrefix = $prefix.' '.$apiKey;
        }

        return $keyWithPrefix;
    }

    /**
     * Make the HTTP call (Sync)
     *
     * @param string       $resourcePath path to method endpoint
     * @param string       $method       method to call
     * @param array        $queryParams  parameters to be place in query URL
     * @param array|string $postData     parameters to be placed in POST body
     * @param array        $headerParams parameters to be place in request header
     * @param string       $responseType expected response type of the endpoint
     *
     * @throws ApiException on a non 2xx response
     * @return mixed
     */
    public function callApi(
        $resourcePath,
        $method,
        array $queryParams,
        $postData,
        array $headerParams,
        $responseType = null
    ) {
        $headers = [];

        // construct the http header
        $headerParams = array_merge(
            (array)$this->config->getDefaultHeaders(),
            (array)$headerParams
        );

        foreach ($headerParams as $key => $val) {
            $headers[] = "$key: $val";
        }

        // form data
        if (is_array($postData) && in_array('Content-Type: application/x-www-form-urlencoded', $headers, true)) {
            $postData = http_build_query($postData);
        } elseif ((is_object($postData) || is_array($postData)) && !in_array('Content-Type: multipart/form-data', $headers, true)) { // json model
            $postData = json_encode(ObjectSerializer::sanitizeForSerialization($postData));
        }

        $url = $this->config->getHost() . $resourcePath;

        $curl = curl_init();
        // set timeout, if needed
        if ($this->config->getCurlTimeout() !== 0) {
            curl_setopt($curl, CURLOPT_TIMEOUT, $this->config->getCurlTimeout());
        }
        // return the result on success, rather than just true
        curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);

        curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);

        // disable SSL verification, if needed
        if ($this->config->isSSLVerification() === false) {
            curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, 0);
            curl_setopt($curl, CURLOPT_SSL_VERIFYHOST, 0);
        }

        if ($queryParams !== null) {
            $url = ($url . '?' . http_build_query($queryParams));
        }

        if ($method === self::$POST) {
            curl_setopt($curl, CURLOPT_POST, true);
            curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
        } elseif ($method === self::$HEAD) {
            curl_setopt($curl, CURLOPT_NOBODY, true);
        } elseif ($method === self::$OPTIONS) {
            curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'OPTIONS');
            curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
        } elseif ($method === self::$PATCH) {
            curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'PATCH');
            curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
        } elseif ($method === self::$PUT) {
            curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'PUT');
            curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
        } elseif ($method === self::$DELETE) {
            curl_setopt($curl, CURLOPT_CUSTOMREQUEST, 'DELETE');
            curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
        } elseif ($method !== self::$GET) {
            throw new ApiException('Method ' . $method . ' is not recognized.');
        }
        curl_setopt($curl, CURLOPT_URL, $url);

        // Set user agent
        curl_setopt($curl, CURLOPT_USERAGENT, $this->config->getUserAgent());

        // debugging for curl
        if ($this->config->isDebug()) {
            error_log(
                '[DEBUG] HTTP Request body  ~BEGIN~'.PHP_EOL.print_r($postData, true).PHP_EOL.'~END~'.PHP_EOL,
                3,
                $this->config->getDebugFile()
            );

            curl_setopt($curl, CURLOPT_VERBOSE, 1);
            curl_setopt($curl, CURLOPT_STDERR, fopen($this->config->getDebugFile(), 'a'));
        } else {
            curl_setopt($curl, CURLOPT_VERBOSE, 0);
        }

        // obtain the HTTP response headers
        curl_setopt($curl, CURLOPT_HEADER, 1);

        // Make the request
        $response = curl_exec($curl);
        $httpHeaderSize = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $httpHeader = $this->httpParseHeaders(substr($response, 0, $httpHeaderSize));
        $httpBody = substr($response, $httpHeaderSize);
        $responseInfo = curl_getinfo($curl);

        // debug HTTP response body
        if ($this->config->isDebug()) {
            error_log(
                '[DEBUG] HTTP Response body ~BEGIN~'.PHP_EOL.print_r($httpBody, true).PHP_EOL.'~END~'.PHP_EOL,
                3,
                $this->config->getDebugFile()
            );
        }

        // Handle the response
        if ($responseInfo['http_code'] === 0) {
            $curlErrorMessage = curl_error($curl);

            // curl_exec can sometimes fail but still return a blank message from curl_error().
            if ($curlErrorMessage !== '') {
                $errorMessage = 'API call to '.$url.' failed: '.$curlErrorMessage;
            } else {
                $errorMessage = 'API call to '.$url.' failed, but for an unknown reason. ' .
                    'This could happen if you are disconnected from the network.';
            }

            $exception = new ApiException($errorMessage, 0, null, null);
            $exception->setResponseObject($responseInfo);
            throw $exception;
        } elseif ($responseInfo['http_code'] >= 200 && $responseInfo['http_code'] <= 299) {
            // return raw body if response is a file
            if ($responseType === '\SplFileObject' || $responseType === 'string') {
                return [$httpBody, $responseInfo['http_code'], $httpHeader];
            }

            $data = json_decode($httpBody);
            if (json_last_error() > 0) { // if response is a string
                $data = $httpBody;
            }
        } else {
            $data = json_decode($httpBody);
            if (json_last_error() > 0) { // if response is a string
                $data = $httpBody;
            }

            throw new ApiException(
                '['.$responseInfo['http_code'].'] Error connecting to the API ('.$url.')',
                $responseInfo['http_code'],
                $httpHeader,
                $data
            );
        }
        return [$data, $responseInfo['http_code'], $httpHeader];
    }

    /**
     * Return the header 'Accept' based on an array of Accept provided
     *
     * @param string[] $accept Array of header
     *
     * @return string Accept (e.g. application/json)
     */
    public function selectHeaderAccept($accept)
    {
        if (count($accept) === 0 || (count($accept) === 1 && $accept[0] === '')) {
            return null;
        } elseif (preg_grep('/application\\/json/i', $accept)) {
            return 'application/json';
        } else {
            return implode(',', $accept);
        }
    }

    /**
     * Return the content type based on an array of content-type provided
     *
     * @param string[] $contentType Array for Content-type
     *
     * @return string Content-Type (e.g. application/json)
     */
    public function selectHeaderContentType($contentType)
    {
        if (count($contentType) === 0 || (count($contentType) === 1 && $contentType[0] === '')) {
            return 'application/json';
        } elseif (preg_grep('/application\\/json/i', $contentType)) {
            return 'application/json';
        } else {
            return implode(',', $contentType);
        }
    }

   /**
    * Return an array of HTTP response headers
    *
    * @param string $rawHeaders A string of raw HTTP response headers
    *
    * @return string[] Array of HTTP response headers
    */
    protected function httpParseHeaders($rawHeaders)
    {
        // ref/credit: http://php.net/manual/en/function.http-parse-headers.php#112986
        $headers = [];
        $key = '';

        foreach (explode("\n", $rawHeaders) as $h) {
            $h = explode(':', $h, 2);

            if (isset($h[1])) {
                if (!isset($headers[$h[0]])) {
                    $headers[$h[0]] = trim($h[1]);
                } elseif (is_array($headers[$h[0]])) {
                    $headers[$h[0]] = array_merge($headers[$h[0]], [trim($h[1])]);
                } else {
                    $headers[$h[0]] = array_merge([$headers[$h[0]]], [trim($h[1])]);
                }

                $key = $h[0];
            } else {
                if (strpos($h[0], "\t") === 0) {
                    $headers[$key] .= "\r\n\t".trim($h[0]);
                } elseif (!$key) {
                    $headers[0] = trim($h[0]);
                }
                trim($h[0]);
            }
        }

        return $headers;
    }
}
