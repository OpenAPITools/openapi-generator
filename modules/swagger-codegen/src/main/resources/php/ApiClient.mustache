<?php
/**
 *  Copyright 2015 SmartBear Software
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 */

namespace {{invokerNamespace}};

class ApiClient {

  public static $PATCH = "PATCH";
  public static $POST = "POST";
  public static $GET = "GET";
  public static $PUT = "PUT";
  public static $DELETE = "DELETE";
  
  protected $defaultHeaders = array();

  /**
   * The host (from basePath)
   */
  protected $host = '{{basePath}}';

  /*
   * @var string timeout (second) of the HTTP request, by default set to 0, no timeout
   */
  protected $curlTimeout = 0;

  /*
   * @var string user agent of the HTTP request, set to "PHP-Swagger" by default
   */
  protected $userAgent = "PHP-Swagger";

  /**
   * @var ApiConfiguration
   */
  protected $config;

  /**
   * @param ApiConfiguration $config config for this ApiClient
   */
  function __construct(ApiConfiguration $config = null) {
    if ($config == null) {
      $config = ApiConfiguration::getDefaultConfiguration();
    }
    
    $this->config = $config;
  }

  /**
   * add default header 
   *
   * @param string $headerName header name (e.g. Token)
   * @param string $headerValue header value (e.g. 1z8wp3)
   * @return ApiClient
   */
  public function addDefaultHeader($headerName, $headerValue) {
    if (!is_string($headerName)) {
      throw new \InvalidArgumentException('Header name must be a string.');
    }

    $this->defaultHeaders[$headerName] =  $headerValue;
    return $this;
  }

  /**
   * get the default header 
   *
   * @return array default header
   */
  public function getDefaultHeaders() {
    return $this->defaultHeaders;
  }

  /**
   * @param string $host
   * @return ApiConfiguration
   */
  public function setHost($host) {
    $this->host = $host;
    return $this;
  }

  /**
   * @return string
   */
  public function getHost() {
    return $this->host;
  }

  /**
   * delete the default header based on header name
   *
   * @param string $headerName header name (e.g. Token)
   */
  public function deleteDefaultHeader($headerName) {
    unset($this->defaultHeaders[$headerName]);
  }

  /**
   * set the user agent of the api client
   *
   * @param string $userAgent the user agent of the api client
   * @return ApiClient
   */
  public function setUserAgent($userAgent) {
    if (!is_string($userAgent))
      throw new \InvalidArgumentException('User-agent must be a string.');

    $this->userAgent = $userAgent;
    return $this;
  }

  /**
   * get the user agent of the api client
   * 
   * @return string user agent
   */
  public function getUserAgent() {
    return $this->userAgent;
  }

  /**
   * set the HTTP timeout value
   *
   * @param integer $seconds Number of seconds before timing out [set to 0 for no timeout]
   * @return ApiClient
   */
  public function setTimeout($seconds) {
    if (!is_numeric($seconds) || $seconds < 0)
      throw new \InvalidArgumentException('Timeout value must be numeric and a non-negative number.');

    $this->curlTimeout = $seconds;
    return $this;
  }

  /**
   * get the HTTP timeout value
   *
   * @return string HTTP timeout value
   */
  public function getTimeout() {
    return $this->curlTimeout;
  }


  /**
   * Get API key (with prefix if set)
   * @param string $apiKey name of apikey
   * @return string API key with the prefix
   */
  public function getApiKeyWithPrefix($apiKey) {
    $prefix = $this->config->getApiKeyPrefix($apiKey);
    $apiKey = $this->config->getApiKey($apiKey);

    if (!isset($apiKey)) {
      return null;
    }

    if (isset($prefix)) {
      $keyWithPrefix = $prefix." ".$apiKey;
    } else {
      $keyWithPrefix = $apiKey;
    }

    return $keyWithPrefix;
  }

  /**
   * update header and query param based on authentication setting
   * 
   * @param array $headerParams header parameters (by ref)
   * @param array $queryParams query parameters (by ref)
   * @param array $authSettings array of authentication scheme (e.g ['api_key'])
   */
  public function updateParamsForAuth(&$headerParams, &$queryParams, $authSettings)
  {
    if (count($authSettings) == 0)
      return;

    // one endpoint can have more than 1 auth settings
    foreach($authSettings as $auth) {
      // determine which one to use
      switch($auth) {
        {{#authMethods}}
        case '{{name}}':
          {{#isApiKey}}{{#isKeyInHeader}}$headerParams['{{keyParamName}}'] = $this->getApiKeyWithPrefix('{{keyParamName}}');{{/isKeyInHeader}}{{#isKeyInQuery}}$queryParams['{{keyParamName}}'] = $this->getApiKeyWithPrefix('{{keyParamName}}');{{/isKeyInQuery}}{{/isApiKey}}{{#isBasic}}$headerParams['Authorization'] = 'Basic '.base64_encode($this->config->getUsername().":".$this->config->getPassword());{{/isBasic}}
          {{#isOAuth}}//TODO support oauth{{/isOAuth}}
          break;
        {{/authMethods}}
        default:
          //TODO show warning about security definition not found
      }
    }
  }
  
  /**
   * @param string $resourcePath path to method endpoint
   * @param string $method method to call
   * @param array $queryParams parameters to be place in query URL
   * @param array $postData parameters to be placed in POST body
   * @param array $headerParams parameters to be place in request header
   * @param array $authSettings parameters for authentication
   * @throws \{{invokerNamespace}}\ApiException on a non 2xx response
   * @return mixed
   */
  public function callApi($resourcePath, $method, $queryParams, $postData,
    $headerParams, $authSettings) {

    $headers = array();

    # determine authentication setting
    $this->updateParamsForAuth($headerParams, $queryParams, $authSettings);

    # construct the http header
    $headerParams = array_merge((array)$this->defaultHeaders, (array)$headerParams);

    foreach ($headerParams as $key => $val) {
      $headers[] = "$key: $val";
    }

    // form data
    if ($postData and in_array('Content-Type: application/x-www-form-urlencoded', $headers)) {
      $postData = http_build_query($postData);
    }
    else if ((is_object($postData) or is_array($postData)) and !in_array('Content-Type: multipart/form-data', $headers)) { // json model
      $postData = json_encode(ObjectSerializer::sanitizeForSerialization($postData));
    }

    $url = $this->getHost() . $resourcePath;

    $curl = curl_init();
    // set timeout, if needed
    if ($this->curlTimeout != 0) {
      curl_setopt($curl, CURLOPT_TIMEOUT, $this->curlTimeout);
    }
    // return the result on success, rather than just TRUE
    curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);

    curl_setopt($curl, CURLOPT_HTTPHEADER, $headers);

    if (! empty($queryParams)) {
      $url = ($url . '?' . http_build_query($queryParams));
    }

    if ($method == self::$POST) {
      curl_setopt($curl, CURLOPT_POST, true);
      curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
    } else if ($method == self::$PATCH) {
      curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "PATCH");
      curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
    } else if ($method == self::$PUT) {
      curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "PUT");
      curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
    } else if ($method == self::$DELETE) {
      curl_setopt($curl, CURLOPT_CUSTOMREQUEST, "DELETE");
      curl_setopt($curl, CURLOPT_POSTFIELDS, $postData);
    } else if ($method != self::$GET) {
      throw new ApiException('Method ' . $method . ' is not recognized.');
    }
    curl_setopt($curl, CURLOPT_URL, $url);

    // Set user agent
    curl_setopt($curl, CURLOPT_USERAGENT, $this->userAgent);

    // debugging for curl
    if ($this->config->getDebug()) {
      error_log("[DEBUG] HTTP Request body  ~BEGIN~\n".print_r($postData, true)."\n~END~\n", 3, $this->config->getDebugFile());

      curl_setopt($curl, CURLOPT_VERBOSE, 1);
      curl_setopt($curl, CURLOPT_STDERR, fopen($this->config->getDebugFile(), 'a'));
    } else {
      curl_setopt($curl, CURLOPT_VERBOSE, 0);
    }

    // obtain the HTTP response headers
    curl_setopt($curl, CURLOPT_HEADER, 1);

    // Make the request
    $response = curl_exec($curl);
    $http_header_size = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
    $http_header = substr($response, 0, $http_header_size);
    $http_body = substr($response, $http_header_size);
    $response_info = curl_getinfo($curl);

    // debug HTTP response body
    if ($this->config->getDebug()) {
        error_log("[DEBUG] HTTP Response body ~BEGIN~\n".print_r($http_body, true)."\n~END~\n", 3, $this->config->getDebugFile());
    }

    // Handle the response
    if ($response_info['http_code'] == 0) {
      throw new ApiException("API call to $url timed out: ".serialize($response_info), 0, null, null);
    } else if ($response_info['http_code'] >= 200 && $response_info['http_code'] <= 299 ) {
      $data = json_decode($http_body);
      if (json_last_error() > 0) { // if response is a string
        $data = $http_body;
      }
    } else {
      throw new ApiException("[".$response_info['http_code']."] Error connecting to the API ($url)",
        $response_info['http_code'], $http_header, $http_body);
    }
    return $data;
  }

  /*
   * return the header 'Accept' based on an array of Accept provided
   *
   * @param string[] $accept Array of header
   * @return string Accept (e.g. application/json)
   */
  public static function selectHeaderAccept($accept) {
    if (count($accept) === 0 or (count($accept) === 1 and $accept[0] === '')) {
      return NULL;
    } elseif (preg_grep("/application\/json/i", $accept)) {
      return 'application/json';
    } else {
      return implode(',', $accept);
    }
  }

  /*
   * return the content type based on an array of content-type provided
   *
   * @param array[string] content_type_array Array fo content-type
   * @return string Content-Type (e.g. application/json)
   */
  public static function selectHeaderContentType($content_type) {
    if (count($content_type) === 0 or (count($content_type) === 1 and $content_type[0] === '')) {
      return 'application/json';
    } elseif (preg_grep("/application\/json/i", $content_type)) {
      return 'application/json';
    } else {
      return implode(',', $content_type);
    }
  }

}

