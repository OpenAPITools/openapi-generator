package org.openapitools.codegen.languages;

import org.openapitools.codegen.*;

import java.io.File;
import java.io.IOException;
import java.io.Writer;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.HashSet;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.samskivert.mustache.Mustache;
import com.samskivert.mustache.Template;

import io.swagger.v3.oas.models.OpenAPI;

/** basic asciidoc markup generator.
 * @see <a href="https://asciidoctor.org">asciidoctor</a> 
  */
public class AsciidocDocumentationCodegen extends DefaultCodegen implements CodegenConfig {

	private static final Logger LOGGER = LoggerFactory.getLogger(AsciidocDocumentationCodegen.class);

    public static final String SPEC_DIR = "specDir";
    public static final String SNIPPET_DIR = "snippetDir";

	/** 
	 * Lambda emitting an asciidoc "include::filename.adoc[]" if file is found in path. 
	 * Use:
	 * <pre>{{#includeMarkup}}{{name}}/description.adoc{{/includeMarkup}}</pre>
	 */
	public class IncludeMarkupLambda implements Mustache.Lambda {
		
		private long includeCount = 0;
		private long notFoundCount = 0;
    	private String basePath;
	    
	    public IncludeMarkupLambda(final String basePath) {
	    	this.basePath = basePath;
		}
	    
	    public String resetCounter( ) {
	    	String msg = "included:" + includeCount + " notFound: " + notFoundCount + " from " + basePath;
	    	includeCount = 0;
	    	notFoundCount = 0;
	    	return msg;
	    }

	    @Override
	    public void execute(final Template.Fragment frag, final Writer out) throws IOException {
	    	
	    	final String relativeFileName = frag.execute();
	    	final Path filePathToInclude = Paths.get(basePath, relativeFileName);
	        
	        if(Files.isRegularFile(filePathToInclude)) {
		        LOGGER.debug("including " + ++includeCount + ". file into markup from: " + filePathToInclude.toAbsolutePath().toString());
		        out.write("\ninclude::" + relativeFileName + "[]\n");	
	        } else {
		        LOGGER.debug(++notFoundCount + ". file not found, skip include for: " + relativeFileName);
		        out.write("\n// markup not included, not found: include::" + relativeFileName + "[]\n");	
	        }	        
	    }
	}
	
    protected String invokerPackage = "org.openapitools.client";
    protected String groupId = "org.openapitools";
    protected String artifactId = "openapi-client";
    protected String artifactVersion = "1.0.0";
    
    private IncludeMarkupLambda includeSpecMarkupLambda;
    private IncludeMarkupLambda includeSnippetMarkupLambda;

    public CodegenType getTag() {
        return CodegenType.DOCUMENTATION;
    }

    public String getName() {
        return "asciidoc";
    }

    public String getHelp() {
        return "Generates asciidoc markup based documentation.";
    }
      
    public String getSpecDir() {
    	return additionalProperties.get("specDir").toString();
    }
    
    public String getSnippetDir() {
    	return additionalProperties.get("snippetDir").toString();
    }

    public AsciidocDocumentationCodegen() {
        super();

        LOGGER.trace("start asciidoc codegen");
        
        outputFolder = "generated-code" + File.separator + "asciidoc";
        embeddedTemplateDir = templateDir = "asciidoc-documentation";
                
        defaultIncludes = new HashSet<String>();

        cliOptions.add(new CliOption("appName", "short name of the application"));
        cliOptions.add(new CliOption("appDescription", "description of the application"));
        cliOptions.add(new CliOption("infoUrl", "a URL where users can get more information about the application"));
        cliOptions.add(new CliOption("infoEmail", "an email address to contact for inquiries about the application"));
        cliOptions.add(new CliOption("licenseInfo", "a short description of the license"));
        cliOptions.add(new CliOption(CodegenConstants.LICENSE_URL, "a URL pointing to the full license"));
        cliOptions.add(new CliOption(CodegenConstants.INVOKER_PACKAGE, CodegenConstants.INVOKER_PACKAGE_DESC));
        cliOptions.add(new CliOption(CodegenConstants.GROUP_ID, CodegenConstants.GROUP_ID_DESC));
        cliOptions.add(new CliOption(CodegenConstants.ARTIFACT_ID, CodegenConstants.ARTIFACT_ID_DESC));
        cliOptions.add(new CliOption(CodegenConstants.ARTIFACT_VERSION, CodegenConstants.ARTIFACT_VERSION_DESC));
        
        cliOptions.add(new CliOption(
        		SNIPPET_DIR, 
        		"path with includable markup snippets (e.g. test output generated by restdoc, default: .")
        		.defaultValue("."));
        cliOptions.add(new CliOption(
        		SPEC_DIR, 
        		"path with includable markup spec files (e.g. handwritten additional docs, default: .")
        		.defaultValue(".."));

        additionalProperties.put("appName", "OpenAPI Sample description");
        additionalProperties.put("appDescription", "A sample OpenAPI documentation");
        additionalProperties.put("infoUrl", "https://openapi-generator.tech");
        additionalProperties.put("infoEmail", "team@openapitools.org");
        additionalProperties.put("licenseInfo", "All rights reserved");
        additionalProperties.put(CodegenConstants.LICENSE_URL, "http://apache.org/licenses/LICENSE-2.0.html");
        additionalProperties.put(CodegenConstants.INVOKER_PACKAGE, invokerPackage);
        additionalProperties.put(CodegenConstants.GROUP_ID, groupId);
        additionalProperties.put(CodegenConstants.ARTIFACT_ID, artifactId);
        additionalProperties.put(CodegenConstants.ARTIFACT_VERSION, artifactVersion);
        
        supportingFiles.add(new SupportingFile("index.mustache", "", "index.adoc"));
        reservedWords = new HashSet<String>();

        languageSpecificPrimitives = new HashSet<String>();
        importMapping = new HashMap<String, String>();
        
    }
    
    @Override
    public String escapeQuotationMark(String input) {
        return input; // just return the original string
    }

    @Override
    public String escapeUnsafeCharacters(String input) {
        return input; // just return the original string
    }
    
    @Override
    public void processOpts() {
        super.processOpts();
        
        String specDir = this.additionalProperties.get(SPEC_DIR) + "";
    	if( !Files.isDirectory(Paths.get(specDir))) {
    		LOGGER.warn("base part for include markup lambda not found: " + specDir + " as " + Paths.get(specDir).toAbsolutePath());
    	};
        
        this.includeSpecMarkupLambda = new IncludeMarkupLambda(specDir);
        additionalProperties.put("specinclude", this.includeSpecMarkupLambda );

        String snippetDir = this.additionalProperties.get(SNIPPET_DIR) + "";
    	if( !Files.isDirectory(Paths.get(snippetDir))) {
    		LOGGER.warn("base part for include markup lambda not found: " + snippetDir + " as " + Paths.get(snippetDir).toAbsolutePath());
    	};
        
        this.includeSnippetMarkupLambda = new IncludeMarkupLambda(snippetDir);
        additionalProperties.put("snippetinclude", this.includeSnippetMarkupLambda );    
    }

    @Override
    public void processOpenAPI(OpenAPI openAPI) {
    	if(this.includeSpecMarkupLambda != null) {
    		LOGGER.info("specs: " + 
    				": " + 
    				this.includeSpecMarkupLambda.resetCounter());
    	}
    	if(this.includeSnippetMarkupLambda != null) {
    		LOGGER.info(
    				"snippets: " + 
    				": " + 
    				this.includeSnippetMarkupLambda.resetCounter());
    	}
		super.processOpenAPI(openAPI);
	}

}
