{{#operations}}
{{>partial_header}}
package provider

import (
	"context"
	"fmt"
{{#hasCreate}}
	"encoding/json"
{{/hasCreate}}
{{^hasCreate}}{{#hasRead}}
	"encoding/json"
{{/hasRead}}{{/hasCreate}}
{{^hasCreate}}{{^hasRead}}{{#hasUpdate}}
	"encoding/json"
{{/hasUpdate}}{{/hasRead}}{{/hasCreate}}

	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
{{#hasListAttributes}}
	"github.com/hashicorp/terraform-plugin-framework/types"
{{/hasListAttributes}}
{{#hasCreate}}
	"github.com/hashicorp/terraform-plugin-log/tflog"
{{/hasCreate}}
{{^hasCreate}}{{#hasUpdate}}
	"github.com/hashicorp/terraform-plugin-log/tflog"
{{/hasUpdate}}{{/hasCreate}}
{{^hasCreate}}{{^hasUpdate}}{{#hasDelete}}
	"github.com/hashicorp/terraform-plugin-log/tflog"
{{/hasDelete}}{{/hasUpdate}}{{/hasCreate}}

	"{{gitHost}}/{{gitUserId}}/{{gitRepoId}}/internal/client"
)

var _ resource.Resource = &{{resourceClassName}}Resource{}
var _ resource.ResourceWithImportState = &{{resourceClassName}}Resource{}

func New{{resourceClassName}}Resource() resource.Resource {
	return &{{resourceClassName}}Resource{}
}

type {{resourceClassName}}Resource struct {
	client *client.Client
}

func (r *{{resourceClassName}}Resource) Metadata(_ context.Context, req resource.MetadataRequest, resp *resource.MetadataResponse) {
	resp.TypeName = req.ProviderTypeName + "_{{resourceName}}"
}

func (r *{{resourceClassName}}Resource) Schema(_ context.Context, _ resource.SchemaRequest, resp *resource.SchemaResponse) {
	resp.Schema = schema.Schema{
		Description: "Manages a {{resourceName}} resource.",
		Attributes: map[string]schema.Attribute{
{{#tfAttributes}}
			"{{terraformName}}": {{terraformAttrType}}{
{{#isRequired}}
				Required:    true,
{{/isRequired}}
{{#isComputed}}
				Computed:    true,
{{/isComputed}}
{{#isOptional}}
				Optional:    true,
{{/isOptional}}
{{#isSensitive}}
				Sensitive:   true,
{{/isSensitive}}
{{#isList}}
				ElementType: {{listElementType}},
{{/isList}}
				Description: "{{description}}",
			},
{{/tfAttributes}}
		},
	}
}

func (r *{{resourceClassName}}Resource) Configure(_ context.Context, req resource.ConfigureRequest, resp *resource.ConfigureResponse) {
	if req.ProviderData == nil {
		return
	}

	c, ok := req.ProviderData.(*client.Client)
	if !ok {
		resp.Diagnostics.AddError(
			"Unexpected Resource Configure Type",
			fmt.Sprintf("Expected *client.Client, got: %T.", req.ProviderData),
		)
		return
	}

	r.client = c
}

{{#hasCreate}}
func (r *{{resourceClassName}}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	var plan {{resourceClassName}}Model

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	reqBody := plan.ToClientModel()

	respBody, err := r.client.DoRequest(ctx, "{{createMethod}}", "{{createPath}}", reqBody)
	if err != nil {
		resp.Diagnostics.AddError("Error creating {{resourceName}}", err.Error())
		return
	}

	var result client.{{responseModel}}
	if err := json.Unmarshal(respBody, &result); err != nil {
		resp.Diagnostics.AddError("Error parsing response", err.Error())
		return
	}

	plan.FromClientModel(&result)

	tflog.Trace(ctx, "created {{resourceName}} resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}
{{/hasCreate}}
{{^hasCreate}}
func (r *{{resourceClassName}}Resource) Create(ctx context.Context, req resource.CreateRequest, resp *resource.CreateResponse) {
	resp.Diagnostics.AddError("Not Supported", "Create is not supported for {{resourceName}}")
}
{{/hasCreate}}

{{#hasRead}}
func (r *{{resourceClassName}}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	var state {{resourceClassName}}Model

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

{{#readHasPathParams}}
	respBody, err := r.client.DoRequest(ctx, "{{readMethod}}", fmt.Sprintf("{{readPath}}", state.{{idFieldExported}}{{idFieldValueAccessor}}), nil)
{{/readHasPathParams}}
{{^readHasPathParams}}
	respBody, err := r.client.DoRequest(ctx, "{{readMethod}}", "{{readPath}}", nil)
{{/readHasPathParams}}
	if err != nil {
		resp.Diagnostics.AddError("Error reading {{resourceName}}", err.Error())
		return
	}

	var result client.{{responseModel}}
	if err := json.Unmarshal(respBody, &result); err != nil {
		resp.Diagnostics.AddError("Error parsing response", err.Error())
		return
	}

	state.FromClientModel(&result)

	resp.Diagnostics.Append(resp.State.Set(ctx, &state)...)
}
{{/hasRead}}
{{^hasRead}}
func (r *{{resourceClassName}}Resource) Read(ctx context.Context, req resource.ReadRequest, resp *resource.ReadResponse) {
	resp.Diagnostics.AddError("Not Supported", "Read is not supported for {{resourceName}}")
}
{{/hasRead}}

{{#hasUpdate}}
func (r *{{resourceClassName}}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	var plan {{resourceClassName}}Model

	resp.Diagnostics.Append(req.Plan.Get(ctx, &plan)...)
	if resp.Diagnostics.HasError() {
		return
	}

	reqBody := plan.ToClientModel()

{{#updateHasPathParams}}
	respBody, err := r.client.DoRequest(ctx, "{{updateMethod}}", fmt.Sprintf("{{updatePath}}", plan.{{idFieldExported}}{{idFieldValueAccessor}}), reqBody)
{{/updateHasPathParams}}
{{^updateHasPathParams}}
	respBody, err := r.client.DoRequest(ctx, "{{updateMethod}}", "{{updatePath}}", reqBody)
{{/updateHasPathParams}}
	if err != nil {
		resp.Diagnostics.AddError("Error updating {{resourceName}}", err.Error())
		return
	}

	var result client.{{responseModel}}
	if err := json.Unmarshal(respBody, &result); err != nil {
		resp.Diagnostics.AddError("Error parsing response", err.Error())
		return
	}

	plan.FromClientModel(&result)

	tflog.Trace(ctx, "updated {{resourceName}} resource")
	resp.Diagnostics.Append(resp.State.Set(ctx, &plan)...)
}
{{/hasUpdate}}
{{^hasUpdate}}
func (r *{{resourceClassName}}Resource) Update(ctx context.Context, req resource.UpdateRequest, resp *resource.UpdateResponse) {
	resp.Diagnostics.AddError("Not Supported", "Update is not supported for {{resourceName}}")
}
{{/hasUpdate}}

{{#hasDelete}}
func (r *{{resourceClassName}}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	var state {{resourceClassName}}Model

	resp.Diagnostics.Append(req.State.Get(ctx, &state)...)
	if resp.Diagnostics.HasError() {
		return
	}

{{#deleteHasPathParams}}
	_, err := r.client.DoRequest(ctx, "{{deleteMethod}}", fmt.Sprintf("{{deletePath}}", state.{{idFieldExported}}{{idFieldValueAccessor}}), nil)
{{/deleteHasPathParams}}
{{^deleteHasPathParams}}
	_, err := r.client.DoRequest(ctx, "{{deleteMethod}}", "{{deletePath}}", nil)
{{/deleteHasPathParams}}
	if err != nil {
		resp.Diagnostics.AddError("Error deleting {{resourceName}}", err.Error())
		return
	}

	tflog.Trace(ctx, "deleted {{resourceName}} resource")
}
{{/hasDelete}}
{{^hasDelete}}
func (r *{{resourceClassName}}Resource) Delete(ctx context.Context, req resource.DeleteRequest, resp *resource.DeleteResponse) {
	resp.Diagnostics.AddError("Not Supported", "Delete is not supported for {{resourceName}}")
}
{{/hasDelete}}

func (r *{{resourceClassName}}Resource) ImportState(ctx context.Context, req resource.ImportStateRequest, resp *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("{{idFieldTerraformName}}"), req, resp)
}
{{/operations}}
