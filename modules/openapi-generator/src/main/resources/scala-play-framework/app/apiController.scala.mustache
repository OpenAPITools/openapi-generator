package {{package}}

import javax.inject.{Inject, Singleton}
import play.api.libs.json._
import play.api.mvc._
{{#apiFutures}}
import scala.concurrent.{ExecutionContext, Future}
{{/apiFutures}}
{{#imports}}
import {{import}}
{{/imports}}
{{#operations}}

{{>generatedAnnotation}}@Singleton
class {{classname}}Controller @Inject()(cc: ControllerComponents, api: {{classname}}){{#apiFutures}}(implicit executionContext: ExecutionContext){{/apiFutures}} extends AbstractController(cc) {
  {{#operation}}
  /**
    * {{httpMethod}} {{path}}{{#queryParams.0}}?{{/queryParams.0}}{{#queryParams}}{{paramName}}=[value]{{#hasMore}}&{{/hasMore}}{{/queryParams}} {{#pathParams}}{{#description}}
    * @param {{paramName}} {{description}}{{/description}}{{/pathParams}}
    */
  def {{operationId}}({{#pathParams}}{{paramName}}: {{dataType}}{{#hasMore}}, {{/hasMore}}{{/pathParams}}): Action[AnyContent] = Action{{#apiFutures}}.async{{/apiFutures}} { request =>
    {{! Keep the execution result in its own block to prevent redeclaration of parameter names (however unlikely that might be). }}
    def executeApi(): {{>returnTypeOrUnit}} = {
      {{#bodyParams}}
      val {{paramName}} = request.body.asJson.map(_.as[{{dataType}}]){{#required}}.getOrElse {
        throw new IllegalArgumentException("Missing required body parameter.")
      }{{/required}}
      {{/bodyParams}}
      {{#headerParams}}
      val {{paramName}} = request.headers.get("{{baseName}}")
      {{! TODO: Indentation }}
      {{>app/transformParamValues}}
      {{/headerParams}}
      {{#queryParams}}
      val {{paramName}} = request.{{#isCollectionFormatMulti}}queryString.get("{{baseName}}"){{/isCollectionFormatMulti}}{{^isCollectionFormatMulti}}getQueryString("{{baseName}}"){{/isCollectionFormatMulti}}
      {{! TODO: Indentation }}
      {{>app/transformParamValues}}
      {{/queryParams}}
      {{#formParams}}
      val {{paramName}}: {{>dataTypeOption}} = null // TODO [form]
      {{/formParams}}
      api.{{operationId}}({{#allParams}}{{paramName}}{{#hasMore}}, {{/hasMore}}{{/allParams}})
    }

    {{#apiFutures}}
    executeApi().map { {{#returnType}}result{{/returnType}}{{^returnType}}_{{/returnType}} =>
    {{/apiFutures}}
    {{^apiFutures}}
    {{#returnType}}
    val result = executeApi()
    {{/returnType}}
    {{/apiFutures}}
    {{#returnType}}
    {{#apiFutures}}  {{/apiFutures}}val json = Json.toJson(result)
    {{#apiFutures}}  {{/apiFutures}}Ok(json)
    {{/returnType}}
    {{^returnType}}
    {{#apiFutures}}  {{/apiFutures}}Ok
    {{/returnType}}
    {{#apiFutures}}
    }
    {{/apiFutures}}
  }{{#hasMore}}

  {{/hasMore}}
  {{/operation}}

  private def splitCollectionParam(paramValues: String, collectionFormat: String): List[String] = {
    {{! Note: `+` is used to filter empty values when splitting }}
    val splitBy =
      (collectionFormat: @scala.annotation.switch) match {
        case "csv" => ",+"
        case "tsv" => "\t+"
        case "ssv" => " +"
        case "pipes" => "|+"
      }

    paramValues.split(splitBy).toList
  }
}
{{/operations}}