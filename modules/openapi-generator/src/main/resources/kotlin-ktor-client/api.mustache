{{>licenseInfo}}
package {{apiPackage}}

import io.ktor.client.features.HttpRequestTimeoutException
import io.ktor.client.features.json.serializer.KotlinxSerializer
import io.ktor.client.features.ResponseException
import io.ktor.client.features.logging.LogLevel
import io.ktor.client.features.logging.Logger
import io.ktor.client.features.logging.SIMPLE
import kotlinx.serialization.*

import {{packageName}}.infrastructure.*
import {{packageName}}.infrastructure.authentication.*
{{#imports}}
import {{import}}
{{/imports}}

{{#operations}}
{{#nonPublicApi}}internal {{/nonPublicApi}}class {{classname}}(
    private val basePath: kotlin.String = "{{{basePath}}}",
    private val logger: Logger = Logger.SIMPLE,
    private val logLevel: LogLevel = LogLevel.NONE,
    private val requestTimeoutMillis: Long? = null,
    private val sanitizePaths: Boolean = false
) {
    {{#operation}}
    /**
    * {{summary}}
    * {{notes}}
    {{#allParams}}
    * @param {{paramName}} {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
    {{/allParams}}
    * @return {{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}
    */
    suspend fun {{operationId}}(
        {{#hasParams}}
        {{#allParams}}
        {{#required}}{{>api_req_param}}{{/required}}{{^required}}{{>api_opt_param}}{{/required}}{{#hasMore}},{{/hasMore}}{{^hasMore}}{{#hasAuthMethods}},{{/hasAuthMethods}}{{/hasMore}}
        {{/allParams}}
        {{/hasParams}}
        {{#authMethods}}
        {{name}}: {{>auth_class_name}}{{#hasMore}},{{/hasMore}}
        {{/authMethods}}
    ){{#returnType}} : {{{returnType}}}{{/returnType}} {
        val queryParameters = mutableListOf<Pair<String, Any?>>()
        {{#queryParams}}
        {{#required}}
        queryParameters += "{{{baseName}}}" to {{paramName}}
        {{/required}}
        {{^required}}
        if({{paramName}} != null) queryParameters += "{{{baseName}}}" to {{paramName}}
        {{/required}}
        {{/queryParams}}

        val headerParameters = listOf<Pair<String, Any?>>({{#hasHeaderParams}}
            {{#headerParams}}
            "{{{baseName}}}" to {{paramName}}{{#hasMore}}, {{/hasMore}}
            {{/headerParams}}
        {{/hasHeaderParams}})

        val formParameters = listOf<Pair<String, String?>>({{#hasFormParams}}
            {{#formParams}}
            "{{{baseName}}}" to {{paramName}}{{#hasMore}}, {{/hasMore}}
            {{/formParams}}
        {{/hasFormParams}})

        val mySerializer = KotlinxSerializer().apply {
            {{#uniquedResponses}}
            register({{>param_serializer}})
            {{/uniquedResponses}}
            {{#hasBodyParam}}
            {{#bodyParam}}
            register({{>param_serializer}})
            {{/bodyParam}}
            {{/hasBodyParam}}
        }

        val authProviders = listOf<AuthProvider>({{#hasAuthMethods}}
        {{#authMethods}}
            {{#isApiKey}}
            ApiKeyAuth(
                location = ApiKeyAuth.Location.{{#isKeyInHeader}}header{{/isKeyInHeader}}{{^isKeyInHeader}}query{{/isKeyInHeader}},
                paramName = "{{keyParamName}}",
                config = {{name}}
            ){{#hasMore}},{{/hasMore}}
            {{/isApiKey}}
            {{^isApiKey}}
            {{#isBasicBearer}}
            HttpBasicBearerAuth(
                scheme = "{{scheme}}",
                config = {{name}}
            ){{#hasMore}},{{/hasMore}}
            {{/isBasicBearer}}
            {{^isBasicBearer}}
            {{name}}{{#hasMore}}, {{/hasMore}}
            {{/isBasicBearer}}
            {{/isApiKey}}
        {{/authMethods}}
        {{/hasAuthMethods}})

        var path = "{{{path}}}"
        if (sanitizePaths) {
            path = path.removePrefix("{{{basePathWithoutHost}}}")
        }

        {{#hasErrorResponseDataTypes}}
        try {
            return request(
                url = "$basePath$path"{{#pathParams}}.replace("{"+"{{baseName}}"+"}", "${{paramName}}"){{/pathParams}},
                methodString =  "{{httpMethod}}",
                queryParameters = queryParameters,
                headerParameters = headerParameters,
                formParameters = formParameters,
                serializer = mySerializer,
                authProviders = authProviders,
                requestTimeoutMillis = requestTimeoutMillis,
                logger = this@{{classname}}.logger,
                logLevel = this@{{classname}}.logLevel{{#hasBodyParam}}{{#bodyParam}},
                bodyObject = {{paramName}},
                bodySerializer = {{>param_serializer}}{{/bodyParam}}{{/hasBodyParam}}
            )
        } catch (exception: ResponseException) {
            when(exception.response.status.value) {
                {{#responses}}{{#dataType}}{{^isDefault}}{{{code}}} -> throw exception.toErrorWrapper<{{{baseType}}}>(){{^-last}}
                {{/-last}}{{/isDefault}}{{/dataType}}{{/responses}}
                else -> throw exception
            }
        } catch (timeoutException: HttpRequestTimeoutException) {
            throw TimeoutErrorWrapper(timeoutException)
        }
        {{/hasErrorResponseDataTypes}}
        {{^hasErrorResponseDataTypes}}
        try {
            return request(
                url = "$basePath{{{path}}}"{{#pathParams}}.replace("{"+"{{baseName}}"+"}", "${{paramName}}"){{/pathParams}},
                methodString =  "{{httpMethod}}",
                queryParameters = queryParameters,
                headerParameters = headerParameters,
                formParameters = formParameters,
                serializer = mySerializer,
                authProviders = authProviders,
                requestTimeoutMillis = requestTimeoutMillis,
                logger = this@{{classname}}.logger,
                logLevel = this@{{classname}}.logLevel{{#hasBodyParam}}{{#bodyParam}},
                bodyObject = {{paramName}},
                bodySerializer = {{>param_serializer}}{{/bodyParam}}{{/hasBodyParam}}
            )
        } catch (timeoutException: HttpRequestTimeoutException) {
            throw TimeoutErrorWrapper(timeoutException)
        }
        {{/hasErrorResponseDataTypes}}
    }
    {{^-last}}

    {{/-last}}
    {{/operation}}
}
{{/operations}}
