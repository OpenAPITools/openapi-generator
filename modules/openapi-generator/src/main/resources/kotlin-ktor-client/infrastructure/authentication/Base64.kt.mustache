package {{packageName}}.infrastructure.authentication

import io.ktor.utils.io.core.String
import io.ktor.utils.io.core.toByteArray
import kotlin.experimental.and

private val BASE64_ALPHABET: String = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
private val BASE64_MASK: Byte = 0x3f
private val BASE64_PAD: Char = '='
private val BASE64_INVERSE_ALPHABET = IntArray(256) {
    BASE64_ALPHABET.indexOf(it.toChar())
}

private fun Int.toBase64(): Char = BASE64_ALPHABET[this]

internal object Base64Encoder {
    fun encode(src: ByteArray): ByteArray {
        fun ByteArray.getOrZero(index: Int): Int = if (index >= size) 0 else get(index).toInt()
        // 4n / 3 is expected Base64 payload
        val result = ArrayList<Byte>(4 * src.size / 3)
        var index = 0
        while (index < src.size) {
            val symbolsLeft = src.size - index
            val padSize = if (symbolsLeft >= 3) 0 else (3 - symbolsLeft) * 8 / 6
            val chunk = (src.getOrZero(index) shl 16) or (src.getOrZero(index + 1) shl 8) or src.getOrZero(index + 2)
            index += 3

            for (i in 3 downTo padSize) {
                val char = (chunk shr (6 * i)) and BASE64_MASK.toInt()
                result.add(char.toBase64().toByte())
            }
            // Fill the pad with '='
            repeat(padSize) { result.add(BASE64_PAD.toByte()) }
        }

        return result.toByteArray()
    }
}

internal fun String.encodeBase64(): String = String(Base64Encoder.encode(this.toByteArray()))

internal object Base64Decoder {

    fun decode(src: ByteArray): ByteArray {
        val sextets = src.map { it.fromBase64().toInt() }
        val octetCount = 3 * src.size / 4

        val octets = (0 until octetCount).map { octetIndex ->
            val firstSextetIndex = octetIndex + octetIndex/3
            val firstSextet = sextets[firstSextetIndex]
            val secondSextet = sextets[firstSextetIndex+1]

            val digitsOfSecondSextet = (1 + octetIndex % 3) * 2

            val lhs = firstSextet shl digitsOfSecondSextet
            val rhs = secondSextet ushr (6 - digitsOfSecondSextet)

            (lhs + rhs).toByte()
        }
        return octets.toByteArray()
    }
}
private fun Byte.fromBase64(): Byte = BASE64_INVERSE_ALPHABET[toInt() and 0xff].toByte() and BASE64_MASK

internal fun String.decodeBase64(): ByteArray = Base64Decoder.decode(dropLastWhile { it == BASE64_PAD }.toByteArray())