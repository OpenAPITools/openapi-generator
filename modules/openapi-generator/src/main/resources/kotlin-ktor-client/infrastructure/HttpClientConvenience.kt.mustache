package {{packageName}}.infrastructure

import {{packageName}}.infrastructure.authentication.AuthProvider
import io.ktor.client.*
import io.ktor.client.call.*
import io.ktor.client.plugins.*
import io.ktor.client.plugins.contentnegotiation.*
import io.ktor.client.plugins.logging.*
import io.ktor.client.request.*
import io.ktor.client.request.forms.*
import io.ktor.content.*
import io.ktor.http.*
import io.ktor.serialization.kotlinx.json.*
import io.ktor.util.*
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.json.Json

internal fun List<Pair<String, String?>>.whereSecondNotNull(): List<Pair<String, String>> {
    return mapNotNull {
        val key = it.first
        val value = it.second
        if (value == null) {
            null
        } else {
            key to value
        }
    }
}

//Until kotlinx serialization supports stripping nulls, we have to work around it
internal fun <T> Json.encodeToString(serializer: SerializationStrategy<T>, value: T, stripNull: Boolean): String {
    val nonStrippedJsonString = encodeToString(serializer, value)
    if (!stripNull) {
        return nonStrippedJsonString
    }

    val nullPropertyRegex = Regex(",?\"[^\"]*\":null")
    return nonStrippedJsonString.replace(nullPropertyRegex, "")
}

internal suspend inline fun <reified T, B> request(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    authProviders: List<AuthProvider>,
    requestTimeoutMillis: Long? = null,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: B,
    bodySerializer: SerializationStrategy<B>
): T {
    val serializedBody = TextContent(
        text = Json.encodeToString(serializer = bodySerializer, value = bodyObject, stripNull = true),
        contentType = ContentType.parse("application/json")
    )
    return request(
        url = url,
        methodString = methodString,
        queryParameters = queryParameters,
        headerParameters = headerParameters,
        formParameters = formParameters,
        authProviders = authProviders,
        requestTimeoutMillis = requestTimeoutMillis,
        logger = logger,
        logLevel = logLevel,
        bodyObject = serializedBody
    )
}

internal suspend inline fun <reified T, B> requestWithResponse(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    authProviders: List<AuthProvider>,
    requestTimeoutMillis: Long? = null,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: B,
    bodySerializer: SerializationStrategy<B>
): ApiResponse<T> {
    val serializedBody = TextContent(
        text = Json.encodeToString(serializer = bodySerializer, value = bodyObject, stripNull = true),
        contentType = ContentType.parse("application/json")
    )
    return requestWithResponse(
        url = url,
        methodString = methodString,
        queryParameters = queryParameters,
        headerParameters = headerParameters,
        formParameters = formParameters,
        authProviders = authProviders,
        requestTimeoutMillis = requestTimeoutMillis,
        logger = logger,
        logLevel = logLevel,
        bodyObject = serializedBody
    )
}

internal suspend inline fun <reified T> request(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    authProviders: List<AuthProvider>,
    requestTimeoutMillis: Long? = null,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: Any? = null
): T {
    @Suppress("NAME_SHADOWING") val queryParameters = queryParameters.toMutableList()
    @Suppress("NAME_SHADOWING") val headerParameters = headerParameters.toMutableList()

    val httpClient = HttpClient {
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true })
        }
        install(Logging) {
            this.logger = logger
            this.level = logLevel
        }
        install(HttpTimeout) {
            this.requestTimeoutMillis = requestTimeoutMillis
        }
        expectSuccess = true
    }

    authProviders.forEach {
        it.applyToParams(queryParameters = queryParameters, headerParameters = headerParameters)
    }

    return httpClient.request(url) {
        method = HttpMethod.parse(methodString)
        queryParameters.forEach {
            parameter(it.first, it.second)
        }
        headerParameters.forEach {
            header(it.first, it.second)
        }
        if (!formParameters.isEmpty()) {
            setBody(FormDataContent(Parameters.build {
                formParameters
                    .whereSecondNotNull()
                    .forEach { append(it.first, it.second) }
            }))
        } else if (bodyObject != null) {
            setBody(bodyObject)
        }
    }.body()
}

internal suspend inline fun <reified T> requestWithResponse(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    authProviders: List<AuthProvider>,
    requestTimeoutMillis: Long? = null,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: Any? = null
): ApiResponse<T> {
    @Suppress("NAME_SHADOWING") val queryParameters = queryParameters.toMutableList()
    @Suppress("NAME_SHADOWING") val headerParameters = headerParameters.toMutableList()

    val httpClient = HttpClient {
        install(ContentNegotiation) {
            json(Json { ignoreUnknownKeys = true })
        }
        install(Logging) {
            this.logger = logger
            this.level = logLevel
        }
        install(HttpTimeout) {
            this.requestTimeoutMillis = requestTimeoutMillis
        }
        expectSuccess = true
    }

    authProviders.forEach {
        it.applyToParams(queryParameters = queryParameters, headerParameters = headerParameters)
    }

    val httpResponse = httpClient.request(url) {
        method = HttpMethod.parse(methodString)
        queryParameters.forEach {
            parameter(it.first, it.second)
        }
        headerParameters.forEach {
            header(it.first, it.second)
        }
        if (formParameters.isNotEmpty()) {
            setBody(FormDataContent(Parameters.build {
                formParameters
                    .whereSecondNotNull()
                    .forEach { append(it.first, it.second) }
            }))
        } else if (bodyObject != null) {
            setBody(bodyObject)
        }
    }

    return ApiResponse(
        statusCode = httpResponse.status.value,
        headers = httpResponse.headers.toMap(),
        body = httpResponse.body()
    )
}

internal data class ApiResponse<T>(
    val statusCode: Int,
    val headers: Map<String, List<String>>,
    val body: T
)