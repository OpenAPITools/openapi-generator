package {{packageName}}.infrastructure

import io.ktor.client.HttpClient
import io.ktor.client.features.json.JsonFeature
import io.ktor.client.features.json.serializer.KotlinxSerializer
import io.ktor.client.features.logging.LogLevel
import io.ktor.client.features.logging.Logger
import io.ktor.client.features.logging.Logging
import io.ktor.client.request.forms.FormDataContent
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.request
import io.ktor.content.TextContent
import io.ktor.http.ContentType
import io.ktor.http.HttpMethod
import io.ktor.http.Parameters
import io.ktor.utils.io.core.use
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.json.Json
import {{packageName}}.infrastructure.authentication.AuthProvider

internal fun List<Pair<String, String?>>.whereSecondNotNull(): List<Pair<String, String>> {
    return mapNotNull {
        val key = it.first
        val value = it.second
        if (value == null) {
            null
        } else {
            key to value
        }
    }
}

//Until kotlinx serialization supports stripping nulls, we have to work around it
internal fun <T>Json.stringify(serializer: SerializationStrategy<T>, obj: T, stripNull: Boolean): String {
    val nonStrippedJsonString = stringify(serializer, obj)
    if (!stripNull) {
        return nonStrippedJsonString
    }

    val nullPropertyRegex = Regex(",?\"[^\"]*\":null")
    return nonStrippedJsonString.replace(nullPropertyRegex, "")
}

internal suspend inline fun <reified T, B> request(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    serializer: KotlinxSerializer,
    authProviders: List<AuthProvider>,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: B,
    bodySerializer: SerializationStrategy<B>
): T {
    val serializedBody = TextContent(
        text = Json.plain.stringify(bodySerializer, bodyObject, stripNull = true),
        contentType = ContentType.parse("application/json")
    )
    return request(
        url = url,
        methodString = methodString,
        queryParameters = queryParameters,
        headerParameters = headerParameters,
        formParameters = formParameters,
        serializer = serializer,
        authProviders = authProviders,
        logger = logger,
        logLevel = logLevel,
        bodyObject = serializedBody
    )
}

internal suspend inline fun <reified T> request(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    serializer: KotlinxSerializer,
    authProviders: List<AuthProvider>,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: Any? = null
): T {
    @Suppress("NAME_SHADOWING") val queryParameters = queryParameters.toMutableList()
    @Suppress("NAME_SHADOWING") val headerParameters = headerParameters.toMutableList()

    val httpClient = HttpClient {
        install(JsonFeature) {
            this.serializer = serializer
        }
        install(Logging) {
            this.logger = logger
            this.level = logLevel
        }
    }

    authProviders.forEach {
        it.applyToParams(queryParameters = queryParameters, headerParameters = headerParameters)
    }

    return httpClient.use {
        it.request(url) {
            method = HttpMethod.parse(methodString)
            queryParameters.forEach {
                parameter(it.first, it.second)
            }
            headerParameters.forEach {
                header(it.first, it.second)
            }
            if (!formParameters.isEmpty()) {
                body = FormDataContent(Parameters.build {
                    formParameters
                        .whereSecondNotNull()
                        .forEach { append(it.first, it.second) }
                })
            } else if (bodyObject != null) {
                body = bodyObject
            }
        }
    }
}