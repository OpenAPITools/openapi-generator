package {{packageName}}.infrastructure

import io.ktor.client.HttpClient
import io.ktor.client.features.HttpTimeout
import io.ktor.client.features.json.JsonFeature
import io.ktor.client.features.json.serializer.KotlinxSerializer
import io.ktor.client.features.logging.LogLevel
import io.ktor.client.features.logging.Logger
import io.ktor.client.features.logging.Logging
import io.ktor.client.request.forms.FormDataContent
import io.ktor.client.request.header
import io.ktor.client.request.parameter
import io.ktor.client.request.request
import io.ktor.content.TextContent
import io.ktor.http.ContentType
import io.ktor.http.HttpMethod
import io.ktor.http.Parameters
import io.ktor.utils.io.core.use
import kotlinx.serialization.json.Json
import kotlinx.serialization.SerializationStrategy
import kotlinx.serialization.UnstableDefault
import {{packageName}}.infrastructure.authentication.AuthProvider

internal fun List<Pair<String, String?>>.whereSecondNotNull(): List<Pair<String, String>> {
    return mapNotNull {
        val key = it.first
        val value = it.second
        if (value == null) {
            null
        } else {
            key to value
        }
    }
}

//Until kotlinx serialization supports stripping nulls, we have to work around it
internal fun <T>Json.stringify(serializer: SerializationStrategy<T>, value: T, stripNull: Boolean): String {
    val nonStrippedJsonString = stringify(serializer, value)
    if (!stripNull) {
        return nonStrippedJsonString
    }

    val nullPropertyRegex = Regex(",?\"[^\"]*\":null")
    return nonStrippedJsonString.replace(nullPropertyRegex, "")
}

@UnstableDefault
internal suspend inline fun <reified T, B> request(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    authProviders: List<AuthProvider>,
    requestTimeoutMillis: Long? = null,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: B,
    bodySerializer: SerializationStrategy<B>
): T {
    val serializedBody = TextContent(
        text = Json {}.stringify(serializer = bodySerializer, value = bodyObject, stripNull = true),
        contentType = ContentType.parse("application/json")
    )
    return request(
        url = url,
        methodString = methodString,
        queryParameters = queryParameters,
        headerParameters = headerParameters,
        formParameters = formParameters,
        authProviders = authProviders,
        requestTimeoutMillis = requestTimeoutMillis,
        logger = logger,
        logLevel = logLevel,
        bodyObject = serializedBody
    )
}

internal suspend inline fun <reified T> request(
    url: String,
    methodString: String,
    queryParameters: List<Pair<String, Any?>>,
    headerParameters: List<Pair<String, Any?>>,
    formParameters: List<Pair<String, String?>>,
    authProviders: List<AuthProvider>,
    requestTimeoutMillis: Long? = null,
    logger: Logger,
    logLevel: LogLevel,
    bodyObject: Any? = null
): T {
    @Suppress("NAME_SHADOWING") val queryParameters = queryParameters.toMutableList()
    @Suppress("NAME_SHADOWING") val headerParameters = headerParameters.toMutableList()

    val httpClient = HttpClient {
        install(JsonFeature) {
            this.serializer = KotlinxSerializer()
        }
        install(Logging) {
            this.logger = logger
            this.level = logLevel
        }
        install(HttpTimeout) {
            this.requestTimeoutMillis = requestTimeoutMillis
        }
    }

    authProviders.forEach {
        it.applyToParams(queryParameters = queryParameters, headerParameters = headerParameters)
    }

    return httpClient.use {
        it.request(url) {
            method = HttpMethod.parse(methodString)
            queryParameters.forEach {
                parameter(it.first, it.second)
            }
            headerParameters.forEach {
                header(it.first, it.second)
            }
            if (!formParameters.isEmpty()) {
                body = FormDataContent(Parameters.build {
                    formParameters
                        .whereSecondNotNull()
                        .forEach { append(it.first, it.second) }
                })
            } else if (bodyObject != null) {
                body = bodyObject
            }
        }
    }
}