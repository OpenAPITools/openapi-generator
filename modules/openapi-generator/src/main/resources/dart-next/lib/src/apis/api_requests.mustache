// ignore_for_file: unnecessary_type_check

{{#operations}}
part of '{{classFilename}}.dart';
{{/operations}}

{{#operations}}{{#operation}}

{{#allParams}}{{^isModel}}{{#enumName}}
{{>lib/src/models/enum_inline}}
{{/enumName}}{{/isModel}}{{/allParams}}

{{#isDeprecated}}
@Deprecated('This operation has been deprecated')
{{/isDeprecated}}
{{#bodyAllowed}}abstract{{/bodyAllowed}} class {{classname}}{{operationIdCamelCase}}Request {
  static const pathTemplate = r'{{{path}}}';
  static String method = r'{{{httpMethod}}}';

  {{#bodyAllowed}}
  String get contentType;
  {{/bodyAllowed}}
  final Map<String, String> extraHeaders;
  final Map<String, String> extraCookies;
  final Map<String, Object /* String | List<String> */> extraQueryParameters;

  {{! add path / header / query / cookie params }}
  {{#allParams}}
  {{^isFormParam}}{{^isBodyParam}}
  /// {{{description}}}
  /// spec name: {{baseName}}
  final {{>types/param}} {{paramName}};
  {{/isBodyParam}}{{/isFormParam}}
  {{/allParams}}

  {{#bodyAllowed}}
  const factory {{classname}}{{operationIdCamelCase}}Request.unsafe({
    {{#allParams}}{{^isFormParam}}{{^isBodyParam}}
    {{>types/required_ctor}} {{>types/param}} {{paramName}},
    {{/isBodyParam}}{{/isFormParam}}{{/allParams}}
    Map<String, String> extraHeaders,
    Map<String, Object> extraQueryParameters,
    Map<String, String> extraCookies,
    Stream<Uint8List>? bodyBytesStream,
  }) = {{classname}}{{operationIdCamelCase}}RequestUnsafe;

  {{#vendorExtensions}}{{#better-consumes}}{{#content}}{{#schema}}
  const factory {{classname}}{{operationIdCamelCase}}Request.{{nameInCamelCase}}({
    required {{>types/variable_recursive}} data,
    UnknownMediaTypeHandler? handleUnkownMediaType,
    {{#is_mime_multipart_form-data}}
    AppendFormDataPartHandler? appendUnkownFormDataPart,
    {{/is_mime_multipart_form-data}}
    {{^is_mime_multipart_form-data}}{{#is_mime_multipart}}
    AppendPartHandler? appendUnkownPart,
    {{/is_mime_multipart}}{{/is_mime_multipart_form-data}}
    {{#extraParameters}}
    {{>types/param}} {{paramName}},
    {{/extraParameters}}
    {{#allParams}}
    {{^isFormParam}}{{^isBodyParam}}
    {{>types/required_ctor}} {{>types/param}} {{paramName}},
    {{/isBodyParam}}{{/isFormParam}}
    {{/allParams}}
    Map<String, String> extraHeaders,
    Map<String, Object> extraQueryParameters,
    Map<String, String> extraCookies,
  }) = {{classname}}{{operationIdCamelCase}}Request{{nameInPascalCase}};
  {{/schema}}{{/content}}{{/better-consumes}}{{/vendorExtensions}}
  {{/bodyAllowed}}

  const {{classname}}{{operationIdCamelCase}}Request({
    {{#allParams}}
    {{^isFormParam}}{{^isBodyParam}}
    {{>types/required_ctor}} this.{{paramName}}{{>types/default}},
    {{/isBodyParam}}{{/isFormParam}}
    {{/allParams}}
    this.extraHeaders = const {},
    this.extraQueryParameters = const {},
    this.extraCookies = const {},
  });

  Future<Uri> getResolvedUri({
    required Uri baseUrl,
    Map<String, dynamic> context = const {},
  }) async {
    var resolvedPath = pathTemplate;
    {{! first we resolve path parameters }}
    {{#pathParams}}
    resolvedPath = OpenApiParameterSerializationPath.fromStyle(r'{{style}}', explode: {{isExplode}}, parameterName: r'{{baseName}}',).expand(resolvedPath, {{paramName}});
    {{/pathParams}}
    {{! then query parameters }}
    var methodUri = Uri(path: resolvedPath);
    {{#queryParams}}
    {{^required}}
    if ({{paramName}}.isDefined) {
    {{/required}}
      methodUri = OpenApiParameterSerializationQuery.fromStyle(r'{{style}}', explode: {{isExplode}}, parameterName: r'{{baseName}}', allowEmptyValue: {{isAllowEmptyValue}},).expandUri(methodUri, {{paramName}}{{^required}}.valueRequired{{/required}});
    {{^required}}
    }
    {{/required}}
    {{/queryParams}}

    return baseUrl.replace(
      pathSegments: [
        ...baseUrl.pathSegments,
        ...methodUri.pathSegments,
      ],
      queryParameters: {
        ...baseUrl.queryParameters,
        ...methodUri.queryParameters,
        ...extraQueryParameters,
      },
    );
  }

  Future<Map<String, String>> getResolvedHeaders({
    Map<String, dynamic> context = const {},
  }) async {

    final cookieParts = <String,String>{
      {{#cookieParams}}
        {{^required}}if ({{paramName}}.isDefined){{/required}}
        r'{{baseName}}': OpenApiParameterSerializationCookie(parameterName: r'{{baseName}}',explode: {{isExplode}}).serialize({{paramName}}{{^required}}.valueRequired{{/required}}),
      {{/cookieParams}}
      ...extraCookies,
    };

    var headers = CaseInsensitiveMap<String>.from(<String,String>{
      {{#bodyAllowed}}
      'Content-Type': this.contentType,
      {{/bodyAllowed}}
      {{! first add cookie header }}
      if (cookieParts.isNotEmpty)
        'Cookie': cookieParts.entries.map((e) => '${e.key}=${e.value}').join('; '),
      {{! then headers to override the cookie if necessary }}
      {{#headerParams}}
      {{>lib/src/apis/request/header_param}}
      {{/headerParams}}
      ...extraHeaders,
    });

    var contentType = headers['content-type'];
    if (contentType != null) {
      var parsedContentType = MediaType.parse(contentType).fillDefaults();
      if (parsedContentType.type == 'multipart' && parsedContentType.parameters['boundary'] == null) {
        parsedContentType = parsedContentType.change(
          parameters: {
            ...parsedContentType.parameters,
            'boundary': MultiPartBodySerializer.getRandomBoundaryString(Random()),
          }
        );
      }
      headers['content-type'] = parsedContentType.toString();
    }
    return headers;
  }


  {{#bodyAllowed}}
  Stream<List<int>> getResolvedBody({
    required Map<String, String> headers,
    Map<String, dynamic> context = const {},
  });
  {{/bodyAllowed}}

  Future<HttpRequestBase> createHttpRequest({
    required Uri baseUrl,
    Map<String, dynamic> context = const {},
  }) async {
    final futures = [
      getResolvedUri(
        context: context,
        baseUrl: baseUrl,
      ),
      getResolvedHeaders(context: context),
    ];
    final futureResults = await Future.wait(futures);
    final headers = futureResults[1] as Map<String, String>;
    return HttpRequestBase.stream(
      url: futureResults[0] as Uri,
      headers: headers,
      method: method,
      bodyBytesStream: {{#bodyAllowed}}getResolvedBody(context: context, headers: headers){{/bodyAllowed}}{{^bodyAllowed}}Stream.empty(){{/bodyAllowed}},
      context: context,
    );
  }
}

{{#bodyAllowed}}
/// A version of [{{classname}}{{operationIdCamelCase}}Request], where you can send arbitrary bytes in the body.
class {{classname}}{{operationIdCamelCase}}RequestUnsafe extends {{classname}}{{operationIdCamelCase}}Request {
  final Stream<Uint8List>? bodyBytesStream;

  @override
  final String contentType;

  const {{classname}}{{operationIdCamelCase}}RequestUnsafe({
    this.bodyBytesStream,
    this.contentType = 'application/octet-stream',
    {{#allParams}}
    {{^isFormParam}}{{^isBodyParam}}
    {{>types/required_ctor}} super.{{paramName}},
    {{/isBodyParam}}{{/isFormParam}}
    {{/allParams}}
    super.extraHeaders,
    super.extraQueryParameters,
    super.extraCookies,
  });

  Stream<List<int>> getResolvedBody({
    required Map<String, String> headers,
    Map<String, dynamic> context = const {},
  }) async* {
    final body = this.bodyBytesStream;
    if (body == null) {
      return;
    }
    yield* body;
  }
}



{{#vendorExtensions}}{{#better-consumes}}{{#content}}{{#schema}}
class {{classname}}{{operationIdCamelCase}}Request{{nameInPascalCase}} extends {{classname}}{{operationIdCamelCase}}Request {
  static const specMediaType = r'{{{key}}}';

  @override
  String get contentType => specMediaType;

  final {{>types/variable_recursive}} data;

  /// Pass this to handle serialization and encoding of unkown media types yourself.
  final UnknownMediaTypeHandler? handleUnkownMediaType;

  {{#is_mime_multipart_form-data}}
  /// Pass this to handle serialization of unkown form data values yourself.
  /// A value can result in one or more parts.
  /// returning an empty iterable will skip the field entirely.
  ///
  /// The default behavior is to call [defaultAppendFormDataPart] which will call `.toString`
  /// to stringify the value.
  final AppendFormDataPartHandler? appendUnkownFormDataPart;
  {{/is_mime_multipart_form-data}}

  {{^is_mime_multipart_form-data}}{{#is_mime_multipart}}
  /// Pass this to handle serialization of unkown parts yourself.
  /// A value can result in one or more parts.
  /// returning an empty iterable will skip the part entirely.
  ///
  /// The default behavior is to call [defaultAppendPart] which will call `jsonEncode`
  /// to stringify the value.
  final AppendPartHandler? appendUnkownPart;
  {{/is_mime_multipart}}{{/is_mime_multipart_form-data}}

  {{#extraParameters}}
  final {{>types/param}} {{paramName}};
  {{/extraParameters}}

  const {{classname}}{{operationIdCamelCase}}Request{{nameInPascalCase}}({
    required this.data,
    this.handleUnkownMediaType,
    {{#extraParameters}}
    {{>types/required_ctor}} this.{{paramName}}{{>types/default}},
    {{/extraParameters}}
    {{#allParams}}
    {{^isFormParam}}{{^isBodyParam}}
    {{>types/required_ctor}} super.{{paramName}},
    {{/isBodyParam}}{{/isFormParam}}
    {{/allParams}}
    {{#is_mime_multipart_form-data}}
    this.appendUnkownFormDataPart,
    {{/is_mime_multipart_form-data}}
    {{^is_mime_multipart_form-data}}{{#is_mime_multipart}}
    this.appendUnkownPart,
    {{/is_mime_multipart}}{{/is_mime_multipart_form-data}}
    super.extraHeaders,
    super.extraQueryParameters,
    super.extraCookies,
  });

  @override
  Stream<List<int>> getResolvedBody({
    required Map<String, String> headers,
    Map<String, dynamic> context = const {},
  }) async* {
    //TODO: serialize model, then encode it according to media type.
    final contentType = headers['Content-Type']!;
    final resolvedMediaType = MediaType.parse(contentType);

    final v = data;
    var serialized = {{>types/serialize_recursive}};
    final encoding = OASNetworkingUtils.getEncodingOrDefault(resolvedMediaType);
    Stream<List<int>> _stringResult(String src) {
      return Stream.value(encoding.encode(src));
    }
    final encodingRules = <String, PropertyEncodingRule>{
      {{#content}}{{#encoding}}
      {{#entrySet}}
      r'{{{key}}}': {{#value}}PropertyEncodingRule(
        {{#style}}style: r'{{{style}}}',{{/style}}
        {{#explode}}explode: {{explode}},{{/explode}}
        {{#allowReserved}}allowReserved: {{allowReserved}},{{/allowReserved}}
        {{#contentType}}contentType: MediaType.parse(r'{{{contentType}}}'),{{/contentType}}
        {{#headers}}{{#-first}}
        headers: <String, String>{
        {{/-first}}
        {{>lib/src/apis/request/header_param}}
        {{#-last}}
        },
        {{/-last}}{{/headers}}
      ),{{/value}}
      {{/entrySet}}
      {{/encoding}}{{/content}}
    };

    // Since the user can override mime type at runtime, we need to check the
    // mime type and serialize the model accordingly.
    switch (resolvedMediaType) {
      {{#is_mime_application_json}}
      case MediaType(type: 'application', subtype: 'json'):
        yield* _stringResult(json.encode(serialized));
      {{/is_mime_application_json}}
      {{#is_mime_application_x-www-form-urlencoded}}
      case MediaType(type: 'application', subtype: 'x-www-form-urlencoded'):
        if (serialized is! Map<String, dynamic>) {
          yield* _stringResult(serialized.toString());
          return;
        }
        var result = Uri();

        for (var e in serialized.entries) {
          final rule = encodingRules[e.key];
          final style = rule?.style ?? 'form';
          final explode = rule?.explode ?? (style == 'form');
          result = OpenApiParameterSerializationQuery.fromStyle(style, explode: explode, parameterName: e.key, allowEmptyValue: false,).expandUri(result, e.value);
        }
        var resultString = result.query.toString();
        if (resultString.startsWith('?')) {
          resultString = resultString.substring(1);
        }
        yield* _stringResult(resultString);
      {{/is_mime_application_x-www-form-urlencoded}}
      {{#is_mime_application_xml}}
      case MediaType(type: 'application', subtype: 'xml'):
        break;
      {{/is_mime_application_xml}}
      {{#is_mime_multipart}}
      case MediaType(type: 'multipart'):
        if (serialized is! Map<String, dynamic>) {
          throw ArgumentError('The serialized data must be a map in a multipart request.');
        }

        Stream<HttpPacketMixin> getParts() async* {
          switch (resolvedMediaType.subtype) {
            {{#is_mime_multipart_form-data}}
            case 'form-data':
              for (final e in serialized.entries) {
                final fieldName = e.key;
                final rule = encodingRules[e.key];
                final value = e.value;
                final contentType = rule?.contentType;
                final headers = rule?.headers;
                yield* appendFormDataValue(fieldName, value, contentType, headers, unkownHandler: this.appendUnkownFormDataPart ?? defaultAppendFormDataPart);
              }
            {{/is_mime_multipart_form-data}}
            default:
            {{^is_mime_multipart_form-data}}{{#is_mime_multipart}}
              for (final e in serialized.entries) {
                final key = e.key;
                final value = e.value;
                final rule = encodingRules[key];
                final contentType = rule?.contentType;
                final headers = rule?.headers;
                //key is meaningless here
                yield* appendPartValue(value, contentType, headers, unkownHandler: this.appendUnkownPart ?? defaultAppendPart);
              }
            {{/is_mime_multipart}}{{/is_mime_multipart_form-data}}
          }
        }

        final bodySerializer = MultiPartBodySerializer(
          boundary: resolvedMediaType.parameters['boundary'],
          parts: getParts(),
        );
        final result = await bodySerializer.serialize();
        yield* result.bodyBytesStream;
      {{/is_mime_multipart}}
      {{#is_mime_application_octet-stream}}
      case MediaType(type: 'application', subtype: 'octet-stream'):
        if (serialized is Stream<List<int>>) {
          yield* serialized;
          return;
        }
        if (serialized is List<int>) {
          yield* Stream.value(serialized);
          return;
        }
        if (serialized is XFile) {
          yield* serialized.openRead();
          return;
        }
        yield* _stringResult(serialized.toString());
      {{/is_mime_application_octet-stream}}
      default:
        final handleUnkownMediaType = this.handleUnkownMediaType;
        if (handleUnkownMediaType != null) {
          yield* handleUnkownMediaType(resolvedMediaType, serialized, encoding, encodingRules);
          return;
        }
        yield* _stringResult(serialized.toString());
    }
  }
}{{/schema}}{{/content}}{{/better-consumes}}{{/vendorExtensions}}{{/bodyAllowed}}

{{/operation}}{{/operations}}