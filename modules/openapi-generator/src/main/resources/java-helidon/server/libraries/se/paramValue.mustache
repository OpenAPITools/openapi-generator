{{!
Path parameters:
  * Always required in OpenAPI so there is no need to use Optional.
  * Helidon 3 supports only a single value for a path parameter; 4 supports multiple values. The OpenAPI document tells
    whether to expect 1 or more than 1.
}}{{#isPathParam}}{{#x-helidon-v3}}ValidatorUtils.nonEmpty(request.path().param("{{baseName}}"){{/x-helidon-v3}}{{/isPathParam}}{{!
}}{{#isPathParam}}{{^x-helidon-v3}}ValidatorUtils.nonEmpty(request.path()
                .pathParameters(){{#isContainer}}
                .all("{{baseName}}"){{/isContainer}}{{^isContainer}}
                .first("{{baseName}}")
                .as({{> paramValueAs }}){{/isContainer}}){{/x-helidon-v3}}{{/isPathParam}}{{!
}}{{#isQueryParam}}{{#isPrimitiveType}}request.query{{#x-helidon-v3}}Params{{/x-helidon-v3}}().toMap().getOrDefault("{{baseName}}", List.of()).stream().findFirst(){{/isPrimitiveType}}{{/isQueryParam}}{{!
}}{{#isQueryParam}}{{^isPrimitiveType}}Optional.ofNullable(request.query{{#x-helidon-v3}}Params{{/x-helidon-v3}}().toMap().get("{{baseName}}")){{/isPrimitiveType}}{{/isQueryParam}}{{!
}}{{#isCookieParam}}{{#isPrimitiveType}}request.headers().cookies().toMap().getOrDefault("{{baseName}}", List.of()).stream().findFirst(){{/isPrimitiveType}}{{/isCookieParam}}{{!
}}{{#isCookieParam}}{{^isPrimitiveType}}Optional.ofNullable(request.headers().cookies().toMap().get("{{baseName}}")){{/isPrimitiveType}}{{/isCookieParam}}{{!
}}{{#isHeaderParam}}request.headers().value({{^x-helidon-v3}}HeaderNames.create({{/x-helidon-v3}}"{{baseName}}"{{^x-helidon-v3}}){{/x-helidon-v3}}){{/isHeaderParam}}{{!
}}{{#isFormParam}}Optional.ofNullable({{#isFile}}fileFormContent{{/isFile}}{{^isFile}}nonFileFormContent{{/isFile}}.get("{{baseName}}")){{^isArray}}.flatMap(list->list.stream().findFirst()){{/isArray}}{{/isFormParam}}{{!
}}{{#isPrimitiveType}}{{^isFile}}{{^isString}}
                .map({{!
    }}{{#isDecimal}}BigDecimal::new{{/isDecimal}}{{!
    }}{{#isNumber}}BigDecimal::new{{/isNumber}}{{!
    }}{{#isDate}}LocalDate::parse{{/isDate}}{{#isDateTime}}OffsetDateTime::parse{{/isDateTime}}{{!
    }}{{^isDecimal}}{{^isNumber}}{{^isDate}}{{^isDateTime}}{{{dataType}}}::valueOf{{/isDateTime}}{{/isDate}}{{/isNumber}}{{/isDecimal}}){{!
}}{{/isString}}{{/isFile}}{{/isPrimitiveType}}
                .orElse(null);