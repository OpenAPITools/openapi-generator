package {{package}};

{{#imports}}import {{import}};
{{/imports}}
{{^useAbstractClass}}{{#x-helidon-v3}}
import java.util.logging.Logger;
{{/x-helidon-v3}}{{/useAbstractClass}}
{{^x-helidon-v3}}
import io.helidon.common.Errors;
{{/x-helidon-v3}}
import io.helidon.webserver.{{^x-helidon-v3}}http.{{/x-helidon-v3}}ServerRequest;
import io.helidon.webserver.{{^x-helidon-v3}}http.{{/x-helidon-v3}}ServerResponse;
{{#useBeanValidation}}{{^x-helidon-v3}}import {{rootJavaEEPackage}}.validation.constraints.*;
import {{rootJavaEEPackage}}.validation.Valid;
{{/x-helidon-v3}}{{/useBeanValidation}}{{!
}}{{^x-helidon-v3}}import {{rootJavaEEPackage}}.validation.ValidationException;
{{/x-helidon-v3}}{{!
}}{{#x-helidon-hasGenericTypeDeclarations}}import {{modelPackage}}.GenericTypes;
{{/x-helidon-hasGenericTypeDeclarations}}{{!
}}
{{#operations}}
public class {{classname}}Impl {{^useAbstractClass}}implements{{/useAbstractClass}}{{#useAbstractClass}}extends{{/useAbstractClass}} {{classname}} {

    private static final int HTTP_CODE_NOT_IMPLEMENTED = 501;
{{^useAbstractClass}}
    private static final {{^x-helidon-v3}}System.{{/x-helidon-v3}}Logger LOGGER = {{#x-helidon-v3}}Logger{{/x-helidon-v3}}{{^x-helidon-v3}}System{{/x-helidon-v3}}.getLogger({{classname}}.class.getName());
{{#jackson}}
    private static final ObjectMapper MAPPER = JsonProvider.objectMapper();{{/jackson}}
{{#jsonb}}
    private static final Jsonb JSONB = JsonbBuilder.create();{{/jsonb}}
{{/useAbstractClass}}
{{#operation}}

{{#useAbstractClass}}
    public void handle{{#lambda.titlecase}}{{{operationId}}}{{/lambda.titlecase}}(ServerRequest request, ServerResponse response{{#allParams}}, {{>dataType}} {{paramName}}{{/allParams}}) {
{{/useAbstractClass}}
{{^useAbstractClass}}
{{#x-helidon-v3}}
    public void {{{operationId}}}(ServerRequest request, ServerResponse response{{#allParams}}{{#isBodyParam}}{{#isModel}}, {{{dataType}}} {{paramName}}{{/isModel}}{{/isBodyParam}}{{/allParams}}) {
{{/x-helidon-v3}}
{{^x-helidon-v3}}
    public void {{{operationId}}}(ServerRequest request, ServerResponse response) {
{{!

  If the operation has form parameters we need to generate code to process the request body as form data, creating a Helidon
  Parameters object we can use to assign the individual form variables. That is, unless the body is multipart in which case
  we handle things differently.

}}{{^isMultipart}}{{#formParams}}{{#-first}}        Parameters formParams = request.content().as(Parameters.class);

{{/-first}}{{/formParams}}{{/isMultipart}}{{!
}}{{#isMultipart}}        MultiPart multiPart = request.content().as(MultiPart.class);
        multiPart.forEachRemaining(part -> {
                // TODO: Insert user-implemented handling of multipart data here.
        });
{{/isMultipart}}{{!
}}        ValidatorUtils.Validator validator = ValidatorUtils.validator(LOGGER);
{{#allParams}}{{!
}}{{#isMap}}
        // TODO - user code needed to handle Map for {{#isHeaderParam}}header{{/isHeaderParam}}{{#isQueryParam}}query{{/isQueryParam}}{{#isFormParam}}form{{/isFormParam}}{{#isBodyParam}}body{{/isBodyParam}}{{#isCookieParam}}cookie{{/isCookieParam}} parameter {{paramName}}.{{/isMap}}{{!
}}{{^isMap}}{{!
}}{{!

    We handle form parameters separately here because we handle multipart separate from single part form params.

}}{{^isFormParam}}{{!
}}{{^isBodyParam}}
        {{>paramDecl}} = {{>paramValue}};{{!
}}{{/isBodyParam}}{{!
}}{{#isBodyParam}}{{!
}}{{^isFile}}
        {{>paramDecl}} = {{>bodyParamValue}};{{!
}}{{/isFile}}{{!
}}{{#isFile}}
        InputStream {{paramName}} = request.content().inputStream;{{!
}}{{/isFile}}
{{/isBodyParam}}{{!
}}{{/isFormParam}}{{!
}}{{#isFormParam}}{{^isMultipart}}
        {{>paramDecl}} = {{>paramValue}};{{!
}}{{/isMultipart}}{{/isFormParam}}{{!
}}{{/isMap}}{{!
}}{{/allParams}}
        validator.execute();

        handle{{#lambda.titlecase}}{{operationId}}{{/lambda.titlecase}}(request, response{{#allParams}},
                    {{paramName}}{{/allParams}});
{{/x-helidon-v3}}
{{/useAbstractClass}}
        response.status(HTTP_CODE_NOT_IMPLEMENTED).send();
    }
{{/operation}}

{{#useAbstractClass}}
    public Void handleError(ServerRequest request, ServerResponse response, Throwable throwable) {
        return response.send(throwable);
    }
{{/useAbstractClass}}
{{^useAbstractClass}}
{{^x-helidon-v3}}
    @Override
    public void afterStop() {
        System.out.println("Service {{classname}} is down. Goodbye!");
    }

{{#bodyParam}}{{#isFile}}
    /**
     * Convenience method to transfer an {@link InputStream} (typically the request body content) to a temporary file that will
     * be deleted upon JVM exit.
     *
     * @param inputStream the input stream to copy into a temp file
     * @return {@link java.nio.file.Path} to which the data was written
     */
    static Path toTempFile(InputStream inputStream) {
        try {
            Path tempFilePath = Files.createTempFile("large-file", ".tmp");
            Files.copy(inputStream, tempFilePath, StandardCopyOption.REPLACE_EXISTING);
            tempFilePath.toFile().deleteOnExit();
            return tempFilePath;
        } catch (IOException e) {
            throw new UncheckedIOException(e);
        }
    }{{/isFile}}{{/bodyParam}}{{!
}}{{/x-helidon-v3}}
{{/useAbstractClass}}

{{^x-helidon-v3}}{{!
}}{{#operation}}
{{> opResult }}
{{/operation}}{{!
}}{{#operation}}
    @Override

{{/operation}}{{/x-helidon-v3}}

}
{{/operations}}