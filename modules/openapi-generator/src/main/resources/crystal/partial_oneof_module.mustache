  {{#description}}
  # {{{.}}}
  {{/description}}
  class {{classname}}
    include JSON::Serializable
    include YAML::Serializable

    class SchemaMismatchError < Exception
    end

    {{#oneOf}}
    {{#-first}}
    # List of class defined in oneOf (OpenAPI v3)
    def self.openapi_one_of
      [
    {{/-first}}
        {{{.}}}{{^-last}},{{/-last}}
    {{#-last}}
      ]
    end

    {{/-last}}
    {{/oneOf}}

    {{#discriminator}}
    use_yaml_discriminator {{#propertyName}}"{{{.}}}"{{/propertyName}}, {
      {{#mappedModels}}{{{mappingName}}}: {{{modelName}}}{{^-last}},{{/-last}}{{/mappedModels}}
    }
    {{/discriminator}}

    def self.build(data)
      openapi_one_of.each do |klass|
        begin
          typed_data = find_and_cast_into_type(klass, data)
          return typed_data if typed_data
        rescue ex
          # rescue all errors so we keep iterating even if the current item lookup raises
          Log.trace { ex.message }
        end
      end

      nil
    end

    {{#oneOf}}
    private def self.find_and_cast_into_type(klass : {{{.}}}.class, data)
      return if data.nil?

      Log.trace { "INSPECTING DATA" }
      Log.trace { data.inspect }

      case data
      when NetboxClient::RecursiveHash
        if value = cast_value(array_data: false, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      when Array(NetboxClient::RecursiveHash)
        if value = cast_value(array_data: true, array_class: array_class?(klass), klass: klass, data: data)
          return new(value)
        end
      else
        raise SchemaMismatchError.new("#{data} doesn't match the #{klass} type")
      end
    end
    {{/oneOf}}

    private def self.cast_value(array_data : Bool, array_class : Bool, klass, data)
      if array_class == true && array_data == true
        Log.debug { "Building array of classes: #{klass} / #{data}" }

        klass.from_json(data.to_json)
      elsif array_class == false && array_data == false
        Log.debug { "Building single class: #{klass} / #{data}" }

        klass.from_json(data.to_json)
      end
    end

    private def self.array_class?(klass)
      klass.name.starts_with?("Array(")
    end

    {{#oneOf}}
    def initialize(@value : {{{.}}})
    end

    {{/oneOf}}

    delegate :to_yaml, to: @value
    delegate :to_json, to: @value

    def to_any_h
      {"value" => to_h}
    end

    def to_h
      val = @value
      if val.is_a?(Int32)
        val
      else
        val.to_h
      end
    end
  end
