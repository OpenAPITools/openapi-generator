import {HttpLibrary, RequestContext, ResponseContext} from './http{{importFileExtension}}';
import { from, Observable } from {{#useRxJS}}'rxjs'{{/useRxJS}}{{^useRxJS}}'../rxjsStub{{importFileExtension}}'{{/useRxJS}};
{{#platforms}}
{{#node}}
import { fetch } from 'undici';
{{/node}}
{{#browser}}
import "whatwg-fetch";
{{/browser}}
{{/platforms}}

function withTimeout(fetchFn: any, timeout?: number) {
  return (url: string, options: any = {}) => {
    const controller = new AbortController();
    const userSignal = options.signal as AbortSignal | undefined;

    if (userSignal) {
      if (userSignal.aborted) {
        controller.abort();
      } else {
        userSignal.addEventListener("abort", () => controller.abort());
      }
    }

    let timeoutId: NodeJS.Timeout | undefined;

    if (timeout && timeout > 0) {
      timeoutId = setTimeout(() => controller.abort(), timeout);
    }

    return fetchFn(url, { ...options, signal: controller.signal }).finally(
      () => {
        if (timeoutId) clearTimeout(timeoutId);
      }
    );
  };
}


export class IsomorphicFetchHttpLibrary implements HttpLibrary {

    public send(request: RequestContext): Observable<ResponseContext> {
        let method = request.getHttpMethod().toString();
        let body = request.getBody();

        const effectiveFetch = withTimeout(fetch, request.getTimeout?.());
        const resultPromise = effectiveFetch(request.getUrl(), {
            method: method,
            body: body as any,
            headers: request.getHeaders(),
            signal: request.getSignal(),
            {{#platforms}}
            {{#node}}
            dispatcher: request.getDispatcher(),
            {{/node}}
            {{#browser}}
            credentials: "same-origin"
            {{/browser}}
            {{/platforms}}
        }).then((resp: any) => {
            const headers: { [name: string]: string } = {};
            resp.headers.forEach((value: string, name: string) => {
              headers[name] = value;
            });

            {{#platforms}}
            {{#node}}
            const body = {
              text: () => resp.text(),
              binary: () => resp.buffer()
            };
            {{/node}}
            {{^node}}
            const body = {
              text: () => resp.text(),
              binary: () => resp.blob()
            };
            {{/node}}
            {{/platforms}}
            return new ResponseContext(resp.status, headers, body);
        });

        return from<Promise<ResponseContext>>(resultPromise);

    }
}
