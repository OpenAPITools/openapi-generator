{{#hasImports}}
{{#imports}}
import type { {{{.}}} } from './{{.}}{{importFileExtension}}';
import {
    instanceOf{{{.}}},
    {{{.}}}FromJSON,
    {{{.}}}FromJSONTyped,
    {{{.}}}ToJSON,
} from './{{.}}{{importFileExtension}}';
{{/imports}}

{{/hasImports}}
{{>modelOneOfInterfaces}}

export function {{classname}}FromJSON(json: any): {{classname}} {
    return {{classname}}FromJSONTyped(json, false);
}

export function {{classname}}FromJSONTyped(json: any, ignoreDiscriminator: boolean): {{classname}} {
    if (json == null) {
        return json;
    }
{{#discriminator}}
    switch (json['{{discriminator.propertyBaseName}}']) {
{{#discriminator.mappedModels}}
        case '{{mappingName}}':
            return Object.assign({}, {{modelName}}FromJSONTyped(json, true), { {{discriminator.propertyName}}: '{{mappingName}}' } as const);
{{/discriminator.mappedModels}}
        default:
            throw new Error(`No variant of {{classname}} exists with '{{discriminator.propertyName}}=${json['{{discriminator.propertyName}}']}'`);
    }
{{/discriminator}}
{{^discriminator}}
    {{#oneOfStringEnums}}
    if (json === "{{{.}}}") {
        return json;
    }
    {{/oneOfStringEnums}}
    {{#hasStringOneOf}}
    if (json instanceof String) {
        return json as {{classname}};
    }
    {{/hasStringOneOf}}
    if (!(json instanceof Object)){
        return {} as any;
    }
    {{#hasStringArrayOneOf}}
    if (Array.isArray(json) && json.every(item => item instanceof String)) {
        return json as Array<string>;
    }
    {{/hasStringArrayOneOf}}
    {{#oneOfModels}}
    if (instanceOf{{{.}}}(json)) {
        return {{{.}}}FromJSONTyped(json, true);
    }
    {{/oneOfModels}}
    {{#oneOfArrays}}
    {{#-first}}
    if (Array.isArray(json) && json.every(item => item instanceof Object)) {
    {{/-first}}
        if (json.every(item => instanceOf{{{.}}}(item as Object))) {
            return json.map(value => {{{.}}}FromJSONTyped(value, true));
        }
    {{#-last}}
    }
    {{/-last}}
    {{/oneOfArrays}}

    return {} as any;
{{/discriminator}}
}

export function {{classname}}ToJSON(json: any): any {
    return {{classname}}ToJSONTyped(json, false);
}

export function {{classname}}ToJSONTyped(value?: {{classname}} | null, ignoreDiscriminator: boolean = false): any {
    if (value == null) {
        return value;
    }
{{#discriminator}}
    switch (value['{{discriminator.propertyName}}']) {
{{#discriminator.mappedModels}}
        case '{{mappingName}}':
            return Object.assign({}, {{modelName}}ToJSON(value), { {{discriminator.propertyName}}: '{{mappingName}}' } as const);
{{/discriminator.mappedModels}}
        default:
            throw new Error(`No variant of {{classname}} exists with '{{discriminator.propertyName}}=${value['{{discriminator.propertyName}}']}'`);
    }
{{/discriminator}}

{{^discriminator}}
    {{#oneOfStringEnums}}
    if (value === "{{{.}}}") {
        return value;
    }
    {{/oneOfStringEnums}}
    {{#hasStringOneOf}}
    if (value instanceof String) {
        return value;
    }
    {{/hasStringOneOf}}
    if (!(value instanceof Object)){
        return {};
    }
    {{#hasStringArrayOneOf}}
    if (Array.isArray(value) && value.every(item => item instanceof String)) {
        return value;
    }
    {{/hasStringArrayOneOf}}
    {{#oneOfModels}}
    if (instanceOf{{{.}}}(value)) {
        return {{{.}}}ToJSON(value as {{{.}}});
    }
    {{/oneOfModels}}
    {{#oneOfArrays}}
    {{#-first}}
    if (Array.isArray(value) && value.every(item => item instanceof Object)) {
    {{/-first}}
        if (value.every(item => instanceOf{{{.}}}(item as Object))) {
            return value.map(value => {{{.}}}ToJSON(value as {{{.}}}));
        }
    {{#-last}}
    }
    {{/-last}}
    {{/oneOfArrays}}

    return {};
{{/discriminator}}
}
