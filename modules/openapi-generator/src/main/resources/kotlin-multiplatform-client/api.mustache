{{>licenseInfo}}
@file:Suppress("UnusedImport")

package {{apiPackage}}

{{#imports}}import {{import}}
{{/imports}}

import {{packageName}}.infrastructure.*
import io.ktor.client.HttpClient
import io.ktor.client.request.forms.formData
import io.ktor.client.engine.HttpClientEngine
import io.ktor.client.features.json.serializer.KotlinxSerializer
import io.ktor.client.request.forms.FormPart
import io.ktor.client.utils.EmptyContent
import kotlinx.serialization.json.Json
import io.ktor.http.ParametersBuilder
import kotlinx.serialization.Serializable
import kotlinx.serialization.KSerializer
import kotlinx.serialization.builtins.ListSerializer
import kotlinx.serialization.builtins.serializer
import kotlinx.serialization.descriptors.PrimitiveKind
import kotlinx.serialization.descriptors.PrimitiveSerialDescriptor
import kotlinx.serialization.encoding.Decoder
import kotlinx.serialization.encoding.Encoder

{{#operations}}
@Suppress(
    "unused",
    "RemoveRedundantQualifierName",
    "RemoveExplicitTypeArguments",
    "RemoveRedundantCallsOfConversionMethods",
    "DuplicatedCode",
    "UnnecessaryVariable",
)
public class {{classname}} : ApiClientBase {
    public constructor(
        baseUrl: String = "{{{basePath}}}",
        httpClientEngine: HttpClientEngine? = null,
        json: Json = Json {}
    ) : super(baseUrl, httpClientEngine, json)

    internal constructor(baseUrl: String, client: HttpClient, serializer: KotlinxSerializer) : super(
        baseUrl,
        client,
        serializer
    )

    {{#operation}}
    /**
     * {{summary}}
     * {{notes}}
    {{#allParams}} * @param {{{paramName}}} {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
    {{/allParams}} * @return {{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}
     */
    {{#returnType}}
    @Suppress("UNCHECKED_CAST")
    {{/returnType}}
    public suspend fun {{operationId}}(
        {{#allParams}}
        {{{paramName}}}: {{{dataType}}}{{^required}}? = null{{/required}}{{#hasMore}},{{/hasMore}}
        {{/allParams}}
    ): HttpResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Unit{{/returnType}}> {
        {{! TODO: Optimize all the ?.let to only the places where it's needed }}
        val authNamesOag = listOf<String>({{#authMethods}}"{{name}}"{{#hasMore}}, {{/hasMore}}{{/authMethods}})

        val bodyOag = {{#hasBodyParam}}{{#bodyParam}}{{#isListContainer}}{{^required}}{{{paramName}}}?.let { {{/required}}{{operationIdCamelCase}}Request({{{paramName}}}{{^isList}}.asList(){{/isList}}){{^required}} }{{/required}}{{/isListContainer}}{{^isListContainer}}{{#isMapContainer}}{{^required}}{{{paramName}}}?.let { {{/required}}{{operationIdCamelCase}}Request({{{paramName}}}){{^required}} }{{/required}}{{/isMapContainer}}{{^isMapContainer}}{{{paramName}}}{{/isMapContainer}}{{/isListContainer}}{{/bodyParam}}{{/hasBodyParam}}
            {{^hasBodyParam}}
            {{#hasFormParams}}
            {{#isMultipart}}
            formData {
                {{#formParams}}
                {{^required}}{{{paramName}}}?.let { {{/required}}append(FormPart("{{{baseName}}}", {{{paramName}}})){{^required}} }{{/required}}
                {{/formParams}}
            }
            {{/isMultipart}}
            {{^isMultipart}}
            ParametersBuilder().also {
                {{#formParams}}
                {{^required}}{{{paramName}}}?.apply { {{/required}}it.append("{{{baseName}}}", {{{paramName}}}.toString()){{^required}} }{{/required}}
                {{/formParams}}
            }.build()
            {{/isMultipart}}
            {{/hasFormParams}}
            {{^hasFormParams}}
            EmptyContent
            {{/hasFormParams}}
            {{/hasBodyParam}}

        val queriesOag = Queries {
            {{#queryParams}}
            {{#isContainer}}
            {{#isMapContainer}}
            {{^required}}if ({{{paramName}}} != null) {{/required}}addMap({{{paramName}}})
            {{/isMapContainer}}
            {{^isMapContainer}}
            {{^required}}if ({{{paramName}}} != null) {{/required}}addMulti("{{baseName}}", {{{paramName}}}, "{{collectionFormat}}")
            {{/isMapContainer}}
            {{/isContainer}}
            {{^isContainer}}
            add("{{baseName}}", {{{paramName}}})
            {{/isContainer}}
            {{/queryParams}}
        }

        val headersOag = mutableMapOf<String, String?>(
            {{#headerParams}}
            "{{baseName}}" to {{#isContainer}}{{{paramName}}}?.joinToString(separator = collectionDelimiter("{{collectionFormat}}")){{/isContainer}}{{^isContainer}}this?.toString(){{/isContainer}}{{#hasMore}},{{/hasMore}}
            {{/headerParams}}
        )

        val configOag = RequestConfig(
            RequestMethod.{{httpMethod}},
            "{{path}}"{{#pathParams}}.replace("{" + "{{baseName}}" + "}", {{{paramName}}}.toString()){{/pathParams}},
            queries = queriesOag,
            headers = headersOag
        )

        return {{#hasBodyParam}}jsonRequest{{/hasBodyParam}}{{^hasBodyParam}}{{#hasFormParams}}{{#isMultipart}}multipartFormRequest{{/isMultipart}}{{^isMultipart}}urlEncodedFormRequest{{/isMultipart}}{{/hasFormParams}}{{^hasFormParams}}request{{/hasFormParams}}{{/hasBodyParam}}(
            configOag,
            bodyOag,
            authNamesOag
        ).{{#isListContainer}}wrap<{{operationIdCamelCase}}Response>().map { value{{^isList}}.toTypedArray(){{/isList}} }{{/isListContainer}}{{^isListContainer}}{{#isMapContainer}}wrap<{{operationIdCamelCase}}Response>().map { value }{{/isMapContainer}}{{^isMapContainer}}wrap(){{/isMapContainer}}{{/isListContainer}}
    }
{{#hasBodyParam}}

{{#bodyParam}}
{{#isListContainer}}{{>serial_wrapper_request_list}}{{/isListContainer}}{{#isMapContainer}}{{>serial_wrapper_request_map}}{{/isMapContainer}}
{{/bodyParam}}
{{/hasBodyParam}}
{{#isListContainer}}
{{>serial_wrapper_response_list}}
{{/isListContainer}}
{{#isMapContainer}}
{{>serial_wrapper_response_map}}
{{/isMapContainer}}
{{/operation}}
}
{{/operations}}
