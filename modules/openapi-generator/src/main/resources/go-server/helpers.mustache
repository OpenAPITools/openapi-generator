{{>partial_header}}
package support

import (
	"encoding/json"
	"net/http"
	"io"
	"reflect"
)

// Response return a ImplResponse struct filled
func Response(code int, body interface{}) ImplResponse {
	return ImplResponse {
		Code: code,
		{{#addResponseHeaders}}
		Headers: nil,
		{{/addResponseHeaders}}
		Body: body,
	}
}
{{#addResponseHeaders}}

// ResponseWithHeaders return a ImplResponse struct filled, including headers
func ResponseWithHeaders(code int, headers map[string][]string, body interface{}) ImplResponse {
	return ImplResponse {
		Code: code,
		Headers: headers,
		Body: body,
	}
}
{{/addResponseHeaders}}

// IsZeroValue checks if the val is the zero-ed value.
func IsZeroValue(val interface{}) bool {
	return val == nil || reflect.DeepEqual(val, reflect.Zero(reflect.TypeOf(val)).Interface())
}

// AssertRecurseInterfaceRequired recursively checks each struct in a slice against the callback.
// This method traverse nested slices in a preorder fashion.
func AssertRecurseInterfaceRequired(obj interface{}, callback func(interface{}) error) error {
	return AssertRecurseValueRequired(reflect.ValueOf(obj), callback)
}

// AssertRecurseValueRequired checks each struct in the nested slice against the callback.
// This method traverse nested slices in a preorder fashion.
func AssertRecurseValueRequired(value reflect.Value, callback func(interface{}) error) error {
	switch value.Kind() {
	// If it is a struct we check using callback
	case reflect.Struct:
		if err := callback(value.Interface()); err != nil {
			return err
		}

	// If it is a slice we continue recursion
	case reflect.Slice:
		for i := 0; i < value.Len(); i += 1 {
			if err := AssertRecurseValueRequired(value.Index(i), callback); err != nil {
				return err
			}
		}
	}
	return nil
}

// EncodeJSONResponse uses the json encoder to write an interface to the http response with an optional status code
func EncodeJSONResponse(i interface{}, status *int,{{#addResponseHeaders}} headers map[string][]string,{{/addResponseHeaders}} w http.ResponseWriter) error {
	{{#addResponseHeaders}}
	wHeader := w.Header()
	if headers != nil {
		for key, values := range headers {
			for _, value := range values {
				wHeader.Add(key, value)
			}
		}
	}
	wHeader.Set("Content-Type", "application/json; charset=UTF-8")
	{{/addResponseHeaders}}
	{{^addResponseHeaders}}
	w.Header().Set("Content-Type", "application/json; charset=UTF-8")
	{{/addResponseHeaders}}
	if status != nil {
		w.WriteHeader(*status)
	} else {
		w.WriteHeader(http.StatusOK)
	}

	return json.NewEncoder(w).Encode(i)
}

// NewJSONDecoder creates a jew json decoder to decode an http body.
func NewJSONDecoder(r io.Reader) *json.Decoder {
	return json.NewDecoder(r)
}
