{{#discriminator}}
encode{{classname}} : {{classname}} -> Json.Encode.Value
encode{{classname}} model =
    case model of{{#mappedModels}}
        {{classname}}{{modelName}} subModel ->
            encode{{modelName}}WithTag ("{{discriminatorName}}", "{{mappingName}}") subModel
{{/mappedModels}}


{{/discriminator}}
encode{{#discriminator}}Base{{/discriminator}}{{classname}} : {{#discriminator}}Base{{/discriminator}}{{classname}} -> Json.Encode.Value
encode{{#discriminator}}Base{{/discriminator}}{{classname}} =
    encodeObject << encode{{#discriminator}}Base{{/discriminator}}{{classname}}Pairs


encode{{#discriminator}}Base{{/discriminator}}{{classname}}WithTag : ( String, String ) -> {{#discriminator}}Base{{/discriminator}}{{classname}} -> Json.Encode.Value
encode{{#discriminator}}Base{{/discriminator}}{{classname}}WithTag (tagField, tag) model =
    encodeObject (encode{{#discriminator}}Base{{/discriminator}}{{classname}}Pairs model ++ [ encode tagField Json.Encode.string tag ])


encode{{#discriminator}}Base{{/discriminator}}{{classname}}Pairs : {{#discriminator}}Base{{/discriminator}}{{classname}} -> List EncodedField
encode{{#discriminator}}Base{{/discriminator}}{{classname}}Pairs model =
    let
        pairs =
{{#vars}}            {{#-first}}[{{/-first}}{{^-first}},{{/-first}} {{>recordFieldEncoder}}
{{/vars}}
            ]
    in
    {{#parent}}{{#allOf}}encode{{.}}Pairs model.{{#lambda.camelcase}}{{.}}{{/lambda.camelcase}} ++ {{/allOf}}{{/parent}}pairs{{#vars}}{{#isEnum}}

{{>customTypeEncoder}}
{{/isEnum}}{{/vars}}