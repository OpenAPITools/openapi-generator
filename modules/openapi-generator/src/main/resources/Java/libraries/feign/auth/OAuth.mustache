package {{invokerPackage}}.auth;

import com.github.scribejava.core.builder.ServiceBuilder;
import com.github.scribejava.core.model.OAuth2AccessToken;
import com.github.scribejava.core.oauth.OAuth20Service;
import feign.Request.HttpMethod;
import feign.RequestInterceptor;
import feign.RequestTemplate;
import feign.RetryableException;

import java.io.IOException;
import java.util.concurrent.ExecutionException;

{{>generatedAnnotation}}
public class OAuth implements RequestInterceptor {

  static final int MILLIS_PER_SECOND = 1000;

  public interface AccessTokenListener {
    void notify(OAuth2AccessToken token);
  }

  private volatile String accessToken;
  private Long expirationTimeMillis;
  private AccessTokenListener accessTokenListener;
  private OAuth20Service service;
  private OAuthFlow flow;
  private String scopes;
  private String authorizationUrl;
  private String tokenUrl;

  /**
   * For password grant
   */
  private String username;
  private String password;

  public OAuth(OAuthFlow flow, String authorizationUrl, String tokenUrl, String scopes) {
    this.flow = flow;
    this.scopes = scopes;
    this.authorizationUrl = authorizationUrl;
    this.tokenUrl = tokenUrl;
  }

  @Override
  public void apply(RequestTemplate template) {
    // If the request already have an authorization (eg. Basic auth), do nothing
    if (template.headers().containsKey("Authorization")) {
      return;
    }
    // If first time, get the token
    if (expirationTimeMillis == null || System.currentTimeMillis() >= expirationTimeMillis) {
      updateAccessToken(template);
    }
    if (getAccessToken() != null) {
      template.header("Authorization", "Bearer " + getAccessToken());
    }
  }

  /**
   * Configures the client credentials flow
   * @param clientId
   * @param clientSecret
   */
  public void configureClientCredentialsFlow(String clientId, String clientSecret) {
    service = new ServiceBuilder(clientId)
        .apiSecret(clientSecret)
        .defaultScope(scopes)
        .build(new DefaultApi20Impl(authorizationUrl, tokenUrl));
  }

  /**
  * Configures Oauth password grant flow
  * Note: this flow is deprecated.
  *
  * @param username
  * @param password
  * @param clientId
  * @param clientSecret
  */
  public void configurePasswordGrant(String username, String password, String clientId, String clientSecret) {
    this.username = username;
    this.password = password;
    //TODO the clientId and secret are optional according with the RFC
    service = new ServiceBuilder(clientId)
                  .apiSecret(clientSecret)
                  .defaultScope(scopes)
                  .build(new DefaultApi20Impl(authorizationUrl, tokenUrl));
  }

  private synchronized void updateAccessToken(RequestTemplate template) {
    OAuth2AccessToken accessTokenResponse;
    try {
      accessTokenResponse = getOAuth2AccessToken();
    } catch (Exception e) {
      throw new RetryableException(0, e.getMessage(), HttpMethod.POST, e, null, template.request());
    }
    if (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null) {
      setAccessToken(accessTokenResponse.getAccessToken(), accessTokenResponse.getExpiresIn());
      if (accessTokenListener != null) {
        accessTokenListener.notify(accessTokenResponse);
      }
    }
  }

  private OAuth2AccessToken getOAuth2AccessToken() throws IOException, InterruptedException, ExecutionException {
    switch (flow) {
      case application:
        //CLIENT Credentials grant
        //TODO validate required parameters
        return service.getAccessTokenClientCredentialsGrant(scopes);
      case password:
        return service.getAccessTokenPasswordGrant(username, password, scopes);
      default:
        throw new RuntimeException("Flow not implemented");
    }
  }

  public synchronized void registerAccessTokenListener(AccessTokenListener accessTokenListener) {
    this.accessTokenListener = accessTokenListener;
  }

  public synchronized String getAccessToken() {
    return accessToken;
  }

  public synchronized void setAccessToken(String accessToken, Integer expiresIn) {
    this.accessToken = accessToken;
    this.expirationTimeMillis = expiresIn == null ? null : System.currentTimeMillis() + expiresIn * MILLIS_PER_SECOND;
  }

}
