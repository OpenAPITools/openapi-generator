{{#vendorExtensions.x-is-pure}}
    {{^hasDiscriminatorWithNonEmptyMapping}}
        factory {{classname}}.fromJson(Map<String, dynamic> json) => _${{classname}}FromJson(json);
    {{/hasDiscriminatorWithNonEmptyMapping}}
    {{#hasDiscriminatorWithNonEmptyMapping}}
        factory {{classname}}.fromJson(Map<String, dynamic> json) {
        {{#discriminator}}
            switch(json['{{propertyBaseName}}']){
            {{#mappedModels}}
                case '{{mappingName}}':
                return {{classname}}.{{#lambda.camelcase}}{{#lambda.lowercase}}{{mappingName}}{{/lambda.lowercase}}{{/lambda.camelcase}}(
                {{#lambda.camelcase}}{{modelName}}{{/lambda.camelcase}} : {{modelName}}.fromJson(json),
                );
            {{/mappedModels}}
            }
        {{/discriminator}}
        return {{classname}}.unknown(json: json);
        }
    {{/hasDiscriminatorWithNonEmptyMapping}}
{{/vendorExtensions.x-is-pure}}
{{^vendorExtensions.x-is-pure}}
    {{#vendorExtensions.x-is-child}}
        {{^hasDiscriminatorWithNonEmptyMapping}}
            factory {{classname}}.fromJson(Map<String, dynamic> json) => _${{classname}}FromJson(json);
        {{/hasDiscriminatorWithNonEmptyMapping}}
    {{/vendorExtensions.x-is-child}}
{{/vendorExtensions.x-is-pure}}

{{^vendorExtensions.x-is-pure}}
{{#hasDiscriminatorWithNonEmptyMapping}}
    factory {{classname}}.fromJson(Map<String, dynamic> json) {
        {{#discriminator}}
            switch(json['{{propertyBaseName}}']){
                {{#mappedModels}}
                    case '{{mappingName}}':
                        return {{classname}}.{{#lambda.camelcase}}{{#lambda.lowercase}}{{mappingName}}{{/lambda.lowercase}}{{/lambda.camelcase}}(
                            {{#lambda.camelcase}}{{modelName}}{{/lambda.camelcase}} : {{modelName}}.fromJson(json),
                        );
                {{/mappedModels}}
            }
        {{/discriminator}}
        return {{classname}}.unknown(json: json);
    }
{{/hasDiscriminatorWithNonEmptyMapping}}
{{/vendorExtensions.x-is-pure}}

{{^vendorExtensions.x-is-pure}}
    {{^vendorExtensions.x-is-child}}
        {{^hasDiscriminatorWithNonEmptyMapping}}
            factory {{classname}}.fromJson(Map<String, dynamic> json) {
                {{classname}}? deserializedModel;
                {{#discriminator}}
                    // A discriminator property is specified but no mapping
                    // is provided in the spec, so we expect the property to
                    // have the value of the name of the model. Model prefix &
                    // suffix are ignored, as this is not known by the api provider
                    switch(json['{{propertyBaseName}}']){
                    {{#anyOf}}
                        case '{{#DelModelNamePrefixSuffix}}{{{.}}}{{/DelModelNamePrefixSuffix}}':
                            deserializedModel =  {{classname}}.as{{#lambda.titlecase}}{{#PrimitiveInUnion}}{{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}(
                            {{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}Value : {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}.fromJson(json),
                            );
                            break;
                    {{/anyOf}}
                    {{#oneOf}}
                        case '{{#DelModelNamePrefixSuffix}}{{{.}}}{{/DelModelNamePrefixSuffix}}':
                            deserializedModel =  {{classname}}.as{{#lambda.titlecase}}{{#PrimitiveInUnion}}{{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}(
                            {{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}Value : {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}.fromJson(json),
                            );
                            break;
                    {{/oneOf}}
                        default:
                            break;
                    }
                {{/discriminator}}
                {{^discriminator}}
                    // A discriminator property is not defined in the spec so
                    // we try to parse the json against all the models and try to
                    // return one of the valid model. Note: this approach tries
                    // to return one valid model and if more than one model
                    // is valid it then returns unknown type along with the json so
                    // the consumer can decide which model it is.
                    final fromJsonMethods = <FromJsonMethodType<dynamic>>[{{#anyOf}}{{#lambda.titlecase}}{{#PrimitiveFromJson}}{{{.}}}{{/PrimitiveFromJson}}{{/lambda.titlecase}}.fromJson,{{/anyOf}}{{#oneOf}}{{#lambda.titlecase}}{{#PrimitiveFromJson}}{{{.}}}{{/PrimitiveFromJson}}{{/lambda.titlecase}}.fromJson,{{/oneOf}}];
                    final deserializedModels = <{{classname}}>[];
                    for (final fromJsonMethod in fromJsonMethods) {
                        try {
                            final dynamic parsedModel= fromJsonMethod.call(json);
                            // Note following line won't be executed if already the above parsing fails.
                            {{#anyOf}}
                                    if (parsedModel is {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}) {
                                    deserializedModel =  {{classname}}.as{{#lambda.titlecase}}{{#PrimitiveInUnion}}{{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}(
                                {{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}Value : parsedModel,
                                    );
                                    } else
                            {{/anyOf}}
                            {{#oneOf}}
                                    if (parsedModel is {{#lambda.titlecase}}{{#PrimitiveInUnion}}{{{.}}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}) {
                                    deserializedModel =  {{classname}}.as{{#lambda.titlecase}}{{#PrimitiveInUnion}}{{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}{{/PrimitiveInUnion}}{{/lambda.titlecase}}(
                                {{#lambda.camelcase}}{{{.}}}{{/lambda.camelcase}}Value : parsedModel,
                                    );
                                    } else
                            {{/oneOf}}
                            {
                            deserializedModel =  {{classname}}.unknown(json: json);
                            }
                            deserializedModels.add(deserializedModel);
                        } catch (e) {
                            // We are suppressing the deserialization error when the json could not
                            // be parsed into one of the model. Because we return [{{classname}}.unknown]
                            // if the deserialization fails.
                        }
                    }
                    // Return an unknown type when the incoming json parses into more than one models.
                    // Since we pass deserializedModels, clients can still use the deserialized model.
                    // EvenThough this is valid for AnyOf types, Dart doesn't have polymorphic types.
                    // So we still return this as an unknown type.
                    if(deserializedModels.length > 1){
                        deserializedModel =  {{classname}}.unknown(
                            json: json,
                            deserializedModels: deserializedModels,
                            errorType: DeserializationErrorType.MoreThanOneTypeSatisfied,
                        );
                    }
                {{/discriminator}}


                return deserializedModel ?? {{classname}}.unknown(json: json);
            }
        {{/hasDiscriminatorWithNonEmptyMapping}}
    {{/vendorExtensions.x-is-child}}
{{/vendorExtensions.x-is-pure}}