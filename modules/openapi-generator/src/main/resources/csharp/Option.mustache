// <auto-generated>
{{>partial_header}}

using System;
using Newtonsoft.Json;

{{#nrt}}
#nullable enable

{{/nrt}}

namespace {{packageName}}.{{clientPackage}}
{
    public class OptionConverter<T> : JsonConverter<Option<T>>
    {
        public override void WriteJson(JsonWriter writer, Option<T> value, JsonSerializer serializer)
        {
            if (!value.IsSet)
            {
                writer.WriteNull();
            }
            else
            {
                serializer.Serialize(writer, value.Value);
            }
        }

        public override Option<T> ReadJson(JsonReader reader, Type objectType, Option<T> existingValue, bool hasExistingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null)
            {
                return new Option<T>();
            }

            T val = serializer.Deserialize<T>(reader);
            return val != null ? new Option<T>(val) : new Option<T>();
        }
    }

    public class OptionConverterFactory : JsonConverter
    {
        public override bool CanConvert(Type objectType)
            => objectType.IsGenericType && objectType.GetGenericTypeDefinition() == typeof(Option<>);

        public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
        {
            Type innerType = value?.GetType().GetGenericArguments()[0] ?? typeof(object);
            var converterType = typeof(OptionConverter<>).MakeGenericType(innerType);
            var converter = (JsonConverter)Activator.CreateInstance(converterType);
            converter.WriteJson(writer, value, serializer);
        }

        public override object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer)
        {
            Type innerType = objectType.GetGenericArguments()[0];
            var converterType = typeof(OptionConverter<>).MakeGenericType(innerType);
            var converter = (JsonConverter)Activator.CreateInstance(converterType)!;
            return converter.ReadJson(reader, objectType, existingValue, serializer);
        }
    }

    /// <summary>
    /// A wrapper for operation parameters which are not required
    /// </summary>
    public struct Option<TType>
    {
        /// <summary>
        /// The value to send to the server
        /// </summary>
        public TType Value { get; }

        /// <summary>
        /// When true the value will be sent to the server
        /// </summary>
        public bool IsSet { get; }

        /// <summary>
        /// A wrapper for operation parameters which are not required
        /// </summary>
        /// <param name="value"></param>
        public Option(TType value)
        {
            IsSet = true;
            Value = value;
        }

        {{#equatable}}
        public bool Equals(Option<TType> other)
        {
        if (IsSet != other.IsSet) {
            return false;
        }
        if (!IsSet) {
            return true;
        }
            return object.Equals(Value, other.Value);
        }
        {{/equatable}}

        /// <summary>
        /// Implicitly converts this option to the contained type
        /// </summary>
        /// <param name="option"></param>
        public static implicit operator TType(Option<TType> option) => option.Value;

        /// <summary>
        /// Implicitly converts the provided value to an Option
        /// </summary>
        /// <param name="value"></param>
        public static implicit operator Option<TType>(TType value) => new Option<TType>(value);
    }
}