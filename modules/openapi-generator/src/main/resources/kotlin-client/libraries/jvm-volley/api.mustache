package {{apiPackage}}

// Steve was here
import android.content.Context
import com.android.volley.Request
import com.android.volley.RequestQueue
import com.android.volley.Response
import com.android.volley.toolbox.BaseHttpStack
import com.android.volley.toolbox.Volley
import java.util.*;
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException
import kotlin.coroutines.suspendCoroutine
import org.apache.http.entity.mime.MultipartEntityBuilder;
import com.google.gson.reflect.TypeToken;

import {{packageName}}.infrastructure.ApiClient
import {{packageName}}.request.RequestFactory

import java.io.File;

// Generated import family starts here
{{#imports}}import {{import}}
{{/imports}}
// Generated import family ends here

{{#operations}}
class {{classname}} (
    val context: Context,
    val requestQueue: Lazy<RequestQueue> = lazy(initializer = {
        Volley.newRequestQueue(context.applicationContext)
    }),
    val requestFactory: RequestFactory = RequestFactory()) {

    var basePath = "{{{basePath}}}"
    //var invoker = ApiInvoker.instance
    //fun addHeader(key: String?, value: String?) {
    //    invoker!!.addDefaultHeader(key!!, value!!)
    //}
    // TODO - Set up auth on the invoker/client

    {{#operation}}
    /**
    * {{summary}}
    * {{notes}}
    {{#allParams}}   * @param {{paramName}} {{description}}
    {{/allParams}}   * @return {{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}void{{/returnType}}
    */
    {{#isDeprecated}}
    @Deprecated("This api was deprecated")
    {{/isDeprecated}}
    suspend fun {{operationId}}({{^allParams}}){{/allParams}}{{#allParams}}{{>queryParams}}{{>pathParams}}{{>headerParams}}{{>bodyParams}}{{>formParams}}{{^-last}}, {{/-last}}{{#-last}}){{/-last}}{{/allParams}}: {{#returnType}}{{{returnType}}}?{{/returnType}}{{^returnType}}Unit{{/returnType}} {
        // Here's a funky method
        var postBody: Any? = {{#bodyParam}}{{paramName}}{{/bodyParam}}{{^bodyParam}}null{{/bodyParam}}
        var bodyAsStr: String? = null
        {{#allParams}}
        {{#required}}
        // verify the required parameter '{{paramName}}' is set
        // This is probably taken care of by non-null types anyway
        requireNotNull({{paramName}})
        {{/required}}
        {{/allParams}}

        var localVarContentTypes : Array<String> = arrayOf({{#consumes}}"{{{mediaType}}}"{{^-last}},{{/-last}}{{/consumes}})
        var localVarContentType: String = if (localVarContentTypes.size > 0) { localVarContentTypes[0] } else { "application/json" }

        // Do some work or avoid some work based on what we know about the model, 
        // before we delegate to a pluggable request factory template
        // The request factory template contains only pure code and no templates
        // to make it easy to override with your own.

        // create path and map variables
        val path = "{{{path}}}"{{#pathParams}}.replace("{" + "{{baseName}}" + "}", RequestFactory.escapeString({{{paramName}}}.toString())){{/pathParams}};

        // form params
        val formParams: Map<String, String> = HashMap()

        val queryParams: Map<String, String> = mapOf(
            {{#queryParams}}
            "{{baseName}}" to RequestFactory.parameterToString({{paramName}}),
            {{/queryParams}}
        )

        val headerParams: Map<String, String> = mapOf(
            {{#headerParams}}
            "{{baseName}}" to RequestFactory.parameterToString({{paramName}}),
            {{/headerParams}}
        )

        val contentTypes = arrayOf<String>({{#consumes}}"{{{mediaType}}}"{{^-last}},{{/-last}}{{/consumes}})
        val authNames = arrayOf<String>({{#authMethods}}"{{name}}"{{^-last}}, {{/-last}}{{/authMethods}})

        return suspendCoroutine { continuation ->
            val responseListener = Response.Listener<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Unit{{/returnType}}> { response ->
                continuation.resume(response)
            }

            val errorListener = Response.ErrorListener { error ->
                continuation.resumeWithException(error)
            }

            // Call the correct request builder based on whether we have a return type or a body.
            // All other switching on types must be done in code inside the builder
            val request: Request<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Unit{{/returnType}}> = RequestFactory.build(
                    Request.Method.{{httpMethod}},
                    "$basePath$path",
                    bodyAsStr,
                    headerParams,
                    queryParams,
                    localVarContentType,
                    null,
                    authNames,
                    responseListener,
                    errorListener)

            requestQueue.value.add(request)
        }
    }
    {{/operation}}
}
{{/operations}}
