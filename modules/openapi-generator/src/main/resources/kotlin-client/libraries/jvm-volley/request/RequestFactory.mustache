// Choose a constructor based on the model
// assumes the following local variables are available and have been put into maps
// Knowing the details of an operation it will produce a call to a Volley Request constructor
package {{packageName}}.request

import com.android.volley.NetworkResponse
import com.android.volley.ParseError
import com.android.volley.Request
import com.android.volley.Response
import com.android.volley.toolbox.HttpHeaderParser
import com.android.volley.toolbox.StringRequest
import com.google.gson.Gson
import com.google.gson.JsonSyntaxException
import org.apache.http.Consts
import org.apache.http.entity.ContentType
import java.io.UnsupportedEncodingException
import java.nio.charset.Charset
import java.net.HttpURLConnection
import java.net.URLEncoder
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.*
import kotlin.collections.ArrayList
import java.lang.reflect.Type
import {{packageName}}.auth.Authentication



class RequestFactory {

    // TODO - Move the following helper methods to the request factory
    companion object {
        /** Content type "text/plain" with UTF-8 encoding.  */
        val TEXT_PLAIN_UTF8 = ContentType.create("text/plain", Consts.UTF_8)

        /**
         * ISO 8601 date time format.
         * @see https://en.wikipedia.org/wiki/ISO_8601
         */
        val DATE_TIME_FORMAT = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")

        /**
         * ISO 8601 date format.
         * @see https://en.wikipedia.org/wiki/ISO_8601
         */
        val DATE_FORMAT = SimpleDateFormat("yyyy-MM-dd")
        // fun setUserAgent(userAgent: String) {
        //    INSTANCE!!.addDefaultHeader("User-Agent", userAgent)
        //}

        fun parseDateTime(str: String?): Date {
            return try {
                DATE_TIME_FORMAT.parse(str)
            } catch (e: ParseException) {
                throw RuntimeException(e)
            }
        }

        fun parseDate(str: String?): Date {
            return try {
                DATE_FORMAT.parse(str)
            } catch (e: ParseException) {
                throw RuntimeException(e)
            }
        }

        fun formatDateTime(datetime: Date?): String {
            return DATE_TIME_FORMAT.format(datetime)
        }

        fun formatDate(date: Date?): String {
            return DATE_FORMAT.format(date)
        }

        fun escapeString(str: String): String {
            return try {
                URLEncoder.encode(str, "UTF-8")
            } catch (e: UnsupportedEncodingException) {
                str
            }
        }

        fun parameterToString(param: Any?): String {
            return if (param == null) {
                ""
            } else if (param is Date) {
                formatDateTime(param as Date?)
            } else if (param is Collection<*>) {
                val b = StringBuilder()
                for (o in param) {
                    if (b.length > 0) {
                        b.append(",")
                    }
                    b.append(o.toString())
                }
                b.toString()
            } else {
                param.toString()
            }
        }

        /*
        Format to {@code Pair} objects.
        */
        @JvmStatic
        fun parameterToPairs(collectionFormat: String?, name: String?, value: Any?): List<Pair<String, String>> {
            var collectionFormat = collectionFormat
            val params: MutableList<Pair<String, String>> = mutableListOf()

            // preconditions
            if (name == null || name.isEmpty() || value == null) return params
            var valueCollection: Collection<*>? = null
            valueCollection = if (value is Collection<*>) {
                value
            } else {
                params.add(Pair(name, parameterToString(value)))
                return params
            }
            if (valueCollection!!.isEmpty()) {
                return params
            }

            // get the collection format
            collectionFormat =
                if (collectionFormat == null || collectionFormat.isEmpty()) "csv" else collectionFormat // default: csv

            // create the params based on the collection format
            if (collectionFormat == "multi") {
                for (item in valueCollection) {
                    params.add(Pair(name, parameterToString(item)))
                }
                return params
            }
            var delimiter = ","
            if (collectionFormat == "csv") {
                delimiter = ","
            } else if (collectionFormat == "ssv") {
                delimiter = " "
            } else if (collectionFormat == "tsv") {
                delimiter = "\t"
            } else if (collectionFormat == "pipes") {
                delimiter = "|"
            }
            val sb = StringBuilder()
            for (item in valueCollection) {
                sb.append(delimiter)
                sb.append(parameterToString(item))
            }
            params.add(Pair(name, sb.substring(1)))
            return params
        }

        /*        @JvmOverloads
        fun initializeInstance(
            cache: Cache? = null,
            network: Network? = null,
            threadPoolSize: Int = 0,
            delivery: ResponseDelivery? = null,
            connectionTimeout: Int = 30
        ) {
            INSTANCE = ApiInvoker(cache, network, threadPoolSize, delivery, connectionTimeout)
            setUserAgent("OpenAPI-Generator/1.0.0/android")

            // Setup authentications (key: authentication name, value: authentication).
            INSTANCE!!.authentications = HashMap()
            // Prevent the authentications from being modified.
            INSTANCE!!.authentications = Collections.unmodifiableMap(INSTANCE!!.authentications)
        }

        @JvmStatic
        val instance: ApiInvoker?
            get() {
                if (INSTANCE == null) initializeInstance()
                return INSTANCE
            }

*/

/*
        @JvmStatic
        fun deserialize(json: String?, containerType: String?, cls: Class<*>): Any? {
            return try {
                if ("list".equals(containerType, ignoreCase = true) || "array".equals(
                        containerType,
                        ignoreCase = true
                    )
                ) {
                    JsonUtil.deserializeToList(json, cls)
                } else if (String::class.java == cls) {
                    if (json != null && json.startsWith("\"") && json.endsWith("\"") && json.length > 1) json.substring(
                        1,
                        json.length - 1
                    ) else json
                } else {
                    JsonUtil.deserializeToObject<Any>(json, cls)
                }
            } catch (e: JsonParseException) {
                throw ApiException(500, e.message)
            }
        }

        fun serialize(obj: Any?): String? {
            return try {
                if (obj != null) JsonUtil.serialize(obj) else null
            } catch (e: Exception) {
                throw ApiException(500, e.message)
            }
        }
*/
        init {
            // Use UTC as the default time zone.
            DATE_TIME_FORMAT.timeZone = TimeZone.getTimeZone("UTC")
            DATE_FORMAT.timeZone = TimeZone.getTimeZone("UTC")
        }

        /**
        * Get authentications (key: authentication name, value: authentication).
        */
        var authentications: Map<String, Authentication>? = mapOf(
            {{#authMethods}}
                {{#isApiKey}}
                    "{{name}}", ApiKeyAuth({{#isKeyInHeader}}"header"{{/isKeyInHeader}}{{^isKeyInHeader}}"query"{{/isKeyInHeader}}, "{{keyParamName}}")
                {{/isApiKey}}
                {{#isBasic}}
                    "{{name}}", HttpBasicAuth()
                {{/isBasic}}
                {{#isOAuth}}
                    // TODO: comment out below as OAuth does not exist
                    //"{{name}}", OAuth()
                {{/isOAuth}}
            {{/authMethods}}
        )

        /**
        * Update query and header parameters based on authentication settings.
        *
        * @param authNames The authentications to apply
        */
        private fun updateParamsForAuth(
            authNames: Array<String>,
            queryParams: List<Pair<String, String>>?,
            headerParams: Map<String, String>
        ) {
            for (authName in authNames) {
                val auth = authentications!![authName] ?: throw RuntimeException("Authentication undefined: $authName")
                auth.applyToParams(queryParams?.toMutableList()!!, headerParams?.toMutableMap())
            }
        }

        private fun getMethodPreconditionCheck() {
            // TODO: Implement
        }

        private fun deleteMethodPreconditionCheck() {
            // TODO: Implement
        }

        fun <T> build(method: Int,
               url : String,
               bodyAsStr: String?,
               headers: Map<String, String>?,
               params: Map<String, String>?,
               contentTypeForBody: String?,
               encodingForParams: String?,
               authNames: Array<String>?,
               responseListener: Response.Listener<T>,
               errorListener: Response.ErrorListener): Request<T> {
                updateParamsForAuth(authNames, params, headers)
            // Pivot on the method (verb), and whether parameters are optional
            return when(method) {
                Request.Method.GET -> {
                    getMethodPreconditionCheck()
                    GsonRequest<T>(method, url,
                        bodyAsStr,
                        headers,
                        params,
                        contentTypeForBody,
                        encodingForParams,
                        responseListener,
                        errorListener)
                }
                Request.Method.DELETE -> {
                    deleteMethodPreconditionCheck()
                    StringRequest(method, url, responseListener as Response.Listener<String>, errorListener) as Request<T>
                }
                Request.Method.POST, Request.Method.PATCH, Request.Method.PUT -> {
                    // TODO: precondition check
                    GsonRequest<T>(method, url,
                        bodyAsStr,
                        headers,
                        params,
                        contentTypeForBody,
                        encodingForParams,
                        responseListener,
                        errorListener)
                }
                else -> {
                    // TODO: Make this better.
                    throw Exception("Unsupported method")
                }
            }
        }

/*        fun <T> build(method: Int,
                       url : String,
                       bodyAsStr: String?,
                       headers: Map<String, String>?,
                       params: Map<String, String>?,
                       contentTypeForBody: String?,
                       encodingForParams: String?,
                       responseListener: Response.Listener<T>,
                       errorListener: Response.ErrorListener): Request<T> {
            // Pivot on the method (verb), and whether parameters are optional
            return when(method) {
                Request.Method.GET -> {
                    getMethodPreconditionCheck(

                    )
                    GsonRequest<T>(method, url,
                       bodyAsStr,
                       clazz,
                       headers,
                       params,
                       contentTypeForBody,
                       encodingForParams,
                       responseListener,
                       errorListener)
                }
                Request.Method.DELETE -> {  deleteMethodPreconditionCheck()
                                            StringRequest(method, url, responseListener as Response.Listener<String>, errorListener) as Request<T>
                }
            }
*/
        }
}
