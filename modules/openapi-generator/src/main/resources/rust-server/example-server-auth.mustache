use swagger::{
    auth::{Basic, Bearer},
    Has, 
    XSpanIdString};
use {{{externCrateName}}}::{AuthenticationApi, Claims};
use crate::server::Server;
use jsonwebtoken::{decode, errors::Error as JwtError, Algorithm, DecodingKey, TokenData, Validation};
use swagger::auth::Authorization;
use log::debug;

// NOTE: Set environment variable RUST_LOG to the name of the executable (or "cargo run") to activate console logging for all loglevels.
//     See https://docs.rs/env_logger/latest/env_logger/  for more details


/// Get a dummy claim with full permissions (all scopes) for testing purposes
fn full_permission_claim() -> Claims {
        Claims {
            sub: "tester@acme.com".to_owned(), 
            company: "ACME".to_owned(),
            iss: "mini-bank-IDP".to_owned(),
            // added a very long expiry time
            exp: 10000000000,
            // In this example code all available Scopes are added, so the current Bearer Token gets fully authorization.
            scopes: [
                {{#authMethods}}
                {{#scopes}}
                        "{{{scope}}}",
                {{/scopes}}
                {{/authMethods}}
            ].join(", ")
        }
}



/// Extract the data from a Bearer token using the provided Key (secret) and using the HS512-algorithm in this example. 
fn extract_token_data(token: &str, key: &[u8]) -> Result<TokenData<Claims>, JwtError> {
    
    // Ensure that you set the correct algorithm and correct key.
    // See https://github.com/Keats/jsonwebtoken for more information.
    let token_data = decode::<Claims>(
        &token,
        &DecodingKey::from_secret(key),
        &Validation::new(Algorithm::HS512),
    )?;

    Ok(token_data)
}

/// Build a swagger-Authorization based on the claims (Assuming claims have been extracted from a validated token)
fn build_authorization(claims: Claims) -> Authorization {
    let mut scopes = std::collections::BTreeSet::<String>::new();
    claims
        .scopes
        .split(",")
        .map(|s| s.trim())
        .for_each(|s| {let _ = scopes.insert(s.to_string()); });
    let scopes = swagger::auth::Scopes::Some(scopes);

    Authorization{
        subject: claims.sub, 
        scopes, 
        issuer: Some(claims.iss)}
}


impl<C> AuthenticationApi for Server<C> where C: Has<XSpanIdString> + Send + Sync {

    /// Implementation of the method to map a Bearer-token to an Authorization
    fn bearer_authorization(&self, bearer: &Bearer) -> Authorization {
        debug!("\tAuthorizationApi: Received Bearer-token, {bearer:#?}");

        let auth_data = extract_token_data(&bearer.token, b"secret").unwrap();
        debug!("\tUnpack auth_data as: {auth_data:#?}");
        let authorization = build_authorization(auth_data.claims);
        authorization
    }

    /// Implementation of the method to map an api-key to an Authorization
    fn apikey_authorization(&self, api_key: &str) -> Authorization {
        debug!("\tAuthorizationApi: Received api-key, {api_key:#?}");

        // TODO: insert the logic to map received apikey to the set of claims 
        let claims = full_permission_claim();

        // and build an authorization out of it
        build_authorization(claims)
    }
    
    /// Implementation of the method to map a basic authentication (username and password) to an Authorization
    fn basic_authorization(&self, basic: &Basic) -> Authorization {
        debug!("\tAuthorizationApi: Received Basic-token, {basic:#?}");

        // TODO: insert the logic to map received apikey to the set of claims 
        let claims = full_permission_claim();

        // and build an authorization out of it
        build_authorization(claims)
    }

} 

