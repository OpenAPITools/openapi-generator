// <auto-generated>
{{>partial_header}}
{{#nullableReferenceTypes}}#nullable enable{{/nullableReferenceTypes}}

using System;
using System.Collections.Generic;
using System.Net;
using System.Threading.Tasks;
using Microsoft.Extensions.Logging;
using System.Net.Http;
using System.Net.Http.Headers;
using {{packageName}}.Client;
{{#hasImport}}
using {{packageName}}.{{modelPackage}};
{{/hasImport}}

namespace {{packageName}}.{{apiPackage}}
{
    {{#operations}}
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    {{>visibility}} interface {{interfacePrefix}}{{classname}}
    {
        /// <summary>
        /// An event to track the health of the server. 
        /// If you store these event args, be sure to purge old event args to prevent a memory leak.
        /// </summary>
        event ClientUtils.EventHandler<ApiResponseEventArgs>? ApiResponded;

        {{#operation}}
        /// <summary>
        /// {{summary}}
        /// </summary>
        /// <remarks>
        /// {{notes}}
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}&gt;&gt;</returns>
        Task<ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>> {{operationId}}WithHttpInfoAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null);
        
        /// <summary>
        /// {{summary}}
        /// </summary>
        /// <remarks>
        /// {{notes}}
        /// </remarks>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}&gt;</returns>
        Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}> {{operationId}}Async({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null);
        
        /// <summary>
        /// {{summary}}
        /// </summary>
        /// <remarks>
        /// {{notes}}
        /// </remarks>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}&gt;</returns>
        Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> {{operationId}}OrDefaultAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null);

        {{/operation}}
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    {{>visibility}} partial class {{classname}} : {{interfacePrefix}}{{classname}}
    {
        /// <summary>
        /// An event to track the health of the server. 
        /// If you store these event args, be sure to purge old event args to prevent a memory leak.
        /// </summary>
        public event ClientUtils.EventHandler<ApiResponseEventArgs>? ApiResponded;

        private readonly ILogger<{{classname}}> _logger;
        private readonly HttpClient _httpClient;{{#hasApiKeyMethods}}
        private readonly TokenProvider<ApiKeyToken> _apiKeyProvider;{{/hasApiKeyMethods}}{{#hasHttpBearerMethods}}
        private readonly TokenProvider<BearerToken> _bearerTokenProvider;{{/hasHttpBearerMethods}}{{#hasHttpBasicMethods}}
        private readonly TokenProvider<BasicToken> _basicTokenProvider;{{/hasHttpBasicMethods}}{{#hasHttpSignatureMethods}}
        private readonly TokenProvider<HttpSignatureToken> _httpSignatureTokenProvider;{{/hasHttpSignatureMethods}}{{#hasOAuthMethods}}
        private readonly TokenProvider<OAuthToken> _oauthTokenProvider;{{/hasOAuthMethods}}

        /// <summary>
        /// Initializes a new instance of the <see cref="{{classname}}"/> class.
        /// </summary>
        /// <returns></returns>
        public {{classname}}(ILogger<{{classname}}> logger, HttpClient httpClient, {{#hasApiKeyMethods}}
            TokenProvider<ApiKeyToken> apiKeyProvider{{/hasApiKeyMethods}}{{#hasHttpBearerMethods}}, 
            TokenProvider<BearerToken> bearerTokenProvider{{/hasHttpBearerMethods}}{{#hasHttpBasicMethods}}, 
            TokenProvider<BasicToken> basicTokenProvider{{/hasHttpBasicMethods}}{{#hasHttpSignatureMethods}}, 
            TokenProvider<HttpSignatureToken> httpSignatureTokenProvider{{/hasHttpSignatureMethods}}{{#hasOAuthMethods}}, 
            TokenProvider<OAuthToken> oauthTokenProvider{{/hasOAuthMethods}})
        {
            _logger = logger;
            _httpClient = httpClient;{{#hasApiKeyMethods}}
            _apiKeyProvider = apiKeyProvider;{{/hasApiKeyMethods}}{{#hasHttpBearerMethods}}
            _bearerTokenProvider = bearerTokenProvider;{{/hasHttpBearerMethods}}{{#hasHttpBasicMethods}}
            _basicTokenProvider = basicTokenProvider;{{/hasHttpBasicMethods}}{{#hasHttpSignatureMethods}}
            _httpSignatureTokenProvider = httpSignatureTokenProvider;{{/hasHttpSignatureMethods}}{{#hasOAuthMethods}}
            _oauthTokenProvider = oauthTokenProvider;{{/hasOAuthMethods}}
        }
        {{#operation}}   

        /// <summary>
        /// {{summary}} {{notes}}
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}"/>&gt;</returns>
        public async Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}> {{operationId}}Async({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null)
        {
            ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> result = await {{operationId}}WithHttpInfoAsync({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}cancellationToken).ConfigureAwait(false);
            return result.Content ?? throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);
        }

        /// <summary>
        /// {{summary}} {{notes}}
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}"/>&gt;</returns>
        public async Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> {{operationId}}OrDefaultAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null)
        {
            ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} result = null;
            try 
            {
                result = await {{operationId}}WithHttpInfoAsync({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}cancellationToken).ConfigureAwait(false);
            }
            catch (Exception)
            {
            }

            return result != null && result.IsSuccessStatusCode
                ? result.Content
                : null;
        }     

        /// <summary>
        /// {{summary}} {{notes}}
        /// </summary>
        /// <exception cref="ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns><see cref="Task"/>&lt;<see cref="ApiResponse{T}"/>&gt; where T : <see cref="{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}"/></returns>
        public async Task<ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>> {{operationId}}WithHttpInfoAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null)
        {
            try
            {
                {{#allParams}}{{#-first}}#pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'{{/-first}}{{#required}}{{#nullableReferenceTypes}}
{{! TODO: add a collection of allRequiredParams so the above does not occur if all parameters are optional }}

                if ({{paramName}} == null)
                    throw new ArgumentNullException(nameof({{paramName}}));{{/nullableReferenceTypes}}{{^nullableReferenceTypes}}{{^vendorExtensions.x-csharp-value-type}}
                    
                if ({{paramName}} == null)
                    throw new ArgumentNullException(nameof({{paramName}}));{{/vendorExtensions.x-csharp-value-type}}{{/nullableReferenceTypes}}{{/required}}{{#-last}}
                
                #pragma warning restore CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'{{/-last}}{{/allParams}}
{{! TODO: add a collection of allRequiredParams so the above does not occur if all parameters are optional }}

                using HttpRequestMessage request = new HttpRequestMessage();

                UriBuilder uriBuilder = new UriBuilder();
                uriBuilder.Host = ClientUtils.HOST;
                uriBuilder.Scheme = ClientUtils.SCHEME;
                uriBuilder.Path = ClientUtils.CONTEXT_PATH + "{{path}}";{{#pathParams}}{{#required}}
                uriBuilder.Path = uriBuilder.Path.Replace("%7B{{baseName}}%7D", Uri.EscapeDataString({{paramName}}.ToString()));{{/required}}{{^required}}

                if ({{paramName}} != null)            
                    uriBuilder.Path = uriBuilder.Path + $"/{ Uri.EscapeDataString({{paramName}}).ToString()) }";
                {{/required}}{{/pathParams}}{{#queryParams}}{{#-first}}

                System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);{{/-first}}{{/queryParams}}{{^queryParams}}{{#authMethods}}{{#isApiKey}}{{#isKeyInQuery}}
                
                System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);{{/isKeyInQuery}}{{/isApiKey}}{{/authMethods}}{{/queryParams}}{{#queryParams}}{{#required}}{{#-first}}

{{! all the redundant tags here are to get the spacing just right }}
                {{/-first}}{{/required}}{{/queryParams}}{{#queryParams}}{{#required}}parseQueryString["{{baseName}}"] = Uri.EscapeDataString({{paramName}}.ToString(){{#nullableReferenceTypes}}!{{/nullableReferenceTypes}});
                {{/required}}{{/queryParams}}{{#queryParams}}{{#-first}}
                {{/-first}}{{/queryParams}}{{#queryParams}}{{^required}}if ({{paramName}} != null)
                    parseQueryString["{{baseName}}"] = Uri.EscapeDataString({{paramName}}.ToString(){{#nullableReferenceTypes}}!{{/nullableReferenceTypes}});

                {{/required}}{{#-last}}uriBuilder.Query = parseQueryString.ToString();{{/-last}}{{/queryParams}}{{#headerParams}}{{#required}}
                
                request.Headers.Add("{{baseName}}", ClientUtils.ParameterToString({{paramName}}));{{/required}}{{^required}}
                
                if ({{paramName}} != null)                
                    request.Headers.Add("{{baseName}}", ClientUtils.ParameterToString({{paramName}}));{{/required}}{{/headerParams}}

                MultipartContent multipartContent = new MultipartContent();

                request.Content = multipartContent;{{#formParams}}{{#-first}}
                
                List<KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>> formParams = new List<KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>>();

                multipartContent.Add(new FormUrlEncodedContent(formParams));{{/-first}}{{^isFile}}{{#required}}
                
                formParams.Add(new KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>("{{baseName}}", ClientUtils.ParameterToString({{paramName}})));{{/required}}{{^required}}

                if ({{paramName}} != null)
                    formParams.Add(new KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>("{{baseName}}", ClientUtils.ParameterToString({{paramName}})));{{/required}}{{/isFile}}{{#isFile}}{{#required}}
                
                multipartContent.Add(new StreamContent({{paramName}}));{{/required}}{{^required}}
                
                if ({{paramName}} != null)
                    multipartContent.Add(new StreamContent({{paramName}}));{{/required}}{{/isFile}}{{/formParams}}{{#bodyParam}}
                    
                if (({{paramName}} as object) is System.IO.Stream stream)
                    request.Content = new StreamContent(stream);
                else
                    request.Content = new StringContent(Newtonsoft.Json.JsonConvert.SerializeObject({{paramName}}, ClientUtils.JsonSerializerSettings));{{/bodyParam}}{{#authMethods}}{{#-first}}

                List<TokenBase> tokens = new List<TokenBase>();{{/-first}}{{#isApiKey}}
                    
                ApiKeyToken apiKey = (ApiKeyToken) await _apiKeyProvider.GetAsync(cancellationToken);
                
                tokens.Add(apiKey);{{#isKeyInHeader}}
                
                apiKey.UseInHeader(request, "{{keyParamName}}");{{/isKeyInHeader}}{{#isKeyInQuery}}
                
                apiKey.UseInQuery(request, uriBuilder, parseQueryString, "{{keyParamName}}");{{/isKeyInQuery}}{{#isKeyInCookie}}
                
                apiKey.UseInCookie(request, parseQueryString, "{{keyParamName}}");{{/isKeyInCookie}}{{/isApiKey}}{{/authMethods}}
                
{{! below line must be after any UseInQuery calls, but before using the HttpSignatureToken}}
                request.RequestUri = uriBuilder.Uri;{{#authMethods}}{{#isBasicBasic}}

                BasicToken basicToken = (BasicToken) await _basicTokenProvider.GetAsync(cancellationToken);

                tokens.Add(basicToken);
                
                basicToken.UseInHeader(request, "{{keyParamName}}");{{/isBasicBasic}}{{#isBasicBearer}}

                BearerToken bearerToken = (BearerToken) await _bearerTokenProvider.GetAsync(cancellationToken);

                tokens.Add(bearerToken);
                
                bearerToken.UseInHeader(request, "{{keyParamName}}");{{/isBasicBearer}}{{#isOAuth}}

                OAuthToken oauthToken = (OAuthToken) await _oauthTokenProvider.GetAsync(cancellationToken);

                tokens.Add(oauthToken);
                
                oauthToken.UseInHeader(request, "{{keyParamName}}");{{/isOAuth}}{{#isHttpSignature}}
                
                HttpSignatureToken signatureToken = (HttpSignatureToken) await _httpSignatureTokenProvider.GetAsync(cancellationToken);

                tokens.Add(signatureToken);

                string requestBody = (await request.Content{{#nullableReferenceTypes}}!{{/nullableReferenceTypes}}.ReadAsStringAsync(cancellationToken.GetValueOrDefault()));

                signatureToken.UseInHeader(request, requestBody, cancellationToken);{{/isHttpSignature}}{{/authMethods}}{{#consumes}}{{#-first}}
                
                string[] contentTypes = new string[] { 
                    {{/-first}}"{{{mediaType}}}"{{^-last}},
                    {{/-last}}{{#-last}} 
                };{{/-last}}{{/consumes}}{{#consumes}}{{#-first}}
                
                string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} contentType = ClientUtils.SelectHeaderContentType(contentTypes);

                if (contentType != null)
                    request.Content.Headers.Add("ContentType", contentType);{{/-first}}{{/consumes}}{{#produces}}{{#-first}}
                
                string[] accepts = new string[] { {{/-first}}{{/produces}}
                    {{#produces}}"{{{mediaType}}}"{{^-last}}, 
                    {{/-last}}{{/produces}}{{#produces}}{{#-last}} 
                };{{/-last}}{{/produces}}{{#produces}}{{#-first}}
                
                string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} accept = ClientUtils.SelectHeaderAccept(accepts);

                if (accept != null)
                    request.Headers.Accept.Add(new MediaTypeWithQualityHeaderValue(accept));
                {{/-first}}{{/produces}}
                request.Method = HttpMethod.{{#lambda.titlecase}}{{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}}{{/lambda.titlecase}};
                
                using HttpResponseMessage responseMessage = await _httpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                DateTime requestedAt = DateTime.UtcNow;

                string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

                if (ApiResponded != null)
                    ApiResponded.Invoke(this, new ApiResponseEventArgs(requestedAt, DateTime.UtcNow, responseMessage.StatusCode, "{{path}}"));

                ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> apiResponse = new ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>(responseMessage, responseContent);

                if (apiResponse.IsSuccessStatusCode)
                    apiResponse.Content = Newtonsoft.Json.JsonConvert.DeserializeObject<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}>(apiResponse.RawContent, ClientUtils.JsonSerializerSettings);{{#authMethods}}
                else if (apiResponse.StatusCode == HttpStatusCode.TooManyRequests)
                    foreach(TokenBase token in tokens)
                        token.BeginRateLimit();{{/authMethods}}

                return apiResponse;
            } 
            catch(Exception e)
            {
                _logger.LogError(e, "An error occured while sending the request to the server.");
                throw;
            }
        }
        {{/operation}}
    }
    {{/operations}}
}
