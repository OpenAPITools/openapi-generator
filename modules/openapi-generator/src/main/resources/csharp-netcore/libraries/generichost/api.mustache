// <auto-generated>
{{>partial_header}}
{{#nullableReferenceTypes}}#nullable enable{{/nullableReferenceTypes}}

using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.Net;
using System.Net.Mime;
using {{packageName}}.Client;
{{#hasImport}}
using {{packageName}}.{{modelPackage}};
{{/hasImport}}

namespace {{packageName}}.{{apiPackage}}
{
    {{#operations}}
    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    {{>visibility}} interface {{interfacePrefix}}{{classname}}
    {
        {{#operation}}
        /// <summary>
        /// {{summary}}
        /// </summary>
        /// <remarks>
        /// {{notes}}
        /// </remarks>
        /// <exception cref="{{packageName}}.Client.ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}&gt;&gt;</returns>
        System.Threading.Tasks.Task<ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>> {{operationId}}WithHttpInfoAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null);
        
        /// <summary>
        /// {{summary}}
        /// </summary>
        /// <remarks>
        /// {{notes}}
        /// </remarks>
        /// <exception cref="{{packageName}}.Client.ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}&gt;</returns>
        System.Threading.Tasks.Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}> {{operationId}}Async({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null);
        
        /// <summary>
        /// {{summary}}
        /// </summary>
        /// <remarks>
        /// {{notes}}
        /// </remarks>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task of ApiResponse&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}&gt;</returns>
        System.Threading.Tasks.Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> {{operationId}}OrDefaultAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null);

        {{/operation}}
    }

    /// <summary>
    /// Represents a collection of functions to interact with the API endpoints
    /// </summary>
    {{>visibility}} partial class {{classname}} : {{interfacePrefix}}{{classname}}
    {
        private readonly System.Net.Http.HttpClient _httpClient;{{#hasApiKeyMethods}}
        private readonly TokenProvider<{{packageName}}.Client.ApiKeyToken> _apiKeyProvider;{{/hasApiKeyMethods}}{{#hasHttpBearerMethods}}
        private readonly TokenProvider<{{packageName}}.Client.BearerToken> _bearerTokenProvider;{{/hasHttpBearerMethods}}{{#hasHttpBasicMethods}}
        private readonly TokenProvider<{{packageName}}.Client.BasicToken> _basicTokenProvider;{{/hasHttpBasicMethods}}{{#hasHttpSignatureMethods}}
        private readonly TokenProvider<{{packageName}}.Client.HttpSignatureToken> _httpSignatureTokenProvider;{{/hasHttpSignatureMethods}}{{#hasOAuthMethods}}
        private readonly TokenProvider<{{packageName}}.Client.OAuthToken> _oauthTokenProvider;{{/hasOAuthMethods}}

        /// <summary>
        /// Initializes a new instance of the <see cref="{{classname}}"/> class.
        /// </summary>
        /// <returns></returns>
        public {{classname}}(System.Net.Http.HttpClient httpClient, {{#hasApiKeyMethods}}
            TokenProvider<{{packageName}}.Client.ApiKeyToken> apiKeyProvider{{/hasApiKeyMethods}}{{#hasHttpBearerMethods}}, 
            TokenProvider<{{packageName}}.Client.BearerToken> bearerTokenProvider{{/hasHttpBearerMethods}}{{#hasHttpBasicMethods}}, 
            TokenProvider<{{packageName}}.Client.BasicToken> basicTokenProvider{{/hasHttpBasicMethods}}{{#hasHttpSignatureMethods}}, 
            TokenProvider<{{packageName}}.Client.HttpSignatureToken> httpSignatureTokenProvider{{/hasHttpSignatureMethods}}{{#hasOAuthMethods}}, 
            TokenProvider<{{packageName}}.Client.OAuthToken> oauthTokenProvider{{/hasOAuthMethods}})
        {
            _httpClient = httpClient;{{#hasApiKeyMethods}}
            _apiKeyProvider = apiKeyProvider;{{/hasApiKeyMethods}}{{#hasHttpBearerMethods}}
            _bearerTokenProvider = bearerTokenProvider;{{/hasHttpBearerMethods}}{{#hasHttpBasicMethods}}
            _basicTokenProvider = basicTokenProvider;{{/hasHttpBasicMethods}}{{#hasHttpSignatureMethods}}
            _httpSignatureTokenProvider = httpSignatureTokenProvider;{{/hasHttpSignatureMethods}}{{#hasOAuthMethods}}
            _oauthTokenProvider = oauthTokenProvider;{{/hasOAuthMethods}}
        }
        {{#operation}}   

        /// <summary>
        /// {{summary}} {{notes}}
        /// </summary>
        /// <exception cref="{{packageName}}.Client.ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}&gt;</returns>
        public async System.Threading.Tasks.Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}> {{operationId}}Async({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null)
        {
            {{packageName}}.Client.ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> result = await {{operationId}}WithHttpInfoAsync({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}cancellationToken).ConfigureAwait(false);
            return result.Content ?? throw new ApiException(result.ReasonPhrase, result.StatusCode, result.RawContent);
        }

        /// <summary>
        /// {{summary}} {{notes}}
        /// </summary>
        /// <exception cref="{{packageName}}.Client.ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}&gt;</returns>
        public async System.Threading.Tasks.Task<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> {{operationId}}OrDefaultAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null)
        {
            {{packageName}}.Client.ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> result = await {{operationId}}WithHttpInfoAsync({{#allParams}}{{paramName}}{{^-last}}, {{/-last}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}cancellationToken).ConfigureAwait(false);
            
            return result.IsSuccessStatusCode
                ? result.Content
                : null;
        }     

        /// <summary>
        /// {{summary}} {{notes}}
        /// </summary>
        /// <exception cref="{{packageName}}.Client.ApiException">Thrown when fails to make API call</exception>
        {{#allParams}}
        /// <param name="{{paramName}}">{{description}}{{^required}} (optional{{#defaultValue}}, default to {{.}}{{/defaultValue}}){{/required}}</param>
        {{/allParams}}
        /// <param name="cancellationToken">Cancellation Token to cancel the request.</param>
        /// <returns>Task&lt;ApiResponse&lt;{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}object{{/returnType}}&gt;&gt;</returns>
        public async System.Threading.Tasks.Task<{{packageName}}.Client.ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>> {{operationId}}WithHttpInfoAsync({{#allParams}}{{#required}}{{{dataType}}} {{paramName}}{{^-last}}, {{/-last}}{{/required}}{{^required}}{{{dataType}}} {{paramName}} = null{{^-last}}, {{/-last}}{{/required}}{{/allParams}}{{#allParams.0}}, {{/allParams.0}}System.Threading.CancellationToken{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} cancellationToken = null)
        {
            {{#allParams}}{{#-first}}#pragma warning disable CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'{{/-first}}{{#required}}{{#nullableReferenceTypes}}
{{! TODO: add a collection of allRequiredParams so the above does not occur if all parameters are optional }}

            if ({{paramName}} == null)
                throw new ArgumentNullException(nameof({{paramName}}));{{/nullableReferenceTypes}}{{^nullableReferenceTypes}}{{^vendorExtensions.x-csharp-value-type}}
                
            if ({{paramName}} == null)
                throw new ArgumentNullException(nameof({{paramName}}));{{/vendorExtensions.x-csharp-value-type}}{{/nullableReferenceTypes}}{{/required}}{{#-last}}
            
            #pragma warning restore CS0472 // The result of the expression is always the same since a value of this type is never equal to 'null'{{/-last}}{{/allParams}}
{{! TODO: add a collection of allRequiredParams so the above does not occur if all parameters are optional }}

            using System.Net.Http.HttpRequestMessage request = new System.Net.Http.HttpRequestMessage();

            UriBuilder uriBuilder = new UriBuilder();
            uriBuilder.Host = ClientUtils.HOST;
            uriBuilder.Scheme = ClientUtils.SCHEME;
            uriBuilder.Path = ClientUtils.CONTEXT_PATH + "{{path}}";{{#pathParams}}{{#required}}
            uriBuilder.Path = uriBuilder.Path.Replace("%7B{{baseName}}%7D", Uri.EscapeDataString({{paramName}}.ToString()));{{/required}}{{^required}}

            if ({{paramName}} != null)            
                uriBuilder.Path = uriBuilder.Path + $"/{ Uri.EscapeDataString({{paramName}}).ToString()) }";
            {{/required}}{{/pathParams}}{{#queryParams}}{{#-first}}

            System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);{{/-first}}{{/queryParams}}{{^queryParams}}{{#authMethods}}{{#isApiKey}}{{#isKeyInQuery}}
            
            System.Collections.Specialized.NameValueCollection parseQueryString = System.Web.HttpUtility.ParseQueryString(string.Empty);{{/isKeyInQuery}}{{/isApiKey}}{{/authMethods}}{{/queryParams}}{{#queryParams}}{{#required}}{{#-first}}

{{! all the redundant tags here are to get the spacing just right }}
            {{/-first}}{{/required}}{{/queryParams}}{{#queryParams}}{{#required}}parseQueryString["{{baseName}}"] = Uri.EscapeDataString({{paramName}}.ToString(){{#nullableReferenceTypes}}!{{/nullableReferenceTypes}});
            {{/required}}{{/queryParams}}{{#queryParams}}{{#-first}}
            {{/-first}}{{/queryParams}}{{#queryParams}}{{^required}}if ({{paramName}} != null)
                parseQueryString["{{baseName}}"] = Uri.EscapeDataString({{paramName}}.ToString(){{#nullableReferenceTypes}}!{{/nullableReferenceTypes}});

            {{/required}}{{#-last}}uriBuilder.Query = parseQueryString.ToString();{{/-last}}{{/queryParams}}{{#headerParams}}{{#required}}
            
            request.Headers.Add("{{baseName}}", {{packageName}}.Client.ClientUtils.ParameterToString({{paramName}}));{{/required}}{{^required}}
            
            if ({{paramName}} != null)                
                request.Headers.Add("{{baseName}}", {{packageName}}.Client.ClientUtils.ParameterToString({{paramName}}));{{/required}}{{/headerParams}}

            System.Net.Http.MultipartContent multipartContent = new System.Net.Http.MultipartContent();

            request.Content = multipartContent;{{#formParams}}{{#-first}}
            
            List<KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>> formParams = new List<KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>>();

            multipartContent.Add(new System.Net.Http.FormUrlEncodedContent(formParams));{{/-first}}{{^isFile}}{{#required}}
            
            formParams.Add(new KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>("{{baseName}}", {{packageName}}.Client.ClientUtils.ParameterToString({{paramName}})));{{/required}}{{^required}}

            if ({{paramName}} != null)
                formParams.Add(new KeyValuePair<string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}, string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>("{{baseName}}", {{packageName}}.Client.ClientUtils.ParameterToString({{paramName}})));{{/required}}{{/isFile}}{{#isFile}}{{#required}}
            
            multipartContent.Add(new System.Net.Http.StreamContent({{paramName}}));{{/required}}{{^required}}
            
            if ({{paramName}} != null)
                multipartContent.Add(new System.Net.Http.StreamContent({{paramName}}));{{/required}}{{/isFile}}{{/formParams}}{{#bodyParam}}
                
            if (({{paramName}} as object) is System.IO.Stream stream)
                request.Content = new System.Net.Http.StreamContent(stream);
            else
                request.Content = new System.Net.Http.StringContent(Newtonsoft.Json.JsonConvert.SerializeObject({{paramName}}, {{packageName}}.Client.ClientUtils.JsonSerializerSettings));{{/bodyParam}}{{#authMethods}}{{#-first}}

            List<TokenBase> tokens = new List<TokenBase>();{{/-first}}{{#isApiKey}}
                
            ApiKeyToken apiKey = (ApiKeyToken) await _apiKeyProvider.GetAsync(cancellationToken);
            
            tokens.Add(apiKey);{{#isKeyInHeader}}
            
            apiKey.UseInHeader(request, "{{keyParamName}}");{{/isKeyInHeader}}{{#isKeyInQuery}}
            
            apiKey.UseInQuery(request, uriBuilder, parseQueryString, "{{keyParamName}}");{{/isKeyInQuery}}{{#isKeyInCookie}}
            
            apiKey.UseInCookie(request, parseQueryString, "{{keyParamName}}");{{/isKeyInCookie}}{{/isApiKey}}{{/authMethods}}
            
{{! below line must be after any UseInQuery calls, but before using the HttpSignatureToken}}
            request.RequestUri = uriBuilder.Uri;{{#authMethods}}{{#isBasicBasic}}

            BasicToken basicToken = (BasicToken) await _basicTokenProvider.GetAsync(cancellationToken);

            tokens.Add(basicToken);
            
            basicToken.UseInHeader(request, "{{keyParamName}}");{{/isBasicBasic}}{{#isBasicBearer}}

            BearerToken bearerToken = (BearerToken) await _bearerTokenProvider.GetAsync(cancellationToken);

            tokens.Add(bearerToken);
            
            bearerToken.UseInHeader(request, "{{keyParamName}}");{{/isBasicBearer}}{{#isOAuth}}

            OAuthToken oauthToken = (OAuthToken) await _oauthTokenProvider.GetAsync(cancellationToken);

            tokens.Add(oauthToken);
            
            oauthToken.UseInHeader(request, "{{keyParamName}}");{{/isOAuth}}{{#isHttpSignature}}
            
            HttpSignatureToken signatureToken = (HttpSignatureToken) await _httpSignatureTokenProvider.GetAsync(cancellationToken);

            tokens.Add(signatureToken);

            string requestBody = (await request.Content{{#nullableReferenceTypes}}!{{/nullableReferenceTypes}}.ReadAsStringAsync(cancellationToken.GetValueOrDefault()));

            signatureToken.UseInHeader(request, requestBody, cancellationToken);{{/isHttpSignature}}{{/authMethods}}{{#consumes}}{{#-first}}
            
            string[] contentTypes = new string[] { 
                {{/-first}}"{{{mediaType}}}"{{^-last}},
                {{/-last}}{{#-last}} 
            };{{/-last}}{{/consumes}}{{#consumes}}{{#-first}}
            
            string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} contentType = {{packageName}}.Client.ClientUtils.SelectHeaderContentType(contentTypes);

            if (contentType != null)
                request.Content.Headers.Add("ContentType", contentType);{{/-first}}{{/consumes}}{{#produces}}{{#-first}}
            
            string[] accepts = new string[] { {{/-first}}{{/produces}}
                {{#produces}}"{{{mediaType}}}"{{^-last}}, 
                {{/-last}}{{/produces}}{{#produces}}{{#-last}} 
            };{{/-last}}{{/produces}}{{#produces}}{{#-first}}
            
            string{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}} accept = {{packageName}}.Client.ClientUtils.SelectHeaderAccept(accepts);

            if (accept != null)
                request.Headers.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue(accept));
            {{/-first}}{{/produces}}
            request.Method = System.Net.Http.HttpMethod.{{#lambda.titlecase}}{{#lambda.lowercase}}{{httpMethod}}{{/lambda.lowercase}}{{/lambda.titlecase}};
            
            using System.Net.Http.HttpResponseMessage responseMessage = await _httpClient.SendAsync(request, cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

            string responseContent = await responseMessage.Content.ReadAsStringAsync(cancellationToken.GetValueOrDefault()).ConfigureAwait(false);

            ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}> apiResponse = new ApiResponse<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}{{#nullableReferenceTypes}}?{{/nullableReferenceTypes}}>(responseMessage, responseContent);

            if (apiResponse.IsSuccessStatusCode)
                apiResponse.Content = Newtonsoft.Json.JsonConvert.DeserializeObject<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}object{{/returnType}}>(apiResponse.RawContent, {{packageName}}.Client.ClientUtils.JsonSerializerSettings);{{#authMethods}}
            else if (apiResponse.StatusCode == HttpStatusCode.TooManyRequests)
                foreach(TokenBase token in tokens)
                    token.BeginRateLimit();{{/authMethods}}

            return apiResponse;
        }
        {{/operation}}
    }
    {{/operations}}
}
