# coding=utf-8

{{>partials/header.py}}
from __future__ import (absolute_import, division, print_function)
__metaclass__ = type

from marshmallow import validate, ValidationError

__all__ = ["Pattern", "Range", "MultipleOf"]


class Pattern(validate.Regexp):
    """
    Marshmallow validator that uses re.search instead of re.match to match anywhere.
    https://json-schema.org/understanding-json-schema/reference/string.html#regular-expressions

    Based on marshmallow.validate.Regexp (MIT)

    {{>partials/auto_generated_class_docblock}}
    """

    def __call__(self, value):
        if self.regex.search(value) is None:
            raise ValidationError(self._format_error(value))

        return value


class Range(validate.Validator):
    """
    Marshmallow Range validator that takes exclusiveMinimum and exclusiveMaximum into account.

    OAS 2 uses jsonschema draft 4, and OAS 3 uses jsonschema draft 5.
    In draft 4, exclusiveM* are booleans, but in draft 5 they are numbers.
    The swagger-api libraries however assume it is a boolean even for OAS 3, so that's how we do it here.

    Based on marshmallow.validate.Range (MIT)

    {{>partials/auto_generated_class_docblock}}
    """

    def __init__(self, min=None, max=None, error=None, exclusive_min=False, exclusive_max=False):
        self.min = min
        self.max = max
        self.error = error
        self.exclusive_min = exclusive_min
        self.exclusive_max = exclusive_max

    def _repr_args(self):
        return "min={0!r}, max={1!r}, exclusive_min={2!r}, exclusive_max={3!r}".format(
            self.min, self.max, self.exclusive_min, self.exclusive_max)

    def _format_error(self, value, message):
        return (self.error or message).format(input=value, min=self.min, max=self.max)

    @property
    def message(self):
        message = "Must be "
        if self.min is not None:
            message += (
                "greater than {min}"
                if self.exclusive_min
                else "greater than or equal to {min}"
            )
            if self.max is not None:
                message += " and "
        if self.max is not None:
            message += (
                "less than {max}"
                if self.exclusive_max
                else "less than or equal to {max}"
            )
        message += "."
        return message

    def __call__(self, value):
        if self.min is not None:
            message = "{input} is too low. "
            if self.exclusive_min and value <= self.min:
                message += self.message
                raise ValidationError(self._format_error(value, message))
            elif not self.exclusive_min and value < self.min:
                message += self.message
                raise ValidationError(self._format_error(value, message))

        if self.max is not None:
            message = "{input} is too high. "
            if self.exclusive_max and value >= self.max:
                message += self.message
                raise ValidationError(self._format_error(value, message))
            elif not self.exclusive_max and value > self.max:
                message += self.message
                raise ValidationError(self._format_error(value, message))

        return value


class MultipleOf(validate.Validator):
    """
    Marshmallow validator that ensures a number is a multiple of a given number.

    {{>partials/auto_generated_class_docblock}}

    :param multiple: The float/int that the value must be a multiple of.
    :param str error: Error message to raise in case of a validation error.
        Can be interpolated with `{input}` and `{multiple}`.
    """

    default_message = "Must be a multiple of {multiple}."

    def __init__(self, multiple, error=None):
        self.multiple = multiple
        self.error = error

    def _repr_args(self):
        return "multiple={0!r}".format(self.multiple)

    def _format_error(self, value, message):
        return (self.error or message).format(input=value, multiple=self.multiple)

    def __call__(self, value):
        if value % self.multiple != 0:
            raise ValidationError(self._format_error(value, self.default_message))
        return value

