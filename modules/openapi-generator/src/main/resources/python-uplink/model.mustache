# coding: utf-8

from __future__ import annotations

from datetime import date, datetime  # noqa: F401

import re  # noqa: F401
from typing import Any, Dict, List, Optional, Union, Literal  # noqa: F401

from pydantic import AnyUrl, BaseModel, EmailStr, validator, Field, Extra  # noqa: F401
{{#models}}
{{#model}}
{{#imports}}
{{{.}}}
{{/imports}}


class {{classname}}(BaseModel):
    """NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).

    Do not edit the class manually.

    {{classname}} - a model defined in OpenAPI
    {{#requiredVars}}
        {{name}}: {{#description}}{{.}}{{/description}}{{^description}}The {{name}} of this {{classname}}{{/description}}.
    {{/requiredVars}}
    {{#optionalVars}}
        {{name}}: {{#description}}{{.}}{{/description}}{{^description}}The {{name}} of this {{classname}}{{/description}} [Optional].
    {{/optionalVars}}
    """

{{#requiredVars}}
    {{name}}: {{>model_field_type}}{{#vendorExtensions.x-has-custom-name}} = Field(..., alias="{{baseName}}"){{/vendorExtensions.x-has-custom-name}}
{{/requiredVars}}
{{#optionalVars}}
    {{name}}: Optional[{{>model_field_type}}] = {{#vendorExtensions.x-has-custom-name}}Field(None, alias="{{baseName}}"){{/vendorExtensions.x-has-custom-name}}{{^vendorExtensions.x-has-custom-name}}None{{/vendorExtensions.x-has-custom-name}}
{{/optionalVars}}

    def __init__(
        self,
        *,
    {{#requiredVars}}
    {{#vendorExtensions.x-has-custom-name}}
        {{name}}: {{>model_field_type}} = None,
    {{/vendorExtensions.x-has-custom-name}}
    {{^vendorExtensions.x-has-custom-name}}
        {{name}}: {{>model_field_type}} = None,
    {{/vendorExtensions.x-has-custom-name}}
    {{/requiredVars}}
    {{#optionalVars}}
        {{name}}: Optional[{{>model_field_type}}] = None,
    {{/optionalVars}}
        **kwargs,
    ):
        super().__init__(
            {{#vars}}
            {{name}}={{name}},
            {{/vars}}
            **kwargs,
        )
{{#vars}}
{{#maximum}}

    @validator("{{name}}")
    def {{name}}_max(cls, value):
{{>optional_validator}}
        if value > {{maximum}}:
            raise ValueError(f"{{name}} must be less than {{maximum}}, currently {value}")
        return value
{{/maximum}}
{{#minimum}}

    @validator("{{name}}")
    def {{name}}_min(cls, value):
{{>optional_validator}}
        if value < {{minimum}}:
            raise ValueError(f"{{name}} must be greater than {{minimum}}, currently {value}")
        return value
{{/minimum}}
{{#minLength}}

    @validator("{{name}}")
    def {{name}}_min_length(cls, value):
{{>optional_validator}}
        value_len = len(value)
        if value_len < {{minLength}}:
            raise ValueError(f"Length of {{name}} must at minimum {{minLength}}, currently {value_len}")
        return value
{{/minLength}}
{{#maxLength}}

    @validator("{{name}}")
    def {{name}}_max_length(cls, value):
{{>optional_validator}}
        value_len = len(value)
        if value_len > {{maxLength}}:
            raise ValueError(f"Length of {{name}} must be at maximum {{maxLength}}, currently {value_len}")

        return value
{{/maxLength}}
{{#pattern}}

    @validator("{{name}}")
    def {{name}}_pattern(cls, value):
{{>optional_validator}}
        pattern = r"{{pattern}}"
        if not re.match(pattern, value):
            raise ValueError(f"Value of {{name}} does not match regex pattern ('{pattern}')")
        return value
{{/pattern}}
{{/vars}}
{{/model}}
{{/models}}


{{classname}}.update_forward_refs()
