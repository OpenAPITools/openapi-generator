{{>licenseInfo}}
/*
 * ModelBase.h
 *
 * This is the base class for all model classes
 */

#ifndef ModelBase_H_
#define ModelBase_H_

{{{defaultInclude}}}
#include "json.hpp"
#include <ctime>
#include <string>
#include <vector>
#include <map>

{{#modelNamespaceDeclarations}}
namespace {{this}} {
{{/modelNamespaceDeclarations}}

class {{declspec}} ModelBase
{
public:
    ModelBase();
    virtual ~ModelBase();

    virtual void validate() = 0;

    virtual nlohmann::json toJson() const = 0;
    virtual void fromJson(nlohmann::json& json) = 0;

    static std::string toJson(  std::string const& value );
    static std::string toJson(  std::time_t const& value );
    static int32_t toJson( int32_t const value );
    static int64_t toJson( int64_t const value );
    static double toJson( double const value );
    static bool toJson( bool const value );
    static nlohmann::json toJson(ModelBase const& content ); 
};

class  ModelArrayHelper {
public:
template <typename T>
	static std::vector<T> fromJson(nlohmann::json& json) {
		T *ptrTest;
		std::vector<T> val;
		if (dynamic_cast<ModelBase*>(ptrTest) != nullptr) {
			if (!json.empty()) {
				for (auto &item : json.items()){
					T entry;
					entry.fromJson(item.value());
					val.push_back(entry);
				}
			}
		} else {
			// TODO Primitives
		}
		return val;
}

};

class  ModelMapHelper {
public:

template <typename T>
static std::map<std::string, T> & fromJson(nlohmann::json& json){
	T *ptrTest;
	std::map<std::string, T> val;
	if (dynamic_cast<ModelBase*>(ptrTest) != nullptr) {
		if (!json.empty()) {
			for (auto &item : json.items()){
				T entry;
				entry.fromJson(item.value());
				val.insert(val.end(), std::pair<std::string ,T>(item.key(),entry));
			}
		}
	} else {
		// TODO Primitives
	}
    return val;
}

};


{{#modelNamespaceDeclarations}}
}
{{/modelNamespaceDeclarations}}

#endif /* ModelBase_H_ */
