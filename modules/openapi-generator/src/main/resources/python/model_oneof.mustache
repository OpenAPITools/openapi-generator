from __future__ import annotations
import json
import pprint
{{#vendorExtensions.x-py-other-imports}}
{{{.}}}
{{/vendorExtensions.x-py-other-imports}}
{{#vendorExtensions.x-py-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-model-imports}}
from pydantic import BaseModel, ConfigDict, StrictStr, Field, RootModel, model_validator
from typing import Any, Union, List, Set, Optional, Dict, Union
from typing_extensions import Literal, Self

{{#lambda.uppercase}}{{{classname}}}{{/lambda.uppercase}}_ONE_OF_SCHEMAS = [{{#oneOf}}"{{.}}"{{^-last}}, {{/-last}}{{/oneOf}}]

class {{classname}}(RootModel[Union[{{#oneOf}}{{{.}}}{{^-last}}, {{/-last}}{{/oneOf}}]]):
    """
    {{{description}}}{{^description}}{{{classname}}}{{/description}}
    """
    root: Union[{{#oneOf}}{{.}}{{^-last}}, {{/-last}}{{/oneOf}}] = Field(
      ...{{#discriminator}}, discriminator="{{discriminatorName}}"{{/discriminator}}
    )

    def __getattr__(self, name):
        """
        Delegate attribute access to the root model if the attribute
        doesn't exist on the main class.
        """
        if name in self.__dict__:
            return super().__getattribute__(name)
        if hasattr(self, 'root') and self.root is not None:
            return getattr(self.root, name)
        raise AttributeError(f"'{self.__class__.__name__}' object has no attribute '{name}'")
