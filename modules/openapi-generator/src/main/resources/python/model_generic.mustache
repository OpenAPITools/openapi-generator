from __future__ import annotations
import pprint
import re  # noqa: F401
import json

{{#vendorExtensions.x-py-other-imports}}
{{{.}}}
{{/vendorExtensions.x-py-other-imports}}
{{#vendorExtensions.x-py-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-model-imports}}
from typing import Optional, Set, Literal
from typing_extensions import Self
from pydantic import Field

{{#hasChildren}}
{{#discriminator}}
{{! If this model is a super class, importlib is used. So import the necessary modules for the type here. }}
from typing import TYPE_CHECKING
if TYPE_CHECKING:
{{#mappedModels}}
    from {{packageName}}.models.{{model.classFilename}} import {{modelName}}
{{/mappedModels}}

{{/discriminator}}
{{/hasChildren}}
class {{classname}}({{#parent}}{{{.}}}{{/parent}}{{^parent}}BaseModel{{/parent}}):
    """
    {{#description}}{{{description}}}{{/description}}{{^description}}{{{classname}}}{{/description}}
    """ # noqa: E501
{{#vars}}
  {{#isEnum}}
    {{#allowableValues}}
      {{^isArray}}
        {{#values}}
          {{#-first}}
            {{#-last}}
              {{! Single value enum - use Literal }}
    {{name}}: Literal['{{{.}}}'] = Field(
        {{#required}}...{{/required}}{{^required}}None{{/required}},
        description="{{description}}{{^description}}{{{name}}} of the {{classname}}{{/description}}"
    )
            {{/-last}}
            {{^-last}}
              {{! Multiple value enum - use enum class }}
    {{name}}: {{#required}}{{datatypeWithEnum}}{{/required}}{{^required}}Optional[{{datatypeWithEnum}}]{{/required}} = Field(
        {{#required}}...{{/required}}{{^required}}None{{/required}},
        description="{{description}}{{^description}}{{{name}}} of the {{classname}}{{/description}}"
    )
            {{/-last}}
          {{/-first}}
        {{/values}}
      {{/isArray}}
    {{/allowableValues}}
  {{/isEnum}}
  {{^isEnum}}
    {{name}}: {{{vendorExtensions.x-py-typing}}}
  {{/isEnum}}
{{/vars}}
{{#isAdditionalPropertiesTrue}}
    additional_properties: Dict[str, Any] = {}
{{/isAdditionalPropertiesTrue}}
    __properties: ClassVar[List[str]] = [{{#allVars}}"{{baseName}}"{{^-last}}, {{/-last}}{{/allVars}}]
{{#vars}}
    {{#vendorExtensions.x-regex}}

    @field_validator('{{{name}}}')
    def {{{name}}}_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        {{^required}}
        if value is None:
            return value

        {{/required}}
        {{#required}}
        {{#isNullable}}
        if value is None:
            return value

        {{/isNullable}}
        {{/required}}
        if not re.match(r"{{{.}}}", value{{#vendorExtensions.x-modifiers}} ,re.{{{.}}}{{/vendorExtensions.x-modifiers}}):
            raise ValueError(r"must validate the regular expression {{{vendorExtensions.x-pattern}}}")
        return value
    {{/vendorExtensions.x-regex}}
    {{#isEnum}}

    @field_validator('{{{name}}}')
    def {{{name}}}_validate_enum(cls, value):
        """Validates the enum"""
        {{^required}}
        if value is None:
            return value

        {{/required}}
        {{#required}}
        {{#isNullable}}
        if value is None:
            return value

        {{/isNullable}}
        {{/required}}
        {{#isContainer}}
        {{#isArray}}
        for i in value:
            if i not in set([{{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]):
                raise ValueError("each list item must be one of ({{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}})")
        {{/isArray}}
        {{#isMap}}
        for i in value.values():
            if i not in set([{{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]):
                raise ValueError("dict values must be one of enum values ({{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}})")
        {{/isMap}}
        {{/isContainer}}
        {{^isContainer}}
        if value not in set([{{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}}]):
            raise ValueError("must be one of enum values ({{#allowableValues}}{{#enumVars}}{{{value}}}{{^-last}}, {{/-last}}{{/enumVars}}{{/allowableValues}})")
        {{/isContainer}}
        return value
    {{/isEnum}}
{{/vars}}

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


{{#hasChildren}}
{{#discriminator}}
    # JSON field name that stores the object type
    __discriminator_property_name: ClassVar[str] = '{{discriminator.propertyBaseName}}'

    # discriminator mappings
    __discriminator_value_class_map: ClassVar[Dict[str, str]] = {
        {{#mappedModels}}'{{{mappingName}}}': '{{{modelName}}}'{{^-last}},{{/-last}}{{/mappedModels}}
    }

    @classmethod
    def get_discriminator_value(cls, obj: Dict[str, Any]) -> Optional[str]:
        """Returns the discriminator value (object type) of the data"""
        discriminator_value = obj[cls.__discriminator_property_name]
        if discriminator_value:
            return cls.__discriminator_value_class_map.get(discriminator_value)
        else:
            return None

{{/discriminator}}
{{/hasChildren}}
    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))


{{#vendorExtensions.x-py-postponed-model-imports.size}}
{{#vendorExtensions.x-py-postponed-model-imports}}
{{{.}}}
{{/vendorExtensions.x-py-postponed-model-imports}}
# TODO: Rewrite to not use raise_errors
{{classname}}.model_rebuild(raise_errors=False)
{{/vendorExtensions.x-py-postponed-model-imports.size}}
