class {{classname}}(ModelNormal):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    Attributes:
{{> python-experimental/model_templates/docstring_allowed }}
      attribute_map (dict): The key is attribute name
          and the value is json key in definition.
      discriminator_value_class_map (dict): A dict to go from the discriminator
          variable value to the discriminator class name.
{{> python-experimental/model_templates/docstring_openapi_validations }}
    """

{{> python-experimental/model_templates/classvar_allowed }}

    attribute_map = {
{{#allVars}}
        '{{name}}': '{{baseName}}'{{#hasMore}},{{/hasMore}}  # noqa: E501
{{/allVars}}
    }
{{#discriminator}}

    discriminator_value_class_map = {
        {{#children}}'{{^vendorExtensions.x-discriminator-value}}{{name}}{{/vendorExtensions.x-discriminator-value}}{{#vendorExtensions.x-discriminator-value}}{{{vendorExtensions.x-discriminator-value}}}{{/vendorExtensions.x-discriminator-value}}': {{{classname}}}{{^-last}},
        {{/-last}}{{/children}}
    }
{{/discriminator}}

{{> python-experimental/model_templates/classvar_openapi_validations }}

{{> python-experimental/model_templates/methods_init_properties }}
{{#discriminator}}
    @classmethod
    def get_real_child_model(cls, data):
        """Returns the real base class specified by the discriminator
        We assume that data has javascript keys
        """
        discriminator_key = cls.attribute_map[cls.discriminator]
        discriminator_value = data[discriminator_key]
        return cls.discriminator_value_class_map.get(discriminator_value)

{{/discriminator}}
    def to_dict(self):
        """Returns the model properties as a dict"""
        return model_to_dict(self, serialize=False)

    def to_str(self):
        """Returns the string representation of the model"""
        return pprint.pformat(self.to_dict())

    def __repr__(self):
        """For `print` and `pprint`"""
        return self.to_str()

    def __eq__(self, other):
        """Returns true if both objects are equal"""
        if not isinstance(other, {{classname}}):
            return False

        if not set(self._data_store.keys()) == set(other._data_store.keys()):
            return False
        for _var_name, this_val in six.iteritems(self._data_store):
            that_val = other._data_store[_var_name]
            types = set()
            types.add(this_val.__class__)
            types.add(that_val.__class__)
            vals_equal = this_val == that_val
            if (not six.PY3 and
                    len(types) == 2 and unicode in types):  # noqa: F821
                vals_equal = (
                    this_val.encode('utf-8') == that_val.encode('utf-8')
                )
            if not vals_equal:
                return False
        return True

    def __ne__(self, other):
        """Returns true if both objects are not equal"""
        return not self == other