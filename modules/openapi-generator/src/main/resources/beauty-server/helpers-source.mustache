{{>licenseInfo}}
/*
 * BeautyHelpers.cpp
 *
 * Helper utilities implementation
 */

#include "BeautyHelpers.hpp"
#include <algorithm>
#include <sstream>
#include <iomanip>
#include <cctype>
#include <cjson/cJSON.h>

{{#helpersNamespaceDeclarations}}
namespace {{this}} {
{{/helpersNamespaceDeclarations}}

std::string BeautyHelpers::urlEncode(const std::string& str) {
    std::ostringstream escaped;
    escaped.fill('0');
    escaped << std::hex;

    for (char c : str) {
        if (std::isalnum(c) || c == '-' || c == '_' || c == '.' || c == '~') {
            escaped << c;
        } else {
            escaped << std::uppercase;
            escaped << '%' << std::setw(2) << int(static_cast<unsigned char>(c));
            escaped << std::nouppercase;
        }
    }

    return escaped.str();
}

std::string BeautyHelpers::urlDecode(const std::string& str) {
    std::string decoded;
    for (size_t i = 0; i < str.length(); ++i) {
        if (str[i] == '%' && i + 2 < str.length()) {
            int value;
            std::istringstream is(str.substr(i + 1, 2));
            if (is >> std::hex >> value) {
                decoded += static_cast<char>(value);
                i += 2;
            } else {
                decoded += str[i];
            }
        } else if (str[i] == '+') {
            decoded += ' ';
        } else {
            decoded += str[i];
        }
    }
    return decoded;
}

std::vector<std::string> BeautyHelpers::split(const std::string& str, char delimiter) {
    std::vector<std::string> tokens;
    std::string token;
    std::istringstream tokenStream(str);
    while (std::getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

std::string BeautyHelpers::join(const std::vector<std::string>& parts, const std::string& delimiter) {
    std::ostringstream result;
    for (size_t i = 0; i < parts.size(); ++i) {
        if (i > 0) result << delimiter;
        result << parts[i];
    }
    return result.str();
}

std::string BeautyHelpers::trim(const std::string& str) {
    auto start = str.begin();
    while (start != str.end() && std::isspace(*start)) {
        start++;
    }

    auto end = str.end();
    do {
        end--;
    } while (std::distance(start, end) > 0 && std::isspace(*end));

    return std::string(start, end + 1);
}

std::map<std::string, std::string> BeautyHelpers::parseQueryString(const std::string& query) {
    std::map<std::string, std::string> params;
    std::vector<std::string> pairs = split(query, '&');
    
    for (const auto& pair : pairs) {
        auto equalPos = pair.find('=');
        if (equalPos != std::string::npos) {
            std::string key = urlDecode(pair.substr(0, equalPos));
            std::string value = urlDecode(pair.substr(equalPos + 1));
            params[key] = value;
        } else {
            params[urlDecode(pair)] = "";
        }
    }
    
    return params;
}

std::string BeautyHelpers::buildQueryString(const std::map<std::string, std::string>& params) {
    std::ostringstream query;
    bool first = true;
    
    for (const auto& pair : params) {
        if (!first) query << "&";
        query << urlEncode(pair.first) << "=" << urlEncode(pair.second);
        first = false;
    }
    
    return query.str();
}

bool BeautyHelpers::isValidJson(const std::string& json) {
    cJSON* parsed = cJSON_Parse(json.c_str());
    if (parsed) {
        cJSON_Delete(parsed);
        return true;
    }
    return false;
}

std::string BeautyHelpers::escapeJsonString(const std::string& str) {
    std::string escaped;
    for (char c : str) {
        switch (c) {
            case '"': escaped += "\\\""; break;
            case '\\': escaped += "\\\\"; break;
            case '\b': escaped += "\\b"; break;
            case '\f': escaped += "\\f"; break;
            case '\n': escaped += "\\n"; break;
            case '\r': escaped += "\\r"; break;
            case '\t': escaped += "\\t"; break;
            default:
                if (c < 0x20) {
                    escaped += "\\u";
                    escaped += "0000"; // simplified, should be proper hex
                } else {
                    escaped += c;
                }
                break;
        }
    }
    return escaped;
}

{{#helpersNamespaceDeclarations}}
} // namespace {{this}}
{{/helpersNamespaceDeclarations}}
