{{>header}}
{{>part_of}}
{{#operations}}

class {{{classname}}} {
  {{{classname}}}([ApiClient apiClient]) : apiClient = apiClient ?? defaultApiClient;

  final ApiClient apiClient;
  {{#operation}}

  /// Executes the same logic as [{{{nickname}}}] but instead returns a
  /// [StreamedResponse] that clients can listen to, for example to monitor the progress of
  /// the network activity.
  Future<StreamedResponse> {{{nickname}}}AsStreamedResponse({{#allParams}}{{#required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}{ {{#allParams}}{{^required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} }{{/hasOptionalParams}}) async {
  {{#hasParams}}
    // Verify required params are set.
    {{#allParams}}
      {{#required}}
    if ({{{paramName}}} == null) {
     throw ApiException(HttpStatus.badRequest, 'Missing required param: {{{paramName}}}');
    }
      {{/required}}
    {{/allParams}}

  {{/hasParams}}
    final path = '{{{path}}}'.replaceAll('{format}', 'json'){{#pathParams}}
      .replaceAll('{' + '{{{baseName}}}' + '}', {{{paramName}}}.toString()){{/pathParams}};

    Object postBody{{#bodyParam}} = {{{paramName}}}{{/bodyParam}};

    final queryParams = <QueryParam>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};

    {{#queryParams}}
      {{^required}}
    if ({{{paramName}}} != null) {
      {{/required}}
      queryParams.addAll(_convertParametersForCollectionFormat('{{{collectionFormat}}}', '{{{baseName}}}', {{{paramName}}}));
      {{^required}}
    }
      {{/required}}
    {{/queryParams}}
    {{#headerParams}}
    headerParams['{{{baseName}}}'] = {{{paramName}}};
    {{/headerParams}}

    final contentTypes = <String>[{{#consumes}}'{{{mediaType}}}'{{#hasMore}}, {{/hasMore}}{{/consumes}}];
    final nullableContentType = contentTypes.isNotEmpty ? contentTypes[0] : null;
    final authNames = <String>[{{#authMethods}}'{{{name}}}'{{#hasMore}}, {{/hasMore}}{{/authMethods}}];

    if (
      nullableContentType != null &&
      nullableContentType.toLowerCase().startsWith('multipart/form-data')
    ) {
      bool hasFields = false;
      final mp = MultipartRequest(null, null);
      {{#formParams}}
      {{^isFile}}
      if ({{{paramName}}} != null) {
        hasFields = true;
        mp.fields['{{{baseName}}}'] = parameterToString({{{paramName}}});
      }
      {{/isFile}}
      {{#isFile}}
      if ({{{paramName}}} != null) {
        hasFields = true;
        mp.fields['{{{baseName}}}'] = {{{paramName}}}.field;
        mp.files.add({{{paramName}}});
      }
      {{/isFile}}
      {{/formParams}}
      if (hasFields) {
        postBody = mp;
      }
      {{#hasFormParams}}
    } else {
        {{#formParams}}
          {{^isFile}}
      if ({{{paramName}}} != null) {
        formParams['{{{baseName}}}'] = parameterToString({{{paramName}}});
      }
          {{/isFile}}
        {{/formParams}}
      {{/hasFormParams}}
    }

    return await apiClient.streamAPI(
      path,
      '{{{httpMethod}}}',
      queryParams,
      postBody,
      headerParams,
      formParams,
      nullableContentType,
      authNames,
    );
  }

  /// Executes the same logic as [{{{nickname}}}] but instead returns the processed result as
  /// an HTTP [Response].
  Future<Response> {{{nickname}}}WithHttpInfo({{#allParams}}{{#required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}{ {{#allParams}}{{^required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} }{{/hasOptionalParams}}) =>
    apiClient.getResponse({{{nickname}}}AsStreamedResponse({{#allParams}}{{#required}}{{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}} {{#allParams}}{{^required}}{{{paramName}}}: {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} {{/hasOptionalParams}}));

  {{#summary}}
  /// {{{summary}}}
  ///
  {{/summary}}
  {{#notes}}
  /// {{{notes}}}
  ///
  {{/notes}}
  {{^notes}}
    {{^summary}}
  /// Performs an HTTP '{{{httpMethod}}} {{{path}}}' operation.
  ///
    {{/summary}}
  {{/notes}}
  {{#returnType}}
  /// After the method completes, the result is returned as an instance of [{{{returnType}}}].
  {{/returnType}}
  {{^returnType}}
  /// Note: This method returns nothing.
  {{/returnType}}
  ///
  {{#hasParams}}
  /// Parameters:
  ///
  {{/hasParams}}
  {{#allParams}}
  /// * [{{{dataType}}}] {{{paramName}}}{{#required}} (required){{/required}}{{#optional}} (optional){{/optional}}:
    {{#description}}
  ///   {{{description}}}
    {{/description}}
    {{#hasMore}}
  ///
    {{/hasMore}}
  {{/allParams}}
  {{#returnType}}Future<{{{returnType}}}> {{/returnType}}{{^returnType}}Future<void> {{/returnType}}{{{nickname}}}({{#allParams}}{{#required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}}{ {{#allParams}}{{^required}}{{{dataType}}} {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} }{{/hasOptionalParams}}) async {
    final response = await {{{nickname}}}WithHttpInfo({{#allParams}}{{#required}}{{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}}{{#hasOptionalParams}} {{#allParams}}{{^required}}{{{paramName}}}: {{{paramName}}}{{#hasMore}}, {{/hasMore}}{{/required}}{{/allParams}} {{/hasOptionalParams}});
    if (response.statusCode >= HttpStatus.badRequest) {
      throw ApiException(response.statusCode, _decodeBodyBytes(response));
    }
    {{#returnType}}
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body != null && response.statusCode != HttpStatus.noContent) {
      {{#isListContainer}}
      return (apiClient.deserialize(_decodeBodyBytes(response), '{{{returnType}}}') as List)
        .map((item) => item as {{{returnBaseType}}})
        .toList(growable: false);
      {{/isListContainer}}
      {{^isListContainer}}
        {{#isMap}}
      return {{{returnType}}}.from(apiClient.deserialize(_decodeBodyBytes(response), '{{{returnType}}}'));
        {{/isMap}}
        {{^isMap}}
      return apiClient.deserialize(_decodeBodyBytes(response), '{{{returnType}}}') as {{{returnType}}};
        {{/isMap}}
      {{/isListContainer}}
    }
    return null;
    {{/returnType}}
  }
  {{/operation}}
}
{{/operations}}
