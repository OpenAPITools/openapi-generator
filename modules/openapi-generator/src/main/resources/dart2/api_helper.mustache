{{>header}}
{{>part_of}}
// Ported from the Java version.
Iterable<QueryParam> _convertParametersForCollectionFormat(
  String collectionFormat,
  String name,
  dynamic value,
) {
  final params = <QueryParam>[];

  // preconditions
  if (name != null && !name.isEmpty && value != null) {
    if (value is List) {
      // get the collection format, default: csv
      collectionFormat = (collectionFormat == null || collectionFormat.isEmpty)
        ? 'csv'
        : collectionFormat;

      if (collectionFormat == 'multi') {
        return value.map((v) => QueryParam(name, parameterToString(v)));
      }

      final delimiter = _delimiters[collectionFormat] ?? ',';

      params.add(QueryParam(name, value.map((v) => parameterToString(v)).join(delimiter)));
    } else {
      params.add(QueryParam(name, parameterToString(value)));
    }
  }

  return params;
}

/// Format the given parameter object into a [String].
String parameterToString(dynamic value) {
  if (value == null) {
    return '';
  }
  if (value is DateTime) {
    return value.toUtc().toIso8601String();
  }
  {{#models}}
    {{#model}}
      {{#isEnum}}
  if (value is {{{classname}}}) {
    return {{{classname}}}TypeTransformer().encode(value).toString();
  }
      {{/isEnum}}
    {{/model}}
  {{/models}}
  return value.toString();
}

/// Returns the decoded body as UTF-8 if the given headers indicate an 'application/json'
/// content type. Otherwise, returns the decoded body as decoded by dart:http package.
String _decodeBodyBytes(Response response) {
  final contentType = response.headers['content-type'];
  return contentType != null && contentType.toLowerCase().startsWith('application/json')
    ? response.bodyBytes == null ? null : utf8.decode(response.bodyBytes)
    : response.body;
}

/// Uploads a [StreamedFile] via the provided HTTP [client] to [url] using the
/// specified HTTP [method].
///
/// If [streamedFile] does not exist, or its size is zero, an [ApiException] is thrown.
Future<Response> _uploadStreamedFile(
  Client client,
  String url,
  String method,
  StreamedFile streamedFile,
  Map<String, String> headerParams,
) async {
  final file = File(streamedFile.filePath);
  if (!file.existsSync()) {
    throw ApiException(HttpStatus.badRequest, 'File not found: ${streamedFile.filePath}');
  }
  final totalBytes = await file.length();
  if (totalBytes <= 0) {
    throw ApiException(HttpStatus.badRequest, 'File is invalid: ${streamedFile.filePath}');
  }
  final request = StreamedRequest(method, Uri.parse(url));
  request.headers.addAll(streamedFile.headers);
  request.headers.addAll(headerParams);
  request.contentLength = totalBytes;
  final stream = ByteStream(file.openRead());
  var progressBytes = 0;
  stream.listen(
    (chunk) {
      request.sink.add(chunk);
      progressBytes += chunk.length;
      if (streamedFile.onProgress != null) {
        streamedFile.onProgress(progressBytes, totalBytes, streamedFile);
      }
    },
    onDone: request.sink.close,
    onError: (error, trace) {
      request.sink.close();
      if (streamedFile.onError != null) {
        streamedFile.onError(error, trace);
      }
    },
    cancelOnError: true,
  );
  return Response.fromStream(await client.send(request));
}

/// Uploads a [MultipartRequest] via the provided HTTP [client] to [url] using the
/// specified HTTP [method].
Future<Response> _uploadMultipartRequest(
  Client client,
  String url,
  String method,
  MultipartRequest body,
  Map<String, String> headerParams,
) async {
  final request = MultipartRequest(method, Uri.parse(url));
  request.fields.addAll(body.fields);
  request.files.addAll(body.files);
  request.headers.addAll(body.headers);
  request.headers.addAll(headerParams);
  return Response.fromStream(await client.send(request));
}
