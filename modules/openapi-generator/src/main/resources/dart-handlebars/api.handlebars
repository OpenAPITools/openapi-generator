{{>header}}
{{>part_of}}
{{#each operations}}

class {{{classname}}} {
  {{{classname}}}([{{#with apiClientName}}{{.}}{{/with}}{{#unless apiClientName}}{{{modelNamePrefix}}}ApiClient{{{modelNameSuffix}}}{{/unless}}? apiClient]) : apiClient = apiClient ?? default{{#with apiClientName}}{{.}}{{/with}}{{#unless apiClientName}}{{{modelNamePrefix}}}ApiClient{{{modelNameSuffix}}}{{/unless}};

  final {{#with apiClientName}}{{.}}{{/with}}{{#unless apiClientName}}{{{modelNamePrefix}}}ApiClient{{{modelNameSuffix}}}{{/unless}} apiClient;
  {{#with operation}}

  {{#with summary}}
  /// {{{.}}}
  {{/with}}
  {{#each notes}}
    {{#with summary}}
  ///
    {{/with}}
  /// {{{notes}}}
  ///
  /// Note: This method returns the HTTP [Response].
  {{/each}}
  {{#unless notes}}
    {{#with summary}}
  ///
  /// Note: This method returns the HTTP [Response].
    {{/with}}
    {{#unless summary}}
  /// Performs an HTTP '{{{httpMethod}}} {{{path}}}' operation and returns the [Response].
    {{/unless}}
  {{/unless}}
  {{#if hasParams}}
    {{#with summary}}
  ///
    {{/with}}
    {{#unless summary}}
      {{#each notes}}
  ///
      {{/each}}
    {{/unless}}
  /// Parameters:
  ///
  {{/if}}
  {{#each allParams}}
  /// * [{{{dataType}}}] {{{paramName}}}{{#with required}} (required){{/with}}{{#with optional}} (optional){{/with}}:
    {{#with description}}
  ///   {{{.}}}
    {{/with}}
    {{#unless @last}}
  ///
    {{/unless}}
  {{/each}}
  Future<Response> {{{nickname}}}WithHttpInfo({{#each allParams}}{{#with required}}{{{dataType}}} {{{paramName}}},{{#unless @last}} {{/unless}}{{/with}}{{/each}}{{#if hasOptionalParams}}{ {{#each allParams}}{{#unless required}}{{{dataType}}}? {{{paramName}}},{{#unless @last}} {{/unless}}{{/unless}}{{/each}} }{{/if}}) async {
    // ignore: prefer_const_declarations
    final path = r'{{{path}}}'{{#each pathParams}}
      .replaceAll({{=<% %>=}}'{<% baseName %>}'<%={{ }}=%>, {{{paramName}}}{{#unless isString}}.toString(){{/unless}}){{/each}};

    // ignore: prefer_final_locals
    Object? postBody{{#with bodyParam}} = {{{paramName}}}{{/with}};

    final queryParams = <{{{modelNamePrefix}}}QueryParam{{{modelNameSuffix}}}>[];
    final headerParams = <String, String>{};
    final formParams = <String, String>{};
    {{#if hasQueryParams}}

      {{#each queryParams}}
        {{#unless required}}
    if ({{{paramName}}} != null) {
          {{/unless}}
      queryParams.addAll(_queryParams('{{{collectionFormat}}}', '{{{baseName}}}', {{{paramName}}}));
          {{#unless required}}
    }
        {{/unless}}
      {{/each}}
    {{/if}}
    {{#if hasHeaderParams}}

      {{#each headerParams}}
        {{#with required}}
    headerParams[r'{{{baseName}}}'] = parameterToString({{{paramName}}});
        {{/with}}
        {{#unless required}}
    if ({{{paramName}}} != null) {
      headerParams[r'{{{baseName}}}'] = parameterToString({{{paramName}}});
    }
        {{/unless}}
      {{/each}}
    {{/if}}

    const contentTypes = <String>[{{#each prioritizedContentTypes}}'{{{mediaType}}}'{{#unless @last}}, {{/unless}}{{/each}}];

    {{#if isMultipart}}
    bool hasFields = false;
    final mp = MultipartRequest('{{{httpMethod}}}', Uri.parse(path));
    {{#each formParams}}
    {{#unless isFile}}
    if ({{{paramName}}} != null) {
      hasFields = true;
      mp.fields[r'{{{baseName}}}'] = parameterToString({{{paramName}}});
    }
    {{/unless}}
    {{#if isFile}}
    if ({{{paramName}}} != null) {
      hasFields = true;
      mp.fields[r'{{{baseName}}}'] = {{{paramName}}}.field;
      mp.files.add({{{paramName}}});
    }
    {{/if}}
    {{/each}}
    if (hasFields) {
      postBody = mp;
    }
    {{/if}}
    {{#unless isMultipart}}
    {{#each formParams}}
    {{#unless isFile}}
    if ({{{paramName}}} != null) {
      formParams[r'{{{baseName}}}'] = parameterToString({{{paramName}}});
    }
    {{/unless}}
    {{/each}}
    {{/unless}}

    return apiClient.invokeAPI(
      path,
      '{{{httpMethod}}}',
      queryParams,
      postBody,
      headerParams,
      formParams,
      contentTypes.isEmpty ? null : contentTypes.first,
    );
  }

  {{#with summary}}
  /// {{{.}}}
  {{/with}}
  {{#each notes}}
  {{#with summary}}
  ///
  {{/with}}
  /// {{{notes}}}
  {{/each}}
  {{#if hasParams}}
    {{#with summary}}
  ///
    {{/with}}
    {{#unless summary}}
      {{#each notes}}
  ///
      {{/each}}
    {{/unless}}
  /// Parameters:
  ///
  {{/if}}
  {{#each allParams}}
  /// * [{{{dataType}}}] {{{paramName}}}{{#with required}} (required){{/with}}{{#with optional}} (optional){{/with}}:
    {{#with description}}
  ///   {{{.}}}
    {{/with}}
    {{#unless @last}}
  ///
    {{/unless}}
  {{/each}}
  Future<{{#with returnType}}{{{.}}}?{{/with}}{{#unless returnType}}void{{/unless}}> {{{nickname}}}({{#each allParams}}{{#with required}}{{{dataType}}} {{{paramName}}},{{#unless @last}} {{/unless}}{{/with}}{{/each}}{{#if hasOptionalParams}}{ {{#each allParams}}{{#unless required}}{{{dataType}}}? {{{paramName}}},{{#unless @last}} {{/unless}}{{/unless}}{{/each}} }{{/if}}) async {
    final response = await {{{nickname}}}WithHttpInfo({{#each allParams}}{{#with required}}{{{paramName}}},{{#unless @last}} {{/unless}}{{/with}}{{/each}}{{#if hasOptionalParams}} {{#each allParams}}{{#unless required}}{{{paramName}}}: {{{paramName}}},{{#unless @last}} {{/unless}}{{/unless}}{{/each}} {{/if}});
    if (response.statusCode >= HttpStatus.badRequest) {
      throw {{{modelNamePrefix}}}ApiException{{{modelNameSuffix}}}(response.statusCode, await _decodeBodyBytes(response));
    }
    {{#with returnType}}
    // When a remote server returns no body with a status of 204, we shall not decode it.
    // At the time of writing this, `dart:convert` will throw an "Unexpected end of input"
    // FormatException when trying to decode an empty string.
    if (response.body.isNotEmpty && response.statusCode != HttpStatus.noContent) {
    {{#with native_serialization}}
    {{#if isArray}}
      final responseBody = await _decodeBodyBytes(response);
      return (await apiClient.deserializeAsync(responseBody, '{{{returnType}}}') as List)
        .cast<{{{returnInnerType}}}>()
        .{{#each uniqueItems}}toSet(){{/each}}{{#unless uniqueItems}}toList(){{/unless}};
    {{/if}}
    {{#unless isArray}}
    {{#if isMap}}
      return {{{returnType}}}.from(await apiClient.deserializeAsync(await _decodeBodyBytes(response), '{{{returnType}}}'),);
    {{/if}}
    {{#unless isMap}}
      return await apiClient.deserializeAsync(await _decodeBodyBytes(response), '{{{returnType}}}',) as {{{returnType}}};
    {{/unless}}{{/unless}}{{/with}}
    }
    return null;
    {{/with}}
  }
  {{/with}}
}
{{/each}}
