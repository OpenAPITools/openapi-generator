/**
 * Internet Banking
 * Public API for Internet Banking (IB) clients - web, iOS, Android. A combination of specifications from Backbase, as well as home-grown specifications.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@greater.com.au
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client.api

import com.android.volley.Response
import org.openapitools.client.ApiInvoker.Companion.instance
import org.openapitools.client.ApiInvoker.addDefaultHeader
import org.openapitools.client.ApiInvoker.escapeString
import org.openapitools.client.ApiInvoker.invokeAPI
import org.openapitools.client.ApiInvoker.Companion.deserialize
import org.openapitools.client.ApiInvoker.Companion.parameterToPairs
import org.openapitools.client.ApiInvoker
import kotlin.Throws
import java.util.concurrent.TimeoutException
import java.util.concurrent.ExecutionException
import java.lang.InterruptedException
import org.openapitools.client.ApiException
import com.android.volley.VolleyError
import org.apache.http.entity.mime.MultipartEntityBuilder
import org.apache.http.HttpEntity
import org.openapitools.client.Pair
import org.openapitools.client.model.PendingTransactionList
import org.openapitools.client.model.InviteResponse
import org.openapitools.client.model.TransactionList
import org.openapitools.client.model.TransactionPage
import org.openapitools.client.model.AccountInviteResponse
import org.openapitools.client.model.AcceptInviteRequest
import org.openapitools.client.model.AccountInvite
import java.math.BigDecimal
import java.util.*

class AccountApi {
    var basePath = "https://sim.nonprod.gbcloud.com.au/api"
    var invoker = instance
    fun addHeader(key: String?, value: String?) {
        invoker!!.addDefaultHeader(key!!, value!!)
    }

    /**
     * Delete an account invite
     * Delete an account invite
     * @param inviteCode
     * @return void
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun deleteV1AccountInviteInviteCode(inviteCode: String?) {
        var postBody: Any? = null
        // verify the required parameter 'inviteCode' is set
        if (inviteCode == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteCode' when calling deleteV1AccountInviteInviteCode",
                ApiException(
                    400,
                    "Missing the required parameter 'inviteCode' when calling deleteV1AccountInviteInviteCode"
                )
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteCode}".replace(
            "\\{" + "inviteCode" + "\\}".toRegex(),
            invoker!!.escapeString(inviteCode.toString())
        )

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "DELETE",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                return
            } else {
                return
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * Delete an account invite
     * Delete an account invite
     * @param inviteCode
     */
    fun deleteV1AccountInviteInviteCode(
        inviteCode: String?,
        responseListener: Response.Listener<String?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = null

        // verify the required parameter 'inviteCode' is set
        if (inviteCode == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteCode' when calling deleteV1AccountInviteInviteCode",
                ApiException(
                    400,
                    "Missing the required parameter 'inviteCode' when calling deleteV1AccountInviteInviteCode"
                )
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteCode}".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "inviteCode" + "\\}".toRegex(), invoker!!.escapeString(inviteCode.toString()))

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "DELETE",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse -> responseListener.onResponse(localVarResponse) },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     * A list of pending transactions
     * Returns all pending (aka on-hold or authorisation) transactions for a given account.
     * @param accountId The account Id is in the form &lt;account_type&gt;-&lt;account_number&gt;.
     * @return PendingTransactionList
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun getV1AccountsAccountIdPendingTransactions(accountId: String?): PendingTransactionList? {
        var postBody: Any? = null
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV1AccountsAccountIdPendingTransactions",
                ApiException(
                    400,
                    "Missing the required parameter 'accountId' when calling getV1AccountsAccountIdPendingTransactions"
                )
            )
        }

        // create path and map variables
        val path = "/v1/accounts/{accountId}/pending-transactions".replace(
            "\\{" + "accountId" + "\\}".toRegex(),
            invoker!!.escapeString(accountId.toString())
        )

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        return try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                deserialize(localVarResponse, "", PendingTransactionList::class.java) as PendingTransactionList?
            } else {
                null
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * A list of pending transactions
     * Returns all pending (aka on-hold or authorisation) transactions for a given account.
     * @param accountId The account Id is in the form &lt;account_type&gt;-&lt;account_number&gt;.
     */
    fun getV1AccountsAccountIdPendingTransactions(
        accountId: String?,
        responseListener: Response.Listener<PendingTransactionList?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = null

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV1AccountsAccountIdPendingTransactions",
                ApiException(
                    400,
                    "Missing the required parameter 'accountId' when calling getV1AccountsAccountIdPendingTransactions"
                )
            )
        }

        // create path and map variables
        val path = "/v1/accounts/{accountId}/pending-transactions".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "accountId" + "\\}".toRegex(), invoker!!.escapeString(accountId.toString()))

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse ->
                    try {
                        responseListener.onResponse(
                            deserialize(
                                localVarResponse,
                                "",
                                PendingTransactionList::class.java
                            ) as PendingTransactionList?
                        )
                    } catch (exception: ApiException) {
                        errorListener.onErrorResponse(VolleyError(exception))
                    }
                },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     * GET request for joint account invitation
     * Get joint account invitation
     * @param inviteCode
     * @return InviteResponse
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun getV1InviteCode(inviteCode: String?): InviteResponse? {
        var postBody: Any? = null
        // verify the required parameter 'inviteCode' is set
        if (inviteCode == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteCode' when calling getV1InviteCode",
                ApiException(400, "Missing the required parameter 'inviteCode' when calling getV1InviteCode")
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteCode}".replace(
            "\\{" + "inviteCode" + "\\}".toRegex(),
            invoker!!.escapeString(inviteCode.toString())
        )

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        return try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                deserialize(localVarResponse, "", InviteResponse::class.java) as InviteResponse?
            } else {
                null
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * GET request for joint account invitation
     * Get joint account invitation
     * @param inviteCode
     */
    fun getV1InviteCode(
        inviteCode: String?,
        responseListener: Response.Listener<InviteResponse?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = null

        // verify the required parameter 'inviteCode' is set
        if (inviteCode == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteCode' when calling getV1InviteCode",
                ApiException(400, "Missing the required parameter 'inviteCode' when calling getV1InviteCode")
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteCode}".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "inviteCode" + "\\}".toRegex(), invoker!!.escapeString(inviteCode.toString()))

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse ->
                    try {
                        responseListener.onResponse(
                            deserialize(
                                localVarResponse,
                                "",
                                InviteResponse::class.java
                            ) as InviteResponse?
                        )
                    } catch (exception: ApiException) {
                        errorListener.onErrorResponse(VolleyError(exception))
                    }
                },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     * A list of pending transactions filtered by description (if provided)
     * Returns all pending (aka on-hold or authorisation) transactions for a given account. The transactons can be filtered based on the query parameters.
     * @param accountId
     * @param descriptionFilter Only return transactions who&#39;s description contains this text.  The text is URL encoded.
     * @param minimumAmount The desired amount, or low amount for a range inquiry.
     * @param maximumAmount The high amount for a range inquiry.
     * @return PendingTransactionList
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun getV2PendingTransactions(
        accountId: String?,
        descriptionFilter: String?,
        minimumAmount: BigDecimal?,
        maximumAmount: BigDecimal?
    ): PendingTransactionList? {
        var postBody: Any? = null
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV2PendingTransactions",
                ApiException(400, "Missing the required parameter 'accountId' when calling getV2PendingTransactions")
            )
        }

        // create path and map variables
        val path = "/v2/accounts/{accountId}/pending-transactions".replace(
            "\\{" + "accountId" + "\\}".toRegex(),
            invoker!!.escapeString(accountId.toString())
        )

        // query params
        val queryParams: MutableList<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        queryParams.addAll(parameterToPairs("", "descriptionFilter", descriptionFilter))
        queryParams.addAll(parameterToPairs("", "minimumAmount", minimumAmount))
        queryParams.addAll(parameterToPairs("", "maximumAmount", maximumAmount))
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        return try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                deserialize(localVarResponse, "", PendingTransactionList::class.java) as PendingTransactionList?
            } else {
                null
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * A list of pending transactions filtered by description (if provided)
     * Returns all pending (aka on-hold or authorisation) transactions for a given account. The transactons can be filtered based on the query parameters.
     * @param accountId    * @param descriptionFilter Only return transactions who&#39;s description contains this text.  The text is URL encoded.   * @param minimumAmount The desired amount, or low amount for a range inquiry.   * @param maximumAmount The high amount for a range inquiry.
     */
    fun getV2PendingTransactions(
        accountId: String?,
        descriptionFilter: String?,
        minimumAmount: BigDecimal?,
        maximumAmount: BigDecimal?,
        responseListener: Response.Listener<PendingTransactionList?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = null

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV2PendingTransactions",
                ApiException(400, "Missing the required parameter 'accountId' when calling getV2PendingTransactions")
            )
        }

        // create path and map variables
        val path = "/v2/accounts/{accountId}/pending-transactions".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "accountId" + "\\}".toRegex(), invoker!!.escapeString(accountId.toString()))

        // query params
        val queryParams: MutableList<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        queryParams.addAll(parameterToPairs("", "descriptionFilter", descriptionFilter))
        queryParams.addAll(parameterToPairs("", "minimumAmount", minimumAmount))
        queryParams.addAll(parameterToPairs("", "maximumAmount", maximumAmount))
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse ->
                    try {
                        responseListener.onResponse(
                            deserialize(
                                localVarResponse,
                                "",
                                PendingTransactionList::class.java
                            ) as PendingTransactionList?
                        )
                    } catch (exception: ApiException) {
                        errorListener.onErrorResponse(VolleyError(exception))
                    }
                },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     * Get a list transactions
     * Get a list transactions. The transactions can be filtered based on the query parameters.
     * @param accountId The account Id is in the form &lt;account_type&gt;-&lt;account_number&gt;.
     * @param descriptionFilter Only return transactions who&#39;s description contains this text.  The text is URL encoded.
     * @param startDate The low date selection for a date range inquiry (inclusive).
     * @param endDate The high date selection for a date range inquiry
     * @param minimumAmount The desired amount, or low amount for a range inquiry.
     * @param maximumAmount The high amount for a range inquiry.
     * @param transactionType The transaction type to filter on.
     * @param orderDescending Transactions returned ordered by newest execution to oldest execution.  Defaults to true.
     * @return TransactionList
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun getV3Transactions(
        accountId: String?,
        descriptionFilter: String?,
        startDate: Date?,
        endDate: Date?,
        minimumAmount: Double?,
        maximumAmount: Double?,
        transactionType: String?,
        orderDescending: Boolean?
    ): TransactionList? {
        var postBody: Any? = null
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV3Transactions",
                ApiException(400, "Missing the required parameter 'accountId' when calling getV3Transactions")
            )
        }

        // create path and map variables
        val path = "/v3/accounts/{accountId}/transactions".replace(
            "\\{" + "accountId" + "\\}".toRegex(),
            invoker!!.escapeString(accountId.toString())
        )

        // query params
        val queryParams: MutableList<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        queryParams.addAll(parameterToPairs("", "descriptionFilter", descriptionFilter))
        queryParams.addAll(parameterToPairs("", "startDate", startDate))
        queryParams.addAll(parameterToPairs("", "endDate", endDate))
        queryParams.addAll(parameterToPairs("", "minimumAmount", minimumAmount))
        queryParams.addAll(parameterToPairs("", "maximumAmount", maximumAmount))
        queryParams.addAll(parameterToPairs("", "transactionType", transactionType))
        queryParams.addAll(parameterToPairs("", "orderDescending", orderDescending))
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        return try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                deserialize(localVarResponse, "", TransactionList::class.java) as TransactionList?
            } else {
                null
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * Get a list transactions
     * Get a list transactions. The transactions can be filtered based on the query parameters.
     * @param accountId The account Id is in the form &lt;account_type&gt;-&lt;account_number&gt;.   * @param descriptionFilter Only return transactions who&#39;s description contains this text.  The text is URL encoded.   * @param startDate The low date selection for a date range inquiry (inclusive).   * @param endDate The high date selection for a date range inquiry   * @param minimumAmount The desired amount, or low amount for a range inquiry.   * @param maximumAmount The high amount for a range inquiry.   * @param transactionType The transaction type to filter on.   * @param orderDescending Transactions returned ordered by newest execution to oldest execution.  Defaults to true.
     */
    fun getV3Transactions(
        accountId: String?,
        descriptionFilter: String?,
        startDate: Date?,
        endDate: Date?,
        minimumAmount: Double?,
        maximumAmount: Double?,
        transactionType: String?,
        orderDescending: Boolean?,
        responseListener: Response.Listener<TransactionList?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = null

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV3Transactions",
                ApiException(400, "Missing the required parameter 'accountId' when calling getV3Transactions")
            )
        }

        // create path and map variables
        val path = "/v3/accounts/{accountId}/transactions".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "accountId" + "\\}".toRegex(), invoker!!.escapeString(accountId.toString()))

        // query params
        val queryParams: MutableList<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        queryParams.addAll(parameterToPairs("", "descriptionFilter", descriptionFilter))
        queryParams.addAll(parameterToPairs("", "startDate", startDate))
        queryParams.addAll(parameterToPairs("", "endDate", endDate))
        queryParams.addAll(parameterToPairs("", "minimumAmount", minimumAmount))
        queryParams.addAll(parameterToPairs("", "maximumAmount", maximumAmount))
        queryParams.addAll(parameterToPairs("", "transactionType", transactionType))
        queryParams.addAll(parameterToPairs("", "orderDescending", orderDescending))
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse ->
                    try {
                        responseListener.onResponse(
                            deserialize(
                                localVarResponse,
                                "",
                                TransactionList::class.java
                            ) as TransactionList?
                        )
                    } catch (exception: ApiException) {
                        errorListener.onErrorResponse(VolleyError(exception))
                    }
                },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     * Get a list transactions, returned as paged results.
     * Get a paginated list of transactions. The transactions can be filtered based on the query parameters. When getting paged results, pass the pageSize, pageNumber, previousRequestId (unless it&#39;s the first page). Also, the other filters (startDate, endDate, minimumAmount, maximumAmount, transactionType) can be used with paging searches; but if used on the first page, they must be submitted for each page request. The descriptionFilter cannot be used in conjunction with paging requests.
     * @param accountId The account Id is in the form &lt;account_type&gt;-&lt;account_number&gt;.
     * @param pageNumber The page number to start listing transactions from (starting from page 1)
     * @param pageSize The number of transactions to include in the listing (not completely respected)
     * @param previousRequestId The request id of the first page request (if not the first request)
     * @param startDate The low date selection for a date range inquiry (inclusive).
     * @param endDate The high date selection for a date range inquiry
     * @param minimumAmount The desired amount, or low amount for a range inquiry.
     * @param maximumAmount The high amount for a range inquiry.
     * @param transactionType The transaction type to filter on.
     * @param orderDescending Transactions returned ordered by newest execution to oldest execution.  Defaults to true.
     * @return TransactionPage
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun getV3TransactionsPaged(
        accountId: String?,
        pageNumber: Int?,
        pageSize: Int?,
        previousRequestId: String?,
        startDate: Date?,
        endDate: Date?,
        minimumAmount: Double?,
        maximumAmount: Double?,
        transactionType: String?,
        orderDescending: Boolean?
    ): TransactionPage? {
        var postBody: Any? = null
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV3TransactionsPaged",
                ApiException(400, "Missing the required parameter 'accountId' when calling getV3TransactionsPaged")
            )
        }

        // create path and map variables
        val path = "/v3/accounts/{accountId}/transactions/paginated".replace(
            "\\{" + "accountId" + "\\}".toRegex(),
            invoker!!.escapeString(accountId.toString())
        )

        // query params
        val queryParams: MutableList<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        queryParams.addAll(parameterToPairs("", "pageNumber", pageNumber))
        queryParams.addAll(parameterToPairs("", "pageSize", pageSize))
        queryParams.addAll(parameterToPairs("", "previousRequestId", previousRequestId))
        queryParams.addAll(parameterToPairs("", "startDate", startDate))
        queryParams.addAll(parameterToPairs("", "endDate", endDate))
        queryParams.addAll(parameterToPairs("", "minimumAmount", minimumAmount))
        queryParams.addAll(parameterToPairs("", "maximumAmount", maximumAmount))
        queryParams.addAll(parameterToPairs("", "transactionType", transactionType))
        queryParams.addAll(parameterToPairs("", "orderDescending", orderDescending))
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        return try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                deserialize(localVarResponse, "", TransactionPage::class.java) as TransactionPage?
            } else {
                null
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * Get a list transactions, returned as paged results.
     * Get a paginated list of transactions. The transactions can be filtered based on the query parameters. When getting paged results, pass the pageSize, pageNumber, previousRequestId (unless it&#39;s the first page). Also, the other filters (startDate, endDate, minimumAmount, maximumAmount, transactionType) can be used with paging searches; but if used on the first page, they must be submitted for each page request. The descriptionFilter cannot be used in conjunction with paging requests.
     * @param accountId The account Id is in the form &lt;account_type&gt;-&lt;account_number&gt;.   * @param pageNumber The page number to start listing transactions from (starting from page 1)   * @param pageSize The number of transactions to include in the listing (not completely respected)   * @param previousRequestId The request id of the first page request (if not the first request)   * @param startDate The low date selection for a date range inquiry (inclusive).   * @param endDate The high date selection for a date range inquiry   * @param minimumAmount The desired amount, or low amount for a range inquiry.   * @param maximumAmount The high amount for a range inquiry.   * @param transactionType The transaction type to filter on.   * @param orderDescending Transactions returned ordered by newest execution to oldest execution.  Defaults to true.
     */
    fun getV3TransactionsPaged(
        accountId: String?,
        pageNumber: Int?,
        pageSize: Int?,
        previousRequestId: String?,
        startDate: Date?,
        endDate: Date?,
        minimumAmount: Double?,
        maximumAmount: Double?,
        transactionType: String?,
        orderDescending: Boolean?,
        responseListener: Response.Listener<TransactionPage?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = null

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling getV3TransactionsPaged",
                ApiException(400, "Missing the required parameter 'accountId' when calling getV3TransactionsPaged")
            )
        }

        // create path and map variables
        val path = "/v3/accounts/{accountId}/transactions/paginated".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "accountId" + "\\}".toRegex(), invoker!!.escapeString(accountId.toString()))

        // query params
        val queryParams: MutableList<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        queryParams.addAll(parameterToPairs("", "pageNumber", pageNumber))
        queryParams.addAll(parameterToPairs("", "pageSize", pageSize))
        queryParams.addAll(parameterToPairs("", "previousRequestId", previousRequestId))
        queryParams.addAll(parameterToPairs("", "startDate", startDate))
        queryParams.addAll(parameterToPairs("", "endDate", endDate))
        queryParams.addAll(parameterToPairs("", "minimumAmount", minimumAmount))
        queryParams.addAll(parameterToPairs("", "maximumAmount", maximumAmount))
        queryParams.addAll(parameterToPairs("", "transactionType", transactionType))
        queryParams.addAll(parameterToPairs("", "orderDescending", orderDescending))
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "GET",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse ->
                    try {
                        responseListener.onResponse(
                            deserialize(
                                localVarResponse,
                                "",
                                TransactionPage::class.java
                            ) as TransactionPage?
                        )
                    } catch (exception: ApiException) {
                        errorListener.onErrorResponse(VolleyError(exception))
                    }
                },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     * Regenerate an invite code for an existing invite
     * Regenerate an invite for an existing invite
     * @param inviteId
     * @return AccountInviteResponse
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun postV1AccountInviteRegenerate(inviteId: String?): AccountInviteResponse? {
        var postBody: Any? = null
        // verify the required parameter 'inviteId' is set
        if (inviteId == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteId' when calling postV1AccountInviteRegenerate",
                ApiException(
                    400,
                    "Missing the required parameter 'inviteId' when calling postV1AccountInviteRegenerate"
                )
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteId}/regenerate".replace(
            "\\{" + "inviteId" + "\\}".toRegex(),
            invoker!!.escapeString(inviteId.toString())
        )

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        return try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "POST",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                deserialize(localVarResponse, "", AccountInviteResponse::class.java) as AccountInviteResponse?
            } else {
                null
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * Regenerate an invite code for an existing invite
     * Regenerate an invite for an existing invite
     * @param inviteId
     */
    fun postV1AccountInviteRegenerate(
        inviteId: String?,
        responseListener: Response.Listener<AccountInviteResponse?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = null

        // verify the required parameter 'inviteId' is set
        if (inviteId == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteId' when calling postV1AccountInviteRegenerate",
                ApiException(
                    400,
                    "Missing the required parameter 'inviteId' when calling postV1AccountInviteRegenerate"
                )
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteId}/regenerate".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "inviteId" + "\\}".toRegex(), invoker!!.escapeString(inviteId.toString()))

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf<String>()
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "POST",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse ->
                    try {
                        responseListener.onResponse(
                            deserialize(
                                localVarResponse,
                                "",
                                AccountInviteResponse::class.java
                            ) as AccountInviteResponse?
                        )
                    } catch (exception: ApiException) {
                        errorListener.onErrorResponse(VolleyError(exception))
                    }
                },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     *
     * Request to accept an invite
     * @param inviteId
     * @param acceptInviteRequest
     * @return void
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun postV1InviteCodeAccept(inviteId: String?, acceptInviteRequest: AcceptInviteRequest?) {
        var postBody: Any? = acceptInviteRequest
        // verify the required parameter 'inviteId' is set
        if (inviteId == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteId' when calling postV1InviteCodeAccept",
                ApiException(400, "Missing the required parameter 'inviteId' when calling postV1InviteCodeAccept")
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteId}/accept".replace(
            "\\{" + "inviteId" + "\\}".toRegex(),
            invoker!!.escapeString(inviteId.toString())
        )

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf(
            "application/json"
        )
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "POST",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                return
            } else {
                return
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     *
     * Request to accept an invite
     * @param inviteId    * @param acceptInviteRequest
     */
    fun postV1InviteCodeAccept(
        inviteId: String?,
        acceptInviteRequest: AcceptInviteRequest?,
        responseListener: Response.Listener<String?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = acceptInviteRequest

        // verify the required parameter 'inviteId' is set
        if (inviteId == null) {
            val error = VolleyError(
                "Missing the required parameter 'inviteId' when calling postV1InviteCodeAccept",
                ApiException(400, "Missing the required parameter 'inviteId' when calling postV1InviteCodeAccept")
            )
        }

        // create path and map variables
        val path = "/v1/account-invite/{inviteId}/accept".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "inviteId" + "\\}".toRegex(), invoker!!.escapeString(inviteId.toString()))

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf(
            "application/json"
        )
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "POST",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse -> responseListener.onResponse(localVarResponse) },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }

    /**
     * Invite to a joint account
     * Create an invite for a joint account
     * @param accountId
     * @param accountInvite
     * @return AccountInviteResponse
     */
    @Throws(TimeoutException::class, ExecutionException::class, InterruptedException::class, ApiException::class)
    fun postV3AccountsInvite(accountId: String?, accountInvite: AccountInvite?): AccountInviteResponse? {
        var postBody: Any? = accountInvite
        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling postV3AccountsInvite",
                ApiException(400, "Missing the required parameter 'accountId' when calling postV3AccountsInvite")
            )
        }

        // create path and map variables
        val path = "/v3/accounts/{accountId}/invite".replace(
            "\\{" + "accountId" + "\\}".toRegex(),
            invoker!!.escapeString(accountId.toString())
        )

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf(
            "application/json"
        )
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        return try {
            val localVarResponse = invoker!!.invokeAPI(
                basePath,
                path,
                "POST",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames
            )
            if (localVarResponse != null) {
                deserialize(localVarResponse, "", AccountInviteResponse::class.java) as AccountInviteResponse?
            } else {
                null
            }
        } catch (ex: ApiException) {
            throw ex
        } catch (ex: InterruptedException) {
            throw ex
        } catch (ex: ExecutionException) {
            if (ex.cause is VolleyError) {
                val volleyError = ex.cause as VolleyError?
                if (volleyError!!.networkResponse != null) {
                    throw ApiException(volleyError.networkResponse.statusCode, volleyError.message)
                }
            }
            throw ex
        } catch (ex: TimeoutException) {
            throw ex
        }
    }

    /**
     * Invite to a joint account
     * Create an invite for a joint account
     * @param accountId    * @param accountInvite
     */
    fun postV3AccountsInvite(
        accountId: String?,
        accountInvite: AccountInvite?,
        responseListener: Response.Listener<AccountInviteResponse?>,
        errorListener: Response.ErrorListener
    ) {
        var postBody: Any? = accountInvite

        // verify the required parameter 'accountId' is set
        if (accountId == null) {
            val error = VolleyError(
                "Missing the required parameter 'accountId' when calling postV3AccountsInvite",
                ApiException(400, "Missing the required parameter 'accountId' when calling postV3AccountsInvite")
            )
        }

        // create path and map variables
        val path = "/v3/accounts/{accountId}/invite".replace("\\{format\\}".toRegex(), "json")
            .replace("\\{" + "accountId" + "\\}".toRegex(), invoker!!.escapeString(accountId.toString()))

        // query params
        val queryParams: List<Pair> = ArrayList()
        // header params
        val headerParams: Map<String?, String?> = HashMap()
        // form params
        val formParams: Map<String?, String?> = HashMap()
        val contentTypes = arrayOf(
            "application/json"
        )
        val contentType = if (contentTypes.size > 0) contentTypes[0] else "application/json"
        if (contentType.startsWith("multipart/form-data")) {
            // file uploading
            val localVarBuilder = MultipartEntityBuilder.create()
            val httpEntity = localVarBuilder.build()
            postBody = httpEntity
        } else {
            // normal form params
        }
        val authNames = arrayOf<String>()
        try {
            invoker!!.invokeAPI(basePath,
                path,
                "POST",
                queryParams,
                postBody,
                headerParams,
                formParams,
                contentType,
                authNames,
                Response.Listener { localVarResponse ->
                    try {
                        responseListener.onResponse(
                            deserialize(
                                localVarResponse,
                                "",
                                AccountInviteResponse::class.java
                            ) as AccountInviteResponse?
                        )
                    } catch (exception: ApiException) {
                        errorListener.onErrorResponse(VolleyError(exception))
                    }
                },
                Response.ErrorListener { error -> errorListener.onErrorResponse(error) })
        } catch (ex: ApiException) {
            errorListener.onErrorResponse(VolleyError(ex))
        }
    }
}