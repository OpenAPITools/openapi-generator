/**
 * Internet Banking
 * Public API for Internet Banking (IB) clients - web, iOS, Android. A combination of specifications from Backbase, as well as home-grown specifications.
 *
 * The version of the OpenAPI document: v1
 * Contact: support@greater.com.au
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
package org.openapitools.client

import com.android.volley.*
import org.openapitools.client.auth.Authentication
import org.openapitools.client.ApiInvoker
import org.apache.http.entity.ContentType
import org.apache.http.Consts
import java.lang.RuntimeException
import java.lang.StringBuilder
import kotlin.jvm.JvmOverloads
import kotlin.Throws
import org.openapitools.client.ApiException
import java.lang.Class
import org.openapitools.client.JsonUtil
import com.google.gson.JsonParseException
import java.lang.Exception
import java.net.URLEncoder
import java.io.UnsupportedEncodingException
import org.openapitools.client.auth.HttpBasicAuth
import org.openapitools.client.auth.ApiKeyAuth
import java.lang.InterruptedException
import java.util.concurrent.ExecutionException
import java.util.concurrent.TimeoutException
import com.android.volley.toolbox.RequestFuture
import org.openapitools.client.request.GetRequest
import org.openapitools.client.request.PostRequest
import org.apache.http.entity.StringEntity
import org.apache.http.HttpEntity
import org.openapitools.client.request.PutRequest
import org.openapitools.client.request.DeleteRequest
import org.openapitools.client.request.PatchRequest
import com.android.volley.toolbox.NoCache
import com.android.volley.toolbox.HttpStack
import com.android.volley.toolbox.HurlStack
import com.android.volley.toolbox.BasicNetwork
import java.text.ParseException
import java.text.SimpleDateFormat
import java.util.*
import java.util.concurrent.TimeUnit

class ApiInvoker private constructor(
    cache: Cache?,
    network: Network?,
    threadPoolSize: Int,
    delivery: ResponseDelivery?,
    connectionTimeout: Int
) {
    private val defaultHeaderMap: MutableMap<String, String> = HashMap()
    private var mRequestQueue: RequestQueue? = null

    /**
     * Get authentications (key: authentication name, value: authentication).
     */
    var authentications: Map<String, Authentication>? = null
        private set
    var connectionTimeout: Int

    companion object {
        private var INSTANCE: ApiInvoker? = null

        /** Content type "text/plain" with UTF-8 encoding.  */
        val TEXT_PLAIN_UTF8 = ContentType.create("text/plain", Consts.UTF_8)

        /**
         * ISO 8601 date time format.
         * @see https://en.wikipedia.org/wiki/ISO_8601
         */
        val DATE_TIME_FORMAT = SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSZ")

        /**
         * ISO 8601 date format.
         * @see https://en.wikipedia.org/wiki/ISO_8601
         */
        val DATE_FORMAT = SimpleDateFormat("yyyy-MM-dd")
        fun setUserAgent(userAgent: String) {
            INSTANCE!!.addDefaultHeader("User-Agent", userAgent)
        }

        fun parseDateTime(str: String?): Date {
            return try {
                DATE_TIME_FORMAT.parse(str)
            } catch (e: ParseException) {
                throw RuntimeException(e)
            }
        }

        fun parseDate(str: String?): Date {
            return try {
                DATE_FORMAT.parse(str)
            } catch (e: ParseException) {
                throw RuntimeException(e)
            }
        }

        fun formatDateTime(datetime: Date?): String {
            return DATE_TIME_FORMAT.format(datetime)
        }

        fun formatDate(date: Date?): String {
            return DATE_FORMAT.format(date)
        }

        fun parameterToString(param: Any?): String {
            return if (param == null) {
                ""
            } else if (param is Date) {
                formatDateTime(param as Date?)
            } else if (param is Collection<*>) {
                val b = StringBuilder()
                for (o in param) {
                    if (b.length > 0) {
                        b.append(",")
                    }
                    b.append(o.toString())
                }
                b.toString()
            } else {
                param.toString()
            }
        }

        /*
    Format to {@code Pair} objects.
  */
        @JvmStatic
        fun parameterToPairs(collectionFormat: String?, name: String?, value: Any?): List<Pair> {
            var collectionFormat = collectionFormat
            val params: MutableList<Pair> = ArrayList()

            // preconditions
            if (name == null || name.isEmpty() || value == null) return params
            var valueCollection: Collection<*>? = null
            valueCollection = if (value is Collection<*>) {
                value
            } else {
                params.add(Pair(name, parameterToString(value)))
                return params
            }
            if (valueCollection!!.isEmpty()) {
                return params
            }

            // get the collection format
            collectionFormat =
                if (collectionFormat == null || collectionFormat.isEmpty()) "csv" else collectionFormat // default: csv

            // create the params based on the collection format
            if (collectionFormat == "multi") {
                for (item in valueCollection) {
                    params.add(Pair(name, parameterToString(item)))
                }
                return params
            }
            var delimiter = ","
            if (collectionFormat == "csv") {
                delimiter = ","
            } else if (collectionFormat == "ssv") {
                delimiter = " "
            } else if (collectionFormat == "tsv") {
                delimiter = "\t"
            } else if (collectionFormat == "pipes") {
                delimiter = "|"
            }
            val sb = StringBuilder()
            for (item in valueCollection) {
                sb.append(delimiter)
                sb.append(parameterToString(item))
            }
            params.add(Pair(name, sb.substring(1)))
            return params
        }

        @JvmOverloads
        fun initializeInstance(
            cache: Cache? = null,
            network: Network? = null,
            threadPoolSize: Int = 0,
            delivery: ResponseDelivery? = null,
            connectionTimeout: Int = 30
        ) {
            INSTANCE = ApiInvoker(cache, network, threadPoolSize, delivery, connectionTimeout)
            setUserAgent("OpenAPI-Generator/1.0.0/android")

            // Setup authentications (key: authentication name, value: authentication).
            INSTANCE!!.authentications = HashMap()
            // Prevent the authentications from being modified.
            INSTANCE!!.authentications = Collections.unmodifiableMap(INSTANCE!!.authentications)
        }

        @JvmStatic
        val instance: ApiInvoker?
            get() {
                if (INSTANCE == null) initializeInstance()
                return INSTANCE
            }

        @JvmStatic
        @Throws(ApiException::class)
        fun deserialize(json: String?, containerType: String?, cls: Class<*>): Any? {
            return try {
                if ("list".equals(containerType, ignoreCase = true) || "array".equals(
                        containerType,
                        ignoreCase = true
                    )
                ) {
                    JsonUtil.deserializeToList(json, cls)
                } else if (String::class.java == cls) {
                    if (json != null && json.startsWith("\"") && json.endsWith("\"") && json.length > 1) json.substring(
                        1,
                        json.length - 1
                    ) else json
                } else {
                    JsonUtil.deserializeToObject<Any>(json, cls)
                }
            } catch (e: JsonParseException) {
                throw ApiException(500, e.message)
            }
        }

        @Throws(ApiException::class)
        fun serialize(obj: Any?): String? {
            return try {
                if (obj != null) JsonUtil.serialize(obj) else null
            } catch (e: Exception) {
                throw ApiException(500, e.message)
            }
        }

        init {
            // Use UTC as the default time zone.
            DATE_TIME_FORMAT.timeZone = TimeZone.getTimeZone("UTC")
            DATE_FORMAT.timeZone = TimeZone.getTimeZone("UTC")
        }
    }

    fun addDefaultHeader(key: String, value: String) {
        defaultHeaderMap[key] = value
    }

    fun escapeString(str: String): String {
        return try {
            URLEncoder.encode(str, "UTF-8")
        } catch (e: UnsupportedEncodingException) {
            str
        }
    }

    /**
     * Get authentication for the given name.
     *
     * @param authName The authentication name
     * @return The authentication, null if not found
     */
    fun getAuthentication(authName: String): Authentication? {
        return authentications!![authName]
    }

    /**
     * Helper method to set username for the first HTTP basic authentication.
     */
    fun setUsername(username: String?) {
        for (auth in authentications!!.values) {
            if (auth is HttpBasicAuth) {
                auth.username = username
                return
            }
        }
        throw RuntimeException("No HTTP basic authentication configured!")
    }

    /**
     * Helper method to set password for the first HTTP basic authentication.
     */
    fun setPassword(password: String?) {
        for (auth in authentications!!.values) {
            if (auth is HttpBasicAuth) {
                auth.password = password
                return
            }
        }
        throw RuntimeException("No HTTP basic authentication configured!")
    }

    /**
     * Helper method to set API key value for the first API key authentication.
     */
    fun setApiKey(apiKey: String?) {
        for (auth in authentications!!.values) {
            if (auth is ApiKeyAuth) {
                auth.apiKey = apiKey
                return
            }
        }
        throw RuntimeException("No API key authentication configured!")
    }

    /**
     * Helper method to set API key prefix for the first API key authentication.
     */
    fun setApiKeyPrefix(apiKeyPrefix: String?) {
        for (auth in authentications!!.values) {
            if (auth is ApiKeyAuth) {
                auth.apiKeyPrefix = apiKeyPrefix
                return
            }
        }
        throw RuntimeException("No API key authentication configured!")
    }

    /**
     * Update query and header parameters based on authentication settings.
     *
     * @param authNames The authentications to apply
     */
    private fun updateParamsForAuth(
        authNames: Array<String>,
        queryParams: List<Pair>?,
        headerParams: Map<String?, String?>
    ) {
        for (authName in authNames) {
            val auth = authentications!![authName] ?: throw RuntimeException("Authentication undefined: $authName")
            auth.applyToParams(queryParams, headerParams)
        }
    }

    @Throws(ApiException::class, InterruptedException::class, ExecutionException::class, TimeoutException::class)
    fun invokeAPI(
        host: String,
        path: String,
        method: String,
        queryParams: List<Pair>?,
        body: Any?,
        headerParams: Map<String?, String?>,
        formParams: Map<String?, String?>,
        contentType: String,
        authNames: Array<String>
    ): String {
        return try {
            val future = RequestFuture.newFuture<String>()
            val request: Request<*>? = createRequest(
                host,
                path,
                method,
                queryParams,
                body,
                headerParams,
                formParams,
                contentType,
                authNames,
                future,
                future
            )
            if (request != null) {
                mRequestQueue!!.add(request)
                future[connectionTimeout.toLong(), TimeUnit.SECONDS]
            } else {
                "no data"
            }
        } catch (ex: UnsupportedEncodingException) {
            throw ApiException(0, "UnsupportedEncodingException")
        }
    }

    @Throws(ApiException::class)
    fun invokeAPI(
        host: String,
        path: String,
        method: String,
        queryParams: List<Pair>?,
        body: Any?,
        headerParams: Map<String?, String?>,
        formParams: Map<String?, String?>,
        contentType: String,
        authNames: Array<String>,
        stringRequest: Response.Listener<String>?,
        errorListener: Response.ErrorListener?
    ) {
        try {
            val request: Request<*>? = createRequest(
                host,
                path,
                method,
                queryParams,
                body,
                headerParams,
                formParams,
                contentType,
                authNames,
                stringRequest,
                errorListener
            )
            if (request != null) {
                mRequestQueue!!.add(request)
            }
        } catch (ex: UnsupportedEncodingException) {
            throw ApiException(0, "UnsupportedEncodingException")
        }
    }

    @Throws(ApiException::class, UnsupportedEncodingException::class)
    fun createRequest(
        host: String,
        path: String,
        method: String,
        queryParams: List<Pair>?,
        body: Any?,
        headerParams: Map<String?, String?>,
        formParams: Map<String?, String?>,
        contentType: String,
        authNames: Array<String>,
        stringRequest: Response.Listener<String>?,
        errorListener: Response.ErrorListener?
    ): Request<String>? {
        val b = StringBuilder()
        b.append("?")
        updateParamsForAuth(authNames, queryParams, headerParams)
        if (queryParams != null) {
            for (queryParam in queryParams) {
                if (!queryParam.name.isEmpty()) {
                    b.append(escapeString(queryParam.name))
                    b.append("=")
                    b.append(escapeString(queryParam.value))
                    b.append("&")
                }
            }
        }
        val querystring = b.substring(0, b.length - 1)
        val url = host + path + querystring
        val headers = HashMap<String?, String?>()
        for (key in headerParams.keys) {
            headers[key] = headerParams[key]
        }
        for (key in defaultHeaderMap.keys) {
            if (!headerParams.containsKey(key)) {
                headers[key] = defaultHeaderMap[key]
            }
        }
        headers["Accept"] = "application/json"

        // URL encoded string from form parameters
        var formParamStr: String? = null

        // for form data
        if ("application/x-www-form-urlencoded" == contentType) {
            val formParamBuilder = StringBuilder()

            // encode the form params
            for (key in formParams.keys) {
                val value = formParams[key]
                if (value != null && "" != value.trim { it <= ' ' }) {
                    if (formParamBuilder.length > 0) {
                        formParamBuilder.append("&")
                    }
                    try {
                        formParamBuilder.append(URLEncoder.encode(key, "utf8")).append("=")
                            .append(URLEncoder.encode(value, "utf8"))
                    } catch (e: Exception) {
                        // move on to next
                    }
                }
            }
            formParamStr = formParamBuilder.toString()
        }
        var request: Request<*>? = null
        if ("GET" == method) {
            request = GetRequest(url, headers, null, stringRequest, errorListener)
        } else if ("POST" == method) {
            request = null
            request = if (formParamStr != null) {
                PostRequest(
                    url,
                    headers,
                    contentType,
                    StringEntity(formParamStr, "UTF-8"),
                    stringRequest,
                    errorListener
                )
            } else if (body != null) {
                if (body is HttpEntity) {
                    PostRequest(url, headers, null, body as HttpEntity?, stringRequest, errorListener)
                } else {
                    PostRequest(
                        url,
                        headers,
                        contentType,
                        StringEntity(serialize(body), "UTF-8"),
                        stringRequest,
                        errorListener
                    )
                }
            } else {
                PostRequest(url, headers, null, null, stringRequest, errorListener)
            }
        } else if ("PUT" == method) {
            request = null
            request = if (formParamStr != null) {
                PutRequest(url, headers, contentType, StringEntity(formParamStr, "UTF-8"), stringRequest, errorListener)
            } else if (body != null) {
                if (body is HttpEntity) {
                    PutRequest(url, headers, null, body as HttpEntity?, stringRequest, errorListener)
                } else {
                    PutRequest(
                        url,
                        headers,
                        contentType,
                        StringEntity(serialize(body), "UTF-8"),
                        stringRequest,
                        errorListener
                    )
                }
            } else {
                PutRequest(url, headers, null, null, stringRequest, errorListener)
            }
        } else if ("DELETE" == method) {
            request = null
            request = if (formParamStr != null) {
                DeleteRequest(
                    url,
                    headers,
                    contentType,
                    StringEntity(formParamStr, "UTF-8"),
                    stringRequest,
                    errorListener
                )
            } else if (body != null) {
                if (body is HttpEntity) {
                    DeleteRequest(url, headers, null, body as HttpEntity?, stringRequest, errorListener)
                } else {
                    DeleteRequest(
                        url,
                        headers,
                        contentType,
                        StringEntity(serialize(body), "UTF-8"),
                        stringRequest,
                        errorListener
                    )
                }
            } else {
                DeleteRequest(url, headers, null, null, stringRequest, errorListener)
            }
        } else if ("PATCH" == method) {
            request = null
            request = if (formParamStr != null) {
                PatchRequest(
                    url,
                    headers,
                    contentType,
                    StringEntity(formParamStr, "UTF-8"),
                    stringRequest,
                    errorListener
                )
            } else if (body != null) {
                if (body is HttpEntity) {
                    PatchRequest(url, headers, null, body as HttpEntity?, stringRequest, errorListener)
                } else {
                    PatchRequest(
                        url,
                        headers,
                        contentType,
                        StringEntity(serialize(body), "UTF-8"),
                        stringRequest,
                        errorListener
                    )
                }
            } else {
                PatchRequest(url, headers, null, null, stringRequest, errorListener)
            }
        }
        if (request != null) {
            request.retryPolicy = DefaultRetryPolicy(
                TimeUnit.SECONDS.toMillis(connectionTimeout.toLong()).toInt(),
                DefaultRetryPolicy.DEFAULT_MAX_RETRIES,
                DefaultRetryPolicy.DEFAULT_BACKOFF_MULT
            )
        }
        return request
    }

    private fun initConnectionRequest(cache: Cache, network: Network) {
        mRequestQueue = RequestQueue(cache, network)
        mRequestQueue!!.start()
    }

    private fun initConnectionRequest(cache: Cache, network: Network, threadPoolSize: Int, delivery: ResponseDelivery) {
        mRequestQueue = RequestQueue(cache, network, threadPoolSize, delivery)
        mRequestQueue!!.start()
    }

    fun stopQueue() {
        mRequestQueue!!.stop()
    }

    init {
        var cache = cache
        var network = network
        if (cache == null) cache = NoCache()
        if (network == null) {
            val stack: HttpStack = HurlStack()
            network = BasicNetwork(stack)
        }
        if (delivery == null) {
            initConnectionRequest(cache, network)
        } else {
            initConnectionRequest(cache, network, threadPoolSize, delivery)
        }
        this.connectionTimeout = connectionTimeout
    }
}